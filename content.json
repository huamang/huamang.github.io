{"meta":{"title":"Huamang's Blog","subtitle":"向美好的日子进发","description":"回避现实的人，未来将更不理想","author":"huamang","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-12-24T06:42:35.000Z","updated":"2020-12-24T07:35:50.066Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"向美好的日子出发 我的CSDN：https://blog.csdn.net/m0_51078229"},{"title":"tags","date":"2020-12-24T06:45:13.000Z","updated":"2020-12-24T07:22:42.156Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Javaweb学习笔记1","slug":"Javaweb学习笔记1（JDBC基本操作）","date":"2021-04-07T16:00:00.000Z","updated":"2021-04-07T17:13:24.947Z","comments":true,"path":"2021/04/08/Javaweb学习笔记1（JDBC基本操作）/","link":"","permalink":"http://example.com/2021/04/08/Javaweb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88JDBC%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89/","excerpt":"","text":"JDBCjdbc中文名叫java数据库连接 创建项目创建项目，引入jar包我的jdk是1.8的，所以用的比较老的jar包官网下载https://downloads.mysql.com/archives/c-j/ 导入jar包，并构建好，怎么构建 在数据库里面建立好一个库，我命名为java，建个表test加点数据进去 代码实现分为四个步骤 加载驱动 获得连接 基本操作 释放资源 实现的代码 12345678910111213141516171819202122232425262728293031323334353637383940package com.jdbctest;import org.junit.Test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class JDBCDemo1 &#123; // 使用junit的test来调试 @Test public void demo1() throws Exception&#123; // 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 获得连接,把结果放到Connection类型的对象里面，后面的两个参数是数据库的用户名和密码 Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/java&quot;,&quot;root&quot;,&quot;&quot;); // 基本操作 // 获取sql语句的对象 Statement statement = con.createStatement(); // 编写sql语句 String sql = &quot;select * from test&quot;; // 执行sql语句,把结果放到ResultSet类型的对象里面 ResultSet res = statement.executeQuery(sql); // 遍历结果集,打印出id，username，passwd while (res.next())&#123; System.out.print(res.getString(&quot;id&quot;)+&#x27; &#x27;); System.out.print(res.getString(&quot;username&quot;)+&#x27; &#x27;); System.out.print(res.getString(&quot;passwd&quot;)); System.out.println(); &#125; // 释放资源，依次释放 res.close(); statement.close(); con.close(); &#125;&#125; 查询成功！ JDBC的API详解DraverManager一个驱动管理类作用： 注册驱动 获得与数据库的连接 注册驱动registerDriver()开发过程中是不用这个来注册的 因为这个方法的参数是一个Driver类，而实例化Draver类的时候就会自动注册了如果手动在去注册的话就会注册两次了 平常的开发中，我们通常使用Class.forName(&quot;com.mysql.jbdc.Driver&quot;);这个forName()的作用是： Class.forName 方法的作用，就是初始化给定的类。而我们给定的 MySQL 的 Driver 类中，它在静态代码块中通过 JDBC 的 DriverManager 注册了一下驱动。 获得与数据库的连接getConnection(url,user,passwd)参数 url：一种形式的数据库URL user：数据库用户名 password：用户的密码 主要说下这个url： 1jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;java jdbc：连接数据库的协议 mysql：jdbc的一个子协议，用于区分数据库 localhost：表示mysql数据库服务器的主机地址，如果在本地就是localhost，如果是外网的就填外网的ip 3306：mysql的端口号，可以在配置文件里面修改的 java：所连接数据库的名称 如果连接的是本机而且端口号没去改，localhost:3306还可以省略掉 1jdbc:mysql:&#x2F;&#x2F;&#x2F;java Connection与数据库的一个连接对象 作用： 创建执行sql语句的对象 管理事务 创建执行sql语句的对象createStatement()创建一个对象来将sql语句发送到数据库，返回的Statement类型的对象就可以用来执行sql语句除了这个createStatement()，还有两个方法也有类似的作用 CallableStatement() PreparedStatement() 区别： createStatement()：执行sql CallableStatement()：执行数据库的存储过程 PreparedStatement()：执行sql，可以对sql进行预处理防止sql注入 后期主要都是用 PreparedStatement()来创建对象 事务管理要进行事务管理就要先关闭自动提交提交事务的方法：commit()回滚事务：rollback Statement主要作用是用来执行sql语句作用 执行sql语句 执行批处理 执行sql语句 execute() executeQuery() executeUpdate() 区别： boolean execute()：可以执行查询、修改、添加、删除的sql语句返回值：如果第一个结果为ResultSet对象，则返回true ;如果其为更新计数或者不存在任何结果，则返回false抛出简单来说就是如果执行查询语句就返回true，其他的返回false ResultSet executeQuery()：只能用于查询语句，查询到的结果一般是表格状的，会封装到ResultSet里面 int executeUpdate()：执行修改、添加、删除语句返回值：插入3条记录就返回3，删除5条记录就返回5 常用的是后面两个语句 执行批处理 addBatch()：添加到批处理 clearBatch()：清空批处理 executeBatch()：把一批sql语句传给mysql执行，返回更新了的计数组成数组 Resultselect语句执行后得到的结果集（只有select才行） 结果集的遍历 next()：让指针跳到下一条记录最开始指针是指向记录外面，执行了next后指针就指向了第一个数据指针一直往下跳，只要指针的指向有数据就返回true，当执行了next后没有记录了，就会返回false如下图，执行了四次next，第五次next就没有数据了，指针指向了空，返回了false，这样就循环了四次 结果集的获取用get数据类型()来获取结果集 getInt() getLong() getString() getObject()等等 这里的getObject()可以获取任意类型的值 这一类的getXxx()的方法一般都有一个重载的方法，**开发中通常使用字段名的getXxx()**，用字段名更精准，字段的序号容易改变 getXxx(int columnindex)：字段的序号 getXxx(String columnName)：字段名 资源释放JDBC程序执行结束后，将与数据库进行交互的对象释放掉，通常是 Resultset Statement Connection 这几个对象中尤其是Connection对象是非常稀有的。数据库的连接是有限制的，如果一次性有太多的连接，那么就不能再建立连接了，所以这个对象一定要做到尽量晚创建，尽早释放掉。 要把资源释放写入到finally的代码块里面（finally表示一定会被执行的代码块） 资源释放的规范操作 12345678910111213141516171819202122232425finally &#123; // 释放result if (res != null) &#123; try &#123; res.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; // 手动设空，让java回收机制更快的回收掉，提高效率 rs = null; &#125; // 释放statement if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; stmt = null; &#125; // 释放connection if (con != null) &#123; try &#123; con.close(); &#125; catch (SQLException sqlEx) &#123; // ignore &#125; con = null; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA学习笔记5","slug":"JAVA学习笔记5（Scanner，String，Arrays，Math,，异常）","date":"2021-03-14T16:00:00.000Z","updated":"2021-04-07T17:12:56.871Z","comments":true,"path":"2021/03/15/JAVA学习笔记5（Scanner，String，Arrays，Math,，异常）/","link":"","permalink":"http://example.com/2021/03/15/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%EF%BC%88Scanner%EF%BC%8CString%EF%BC%8CArrays%EF%BC%8CMath,%EF%BC%8C%E5%BC%82%E5%B8%B8%EF%BC%89/","excerpt":"","text":"常用类Scanner类用于获取键盘的输入 方法利用System.in来把输入内容转换为一个流 1Scanner s = new Scanner(System.in); 成员方法 next()方法，获取输入的字符串读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据1234567891011121314151617import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; // 从键盘接收数据 Scanner scan = new Scanner(System.in); // next方式接收字符串 System.out.println(&quot;next方式接收：&quot;); // 判断是否还有输入 if (scan.hasNext()) &#123; String str1 = scan.next(); System.out.println(&quot;输入的数据为：&quot; + str1); &#125; scan.close(); &#125;&#125; next和nextLine的区别 next()方法读取到空白符就结束； nextLine()读取到回车结束； next():1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()：1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。2、可以获得空格。 String类不可变性: 字符串是常量,它的值在创建之后不能更改只能是变量引用地址的改变,不能是值的改变字符串变量相加：先开空间，再加内容字符串常量相加：先加，再找，没有再开空间 String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 常用方法1234567891011121314151617181920212223242526比较字符串的内容是否相同，严格区分大小写boolean equals(Object obj):比较字符串的内容是否相同，不考虑大小写boolean equalsIgnoreCase(String str):判断字符串的内容是否为空boolean isEmpty():返回字符串的长度。字符的个数。int length():返回字符串中指定位置的字符。char charAt(int index):返回指定&quot;字符&quot;在字符串中第一次出现的位置int indexOf(int ch):返回指定&quot;字符串&quot;在字符串中第一次出现的位置int indexOf(String str):返回从指定位置开始到指定位置结束的子串,左闭右开String substring(int start,int end):字符的替换String replace(char old,char new) StringBuffer由于字符串是不变的，我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题 构造方法声明字符串长度 1234public StringBuffer(int capacity)例：创建一个长度为10的字符串StringBuilder sb = new StringBuilder(10); 创建对象时直接赋值字符串 1234public StringBuffer(String str)例:StringBuffer sBuffer = new StringBuffer(&quot;hello&quot;); 成员方法 添加功能 123public StringBuffer append(String str)public StringBuffer insert(int offset,String str) 删除功能 123public StringBuffer deleteCharAt(int index)public StringBuffer delete(int start,int end) 替换功能 1public StringBuffer replace(int start,int end,String str) 反转功能 1public StringBuffer reverse() 截取功能 12public String substring(int start)public String substring(int start,int end) Arrays成员方法 转数组为字符串 1public static String toString(int[] a) 排序 1public static void sort(int[] a) 二分查找 1public static int binarySearch(int[] a,int key) Math类主要记录一下Math.random的用法 这个方法获取的随机数范围为 0.0 =&lt; Math.random &lt; 1.0 若需要[x，y)范围的伪随机数1Math.random()*(y-x)+x 若需要[x，y]范围的伪随机整数1(int)Math.random()*(y-x+1)+x 异常处理抛出异常：throw，throws捕获异常：try，catch，finally try…catch… 执行流程:程序从try里面的代码开始执行出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理执行完毕之后，程序还可以继续往下执行 例如： 1234567public static void method()&#123; try &#123; int[]arr = &#123;1,2,3&#125;; System.out.println(arr[3]);&#125; catch (ArrayIndexOutofBoundsException e)&#123; System.out.println(&quot;你访间的数组的索引不存在&quot;);&#125; throws&amp;throw 1234public static void method() throws ArrayIndexOutOfBoundsException &#123; int[]arr = &#123;1,2,3&#125;; system.out.printin(arr=[3]&#125; throw关键字，用于方法内部，抛出异常对象 1234567public void checkScore( int score) &#123; if(score&lt;e || score&gt;100)&#123; throw new ScoreException(); &#125; else &#123; System.out.println(&quot;分数正常&quot;) &#125;&#125; Throwable成员方法 1234567public static void method()&#123; try &#123; int[]arr = &#123;1，2,3&#125;; System.out.println(arr[3]); &#125; catch (ArrayIndexOutofBoundsException e)&#123; e.printStackTrace();&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA学习笔记4","slug":"JAVA学习笔记4（继承，super，构造器，向上向下取整，包装类）","date":"2021-03-13T16:00:00.000Z","updated":"2021-04-07T17:12:50.640Z","comments":true,"path":"2021/03/14/JAVA学习笔记4（继承，super，构造器，向上向下取整，包装类）/","link":"","permalink":"http://example.com/2021/03/14/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%EF%BC%88%E7%BB%A7%E6%89%BF%EF%BC%8Csuper%EF%BC%8C%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%8C%E5%90%91%E4%B8%8A%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4%EF%BC%8C%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%89/","excerpt":"","text":"类的继承继承Java中的继承是通过extends关键字来实现的 123class 子类 extends 父类&#123; ...&#125; 例： 12345678public class Fruit&#123; public double weight; public void info() &#123; System.out.println(&quot;我是一个水果! 重:&quot; + weight + &quot;g!&quot;); &#125;&#125; 1234567891011121314public class Apple extends Fruit&#123; public static void main(String[] args) &#123; //创建Apple对象 Apple a = new Apple(); //Apple 对象本身没有 weight 成员变量 //因为Apple 父 类有 weight 成员变量, 所以也可以访问 Apple 对象的 weight 成员变量. a.weight = 56; //调用 Apple 对象的 info() 方法 a.info(); &#125;&#125; 父类方法的重写子类包含与父类同名方法的现象称为方法重写(Override). 也被称为方法覆盖.可以说子类重写了父类的方法, 也可以说子类覆盖了父类的方法, 都行. 方法的重写要遵循两同两小一大规则： 两同: 方法名相同 / 形参列表相同 两小: 子类方法返回值类型应比父类方法返回值类型小或相等. / 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等. 一大: 子类方法的访问权限应比父类方法的访问权限大或相等. 例：创建一个鸟类，有一个方法是fly再创建一个鸵鸟类，继承鸟类，但是要重写fly方法 12345678public class Bird&#123; //Bird 类的 fly() 方法 public void fly() &#123; System.out.println(&quot;flying...&quot;); &#125;&#125; 123456789101112131415public class Ostrich&#123; //重写 Bird 类的 fly() 方法 public void fly() &#123; System.out.println(&quot;i can&#x27;t fly&quot;); &#125; public static void main(String[] args) &#123; //创建 Ostrich 对象 Ostrich os = new Ostrich(); //执行 Ostrich 对象的 fly() 方法, 将会输出 &quot;i can&#x27;t fly&quot; os.fly(); &#125;&#125; 注意：覆盖方法和被覆盖方法要么都是类方法, 要么都是实例方法。不能一个是类方法, 一个是实例方法 super当子类覆盖了父类方法后, 子类的对象将无法访问父类中被覆盖的方法但可以在子类方法中调用父类中被覆盖的方法。 如果需要在子类方法中调用父类中被覆盖的方法, 则可以使用super(被覆盖的是实例方法) 或者 父类类名(被覆盖的是类方法) 来作为调用者, 调用父类中被覆盖的方法 例1：此时为鸵鸟类添加一个方法，可以调用父类的fly方法 12345public void superfly()&#123; //在子类方法中通过 super 显式调用父类被覆盖的实例方法 super.fly();&#125; 例2： 1234567891011121314151617181920212223class BaseClass&#123; public int a = 5;&#125;public class SubClass extends BaseClass&#123; public int a = 7; public void accessOwner() &#123; System.out.println(a); &#125; public void accessBase() &#123; //通过使用 super 来限定访问从父类继承得到的 a 的实例变量 System.out.println(super.a); &#125; public static void main(String[] args) &#123; SubClass sc = new SubClass(); sc.accessOwner(); //输出 7 sc.accessBase(); //输出 5 &#125;&#125; 调用父类构造器（构造方法）super同样可以来调用父类的构造方法（也叫构造器） 1234567891011121314151617181920212223242526class Base&#123; public double size; public String name; public Base(double size, String name) &#123; this.size = size; this.name = name; &#125;&#125;public class Sub extends Base&#123; public String color; public Sub(double size, String name, String color) &#123; //通过 super 调用来调用父类构造器的初始化过程 super(size, name); this.color = color; &#125; public static void main(String[] args) &#123; Sub s = new Sub(5.6, &quot;皮卡丘&quot;, &quot;黄色&quot;); //输出 Sub 对象的 三个实例变量 System.out.println(s.size + &quot;--&quot; + s.name + &quot;--&quot; + s.color); &#125;&#125; 从上面程序中不难看出, 使用 super 调用和使用 this 调用也很像区别在于 super 调用的是其父类的构造器, 而 this 调用的是同一个类中重载的构造器因此, 使用 super 调用父类构造器也必需出现在子类构造器执行体的第一行所以 this 调用 和 super 调用不会同时出现 下面例子： 涉及this的方法重载的构造器 涉及super的父类构造器 三代继承1234567891011121314151617181920212223242526272829303132333435class Creature&#123; public Creature() &#123; System.out.println(&quot;Creature 无参数的构造器&quot;); &#125;&#125; class Animal extends Creature&#123; public Animal(String name) &#123; System.out.println(&quot;Animal 带一个参数的构造器,&quot; + &quot;该动物的 name 为:&quot; + name); &#125; public Animal(String name, int age) &#123; //使用 this 调用同一个重载的构造器 this(name); System.out.println(&quot;Animal 带两个参数的构造器,&quot; + &quot;其 age 为:&quot; + age); &#125;&#125; public class Wolf extends Animal&#123; public Wolf() &#123; //显式调用父类有两个参数的构造器 super(&quot;大灰狼&quot;, 3); System.out.println(&quot;Wolf 无参数的构造器&quot;); &#125; public static void main(String[] args) &#123; new Wolf(); &#125;&#125; Object类Object类是所有类的父类，记录几个常用方法 getClass()是类定义的方法，返回对象执行时的Class实例，然后使用这个实例调用getName()方法可以获取类名： 1getClass().getName(); toString()将一个对象返回为字符串类型，返回一个String实例一般的使用时会重写这个方法，例如： 1234567891011public class ObjectInstance &#123; public String toString() &#123; // 重写toString()方法 return &quot;在&quot; + getClass().getName() + &quot;类中重写toString()方法&quot;; &#125; public static void main(String[] args) &#123; System.out.println(new ObjectInstance()); // 打印本类对象 &#125;&#125;输出：在ObjectInstance类中重写toString()方法 equals()之前有记录”==“和equals()的区别，”==“的比较是比较地址，equals()的比较是比较对象的内容是否相等 对象的类型转换向上转型例如下例，平行四边形是一个四边形，自然四边形就是平行四边形的父类，四边形类里面有个draw方法，参数是四边形类型的参数 平行四边形也是四边形的一种，所以可以把平行四边形的对象看作是四边形的对象，把平行四边形类的对象赋值给四边形类型的变量，再作为参数传入draw方法，相当于Ouadrangle obj = new Parallelograme()，把子类对象赋值给父类类型的变量，这样的技术叫做“向上转型” 123456789101112class Quadrangle &#123; // 四边形类 public static void draw(Quadrangle q) &#123; // 四边形类中的方法 // SomeSentence &#125;&#125;public class Parallelogram extends Quadrangle &#123; // 平行四边形类，继承了四边形类 public static void main(String args[]) &#123; Parallelogram p = new Parallelogram(); // 实例化平行四边形类对象引用 draw(p); // 调用父类方法 &#125;&#125; 其实，平行四边形就是四边形的一部分，所以他有的属性，四边形肯定包含这个属性，这样就好理解了 向下取整与向上相反，如果要把父类的对象赋值给子类类型的变量的时候，就要使用显式类型转换 12345678向上类型转换,获得一个父类类型的对象Ouadrangle p = new Parallelogram()直接把父类对象赋值给子类对象，出现编译错误Parallelogram q = p把父类对象赋值给子类对象，并强制转为子类型Parallelogram q = (Parallelogram)p 包装类包装类可以把基本类型转换成对象来处理 Integerjava.lang包中的Integer类、Long类和Short类，分别将基本类型int、long和short封装成一个类。由于这些类都是Number的子类，区别就是封装不同的数据类型，其包含的方法基本相同 Integer类在对象中包装了一个基本类型int的值。该类的对象包含一个int类型的字段。此外，该类提供了多个方法，能在int类型和String类型之间互相转换，同时还提供了处理int类型时非常有用的其他一些常量和方法。 构造方法：有两种构造方法 Integer(int number)1Integer number = new Integer(123); Integer(String str)以字符类型的变量为参数来获取Integer对象1Integer number = new Integer(&quot;123&quot;) 常用方法 Integer(int value)和Integer(String s)构造方法 public static int parseInt(String s)将字符串转换成整数。 public static Integer valueOf(int i)将一个整数转换成Integer类型对象，即装箱。 public static Integer valueOf(String s)将字符串数字转换成Integer类型对象，也是装箱。1234567891011public class Summation &#123; // 创建类Summation public static void main(String args[]) &#123; // 主方法 String str[] = &#123; &quot;89&quot;, &quot;12&quot;, &quot;10&quot;, &quot;18&quot;, &quot;35&quot; &#125;; // 定义String数组 int sum = 0; // 定义int型变量sum for (int i = 0; i &lt; str.length; i++) &#123; // 循环遍历数组 int myint=Integer.parseInt(str[i]);//将数组中的每个元素都转换为int型 sum = sum + myint; // 将数组中的各元素相加 &#125; System.out.println(&quot;数组中的各元素之和是：&quot; + sum); // 将计算后结果输出 &#125;&#125; Boolen构造方法123Boolean(boolean value);Boolean b = new Boolean(true); 1234567891011public class GetBoolean &#123; // 创建类GetBoolean public static void main(String args[]) &#123; // 主方法 Boolean b1 = new Boolean(true); // 创建Boolean对象 Boolean b2 = new Boolean(&quot;ok&quot;); // 创建Boolean对象 System.out.println(&quot;b1：&quot; + b1.booleanValue()); System.out.println(&quot;b2：&quot; + b2.booleanValue()); &#125;&#125;// b1:true// b2:false Byte构造方法 Byte(byte value)12byte mybyte = 45;Byte b = new Byte(mybyte); Byte(STing str)1Byte mybyte = new Byte(&quot;12&quot;)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA学习笔记3","slug":"JAVA学习笔记3（类，this，静态，主方法，对象）","date":"2021-03-12T16:00:00.000Z","updated":"2021-04-07T17:12:41.643Z","comments":true,"path":"2021/03/13/JAVA学习笔记3（类，this，静态，主方法，对象）/","link":"","permalink":"http://example.com/2021/03/13/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%EF%BC%88%E7%B1%BB%EF%BC%8Cthis%EF%BC%8C%E9%9D%99%E6%80%81%EF%BC%8C%E4%B8%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%89/","excerpt":"","text":"类类的定义Java中，类是基本组成单位类由属性和行为组成 利用class关键字对类进行定义 12345678910public class Phone&#123; //成员变量 String brand; int price; //成员方法 public void call()&#123; System.out.println(&quot;打电话&quot;); &#125;&#125; 对象的创建与使用有了类就可以基于这个类来创建对象，创建方法和php的很像，使用new关键字 1类名 对象名 = new 类名() 使用对象对象的时候分为成员变量的访问和成员方法的调用 12对象名.变量名对象名.方法名 权限修饰符 修饰符 本类 同包的类或子类 其他包 private 可以 不可以 不可以 protected 可以 可以 不可以 public 可以 可以 可以 局部变量定义：在成员方法中定义的变量叫做局部变量 局部变量在方法被执行的时候调用，在方法执行结束的时候销毁 局部变量的作用范围局部变量的有效范围从该变量的声明开始到该变量的结束为止在互不嵌套的作用域里面可以同时声明两个同名的变量 this关键字和php中一样，this关键字用来代替本类对象，在类的内部来调用类内部的属性或方法如下面的例子，添加this关键字来明确引用的是类成员还是局部变量还是方法的参数 12private void setName(Sting name)&#123; this.name = name this还可以作为返回值，将对象返回 类的构造方法特点： 没有返回值 构造方法的名称要与本类的名称相同 构造方法的时候可以为成员变量赋值，这样实例化一个对象的时候成员变量也会被初始化 如果类没有构造方法，编译器会自动创建一个不带参数的构造方法 12345678910public class AnyThing&#123; public AnyThing()&#123; //传入参数的时候自动调用了有参数的构造方法 this(&quot;调用有参的构造方法&quot;); System.out.println(&quot;无参数构造方法&quot;)&#x27; &#125; public AnyThing(String name)&#123; System.out.println(&quot;有参数的构造方法&quot;) &#125;&#125; 静态变量，常量和方法static关键字由static修饰的变量，常量，方法被称作静态变量，常量，方法 静态变量的作用有时候，两个类在同一个内存区域想共享一个数据，可以把这个数据设成静态的，这样本类和其他类都可以调用这个静态成员，根据类名来访问静态成员的时候与对象无关，只与类有关语法： 1类名.静态类成员 例： 12345678910111213public class StaticTest&#123; final static double PI = 3.14; static int id;&#125; public static void method1()&#123; //do something &#125; public void method2()&#123; System.out.println(StaticTest.PI);//调用静态常量 System.out.println(StaticTest.PI);//调用静态变量 StaticTest.method1();//调用静态方法 &#125;&#125; 静态变量同样遵循public，protected，private 修饰符的限定 注意： 静态方法中不能使用this关键字 静态方法中不能直接调用非静态方法（可以对象.方法调用）直接调用指的是：123public static Test()&#123;mathod();//mathod是静态方法&#125; 这样就会报错 类的主方法之前一直使用的main方法，现在来解析一下 123public static void main(String[],args)&#123; //方法体&#125; 主方法是静态的，如果要直接调用主类中的其他的方法，也必须是静态(static) 没有返回值(void) 主方法的形参是数组，args[0]~args[n]分别代表程序的第一个参数到第n个参数 对象对象的创建前面说了，每实例化一个对象就会自动调用一次构造方法，实际上这就是创建对象的过程语法： 12Test mytest = new Test();类名 对象名 = new 构造方法(); 所以说前面的Test是类名，后面的Test()就是构造方法的方法名，与类名相同 访问对象的属性和方法12345678910111213141516171819202122public class Visit &#123; int i = 10; public void call() &#123; System.out.println(&quot;调用call()方法&quot;); &#125; public Visit() &#123; &#125; //构造方法 public static void main(String[] args) &#123; Visit n1 = new Visit(); Visit n2 = new Visit(); //实例化两对象 n2.i = 20; //使用n1来调用成员方法和函数 System.out.println(&quot;n1中i的值是：&quot;+n1.i); n1.call(); //使用n2来调用成员方法和函数 System.out.println(&quot;n2中的i的值是：&quot;+n2.i); n2.call(); &#125;&#125; 观察到两次i的值不一样，一次是20，一次是10，说明两个对象的产生是独立的，改变了n2的i的值，n1的i的值不会受到影响 如果不希望成员变量被任何一个对象所改变，可以使用静态变量，加上static关键字 对象的引用引用只是存放一个对象的内存地址，不是存放一个对象语法： 123类名 对象引用名Book book; 对象的比较java中有两个比较对象的方式 “==” equals()方法 区别：“==”是比较地址equals()是比较值 123456789101112public class Compare &#123; public static void main(String[] args) &#123; String c1 = new String(&quot;abc&quot;); // 创建两个String型对象引用 String c2 = new String(&quot;abc&quot;); String c3 = c1; // 将c1对象引用赋予c3 // 使用“==”运算符比较c2与c3 System.out.println(&quot;c2==c3的运算结果为：&quot; + (c2 == c3)); // 使用equals()方法比较c2与c3 System.out.println(&quot;c2.equals(c3)的运算结果为：&quot; + (c2.equals(c3))); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA学习笔记2","slug":"JAVA学习笔记2","date":"2021-03-11T16:00:00.000Z","updated":"2021-04-07T17:11:44.934Z","comments":true,"path":"2021/03/12/JAVA学习笔记2/","link":"","permalink":"http://example.com/2021/03/12/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","excerpt":"","text":"数组对于数组的创建，先声明，再用new运算符进行内存分配 声明有两种方法 12int arr[];int[] arr; new创建对象，分配内存，给改数组一个地址，地址就是arr的值 1数组名 = new 数据类型[元素个数] 例如： 1arr = new int[3] 当给了一个数组三个位置后，会自动填充，int类型就是0 定义方法可以声明的时候去分配内存 1int arr[] = new int[5] 或者直接赋好值 1int arr[] = new int[]&#123;1,2,3,4,5&#125; 二维数组声明加分配内存 1int arr[][] = new int[2][4] 1int arr[][] = &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125; 遍历数组遍历数组用for循环来实现用foreach语句将更简单 1234int arr[] = &#123;1,2,3&#125;for (int x:arr)&#123; ...&#125; 填充替换将指定的int值分配给int型数组a的每个元素 1fill(int a[],int value) 完整版用值填充x到y，左闭右开 1fill(int a[],int 开始x,int 结束y,int 值) 排序Arrays类的sort方法 1Arrays.sort(数组名) 数组查询Arrays类的binarySearch()方法 1Arrays.binarySearch(数组,int 开始,int 结束,要搜索的值) 方法方法的定义在Java中，不叫函数了，叫方法，在主类里面，有一个main方法，有自定义的方法，而自定义的方法就要在main方法中调用 带参数的方法定义 带返回值的方法定义待返回值的方法调用后，需要创建一个同类型的变量来接收返回值 1int x = getMax(10,20); 方法重载特点： 重载仅对应方法的定义，调用不受影响，Java会自动根据所给的参数来判断该调用哪个方法 仅对同一个类中的方法和参数进行识别，与返回值无关 方法的参数传递基本类型引用基本类型的形参无法改变形参 引用传递引用传递是传递地址，所以形参可以改变实参","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA学习笔记1","slug":"JAVA学习笔记1","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-09T16:42:08.511Z","comments":true,"path":"2021/03/10/JAVA学习笔记1/","link":"","permalink":"http://example.com/2021/03/10/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"主类结构Java是一个与面向对象关系很强的编程语言，java的应用程序就是由若干的类组成的每个应用程序都必须包含一个main()方法，含有main方法的类称为主类 示例：定义一个类叫Frist，里面有一个main方法，所以这个类被定义为主类 12345public class Frist &#123; public static void main(String[] args)&#123; System.out.println(&quot;hello&quot;); &#125;&#125; main方法main()方法是类体中的主方法。该方法从“{”号开始，至“}”号结束。public是权限修饰符，static是静态修饰符，void是返回值修饰符，Java程序中的main()方法必须声明为public static void。String[] args是一个字符串类型的数组，它是main()方法的参数。main()方法是程序开始执行的位置。 基本数据类型整数 数据类型 内存空间 取值范围 byte 8位 -128~127 short 16位 -32768~32767 int 32位 -2147483648~2147483647 long 64位 -9223372036854775808~9223372036854775807 整数的定义 123int xint x,yint x = 012,y=123 对于long类型的定义，需要在数字后面加上L或l，表示数值为长整数例如： 1long num = 2147483650L 浮点类型类型有： float double 定义方法就类似于整数默认情况下都被看作double，如果要使用float类型的就要在小数后面加是F或f 字符类型char型用于存储单个字符，占用16位内存空间，定义字符型变量的时候，要用单引号标注&#39;，注意区别双引号&quot;，单引号是字符，双引号是字符串：&#39;s&#39;表示字符，&quot;s&quot;表示字符串 定义例如： 123char x = &#x27;a&#x27;;a在Unicode表中排序97，所以也可以这样写char x = 97; 布尔类型无非是true和false 变量和常量声明变量12int age; //只是声明char a=&#x27;1&#x27;; //声明并赋值 申明常量需要通过final关键字来进行限定语法： 1final 数据类型 常量名[&#x3D;值] 例如： 1final double PI = 3.1415926D; //声明double型常量PI并赋值 运算符逻辑运算符其他的没啥好说的，说一下逻辑运算符逻辑运算符里面有&amp;&amp;和||，分别表示逻辑与和逻辑或但是还有一种短路与：&amp; 和 短路或：|区别：&amp;&amp;的判断逻辑是：第一个表达式如果是true，那就会去判断第二个是不是true，但是如果第一个表达式是false的话就不会走到第二个表达式了，也就不会执行第二个表达式（a++这样的就不会执行） $的判断逻辑是：两个都会执行，如果都是true才返回true或也是同理，||如果判断第一个就是true，那么就不会执行后面的表达式 三元运算符语法 1条件式?值1:值2 意思是如果前面的条件式为true，那么就返回值1，否则返回值2 数据类型转换隐式类型转换从低级到高级的类型转换，系统自己会自动执行类型按精度排序： 1byte&lt;short&lt;int&lt;long&lt;float&lt;double 例如：由于float比int高级，所以会自己进行类型转换，y的结果是50.0 12int x = 50;float y = x; 显式类型转换语法： 1(类型名)要转换的值 例如：此时c的值为3 1int a = (int)3.14 流程控制else ifif…else就不多说java支持else if(else和if用空格隔开) 123456if()&#123;...&#125;else if()&#123;...&#125;else&#123;&#125; switch123456789101112switch(表达式)&#123;case 常量1: ... break;case 常量n: ... break;default: ... break;&#125; 可以用break穿透，比如当表达式与多个值匹配的结果要有相同的结果，就可以把那几个放一起在最后加一个break，例如春季是3，4，5月，可以把case后常量为345的放一起在五月break一下 123456789switch (5)&#123; case 3: System.out.println(&quot;春季&quot;); case 4: System.out.println(&quot;春季&quot;); case 5: System.out.println(&quot;春季&quot;); break; &#125; 执行结果只有一个春季 while和for和c一样，不多说foreach语句for语句的简化版，把遍历对象的值赋值给x，依次循环 123for(元素变量x: 遍历对象obj)&#123; 引用了x的java语句&#125; 字符串声明字符串在java里，字符串必须在双引号里面&quot;你好&quot;语法 1String str; 创建字符串java中将字符串当做对象来管理 String(char a[])：用一个字符数组a创建String对象。 12char a[] = &#123;&#x27;g&#x27;,&#x27;o&#x27;,&#x27;o&#x27;&#125;;String s = new String(a); String(char a[], int offset, int length) 12char a[] = &#123;&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;n&#x27;,&#x27;t&#x27;&#125;;String s = new String(a,2,4); 结果是”uden” 引用字符串常量 123String str1,str2;str1 = &quot;abc&quot;str2 = &quot;abc&quot; 这个时候str1和str2具有相同的实体，就类似于c语言中的地址指向同一个值 连接字符串用+连接字符串字符串可以和其他的基本类型进行连接，其他的基本类型会被直接转化成字符串 获取字符串长度Sring类的length()方法 1str.length(); 字符串查找String类提供两种方法：indexOf()和lastindexOf() indexOf(String s)，返回首次出现的索引位置1str.indexOf(substr); lastindex(String s)，返回字符串出现的最后索引 获取指定字符使用charAt()可以将指定索引的字符返回 1str.charAt(int index); 字符串操作获取子字符串截取从指定的索引值开始到结束 1str.substring(int begin); 完整版老规矩：左闭右开 1str.substring(int begin,int end); 去除空格忽略前后空格 1str.trim(); 字符串替换1str.replace(char old,char new); 字符串判断是否相等字符串对象不能简单的用比较运算符==，比较运算符比较的是两字符串的地址是否相同，要使用equals()函数和equalsIgnoreCase() equals()如果有相同的字符和长度，用这个比较1str1.equals(str2); equalsIgnoreCase()这个用于不区分大小写的 字符串分割split()方法根据sign分割，limit是匹配次数，如果是n则匹配n-1次，也可以理解成分成n段 1str.split(String sign,int limit) 格式化字符串1str.format(String format,Object ...args) 正则表达式 [^456]表示4，5，6之外的任何字符 [a-r]：代表a-r的任意字符 [a-zA-Z]：表示任意的字母 [a-e[g-z]]：代表a~e或g~z中的任何一个字母 正则表达式可以用限定修饰符来限定元字符的出现次数，例如：A*表示A可在字符串出现0次或多次|限定修饰符|意义||–|–||?|0次或1次||*|0次或多次||+|一次或多次||{n}|正好出现n次||{n,}|至少出现n次||{n,m}|出现n到m次|","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"PHP学习笔记9","slug":"PHP10：面向对象","date":"2021-02-11T16:00:00.000Z","updated":"2021-02-23T11:59:03.335Z","comments":true,"path":"2021/02/12/PHP10：面向对象/","link":"","permalink":"http://example.com/2021/02/12/PHP10%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"思想图解：就是把个个方法对应到它的主题，买家的方法就对应到买家那里，卖家的方法就放到卖家那里，凡是做任何一件事都有一个操作的主体，虽然更复杂，但是更符合人类的思想 关键字说明 类: class，是定义面向对象主体的最外层结构，用来包裹主体的数据和功能（函数)。类是一类具有共性事务的代表，代表的是事务的共性。 对象: object，是某类事务的具体代表，也是实际数据和功能操作的具体单元，也被称之为实例(instance) 实例化: new，从一个抽象的概念得到一个符合抽象概念的具体实例的过程 类成员:member，指类class结构中的所有内容，类成员里有三种 方法: method，本质是在类class结构中创建的函数，也称之为成员方法或者成员函数 属性: property，本质是在类class结构中创建的变量，也称之为成员变量 类常量: const，本质是在类class结构中创建的常量 类的定义 类成员类成员:指直接定义在类结构内部的一级成员，即直接依赖f的成员 类成员分类 成员变量（属性)︰给对象存储数据的变量。成员函数（(方法)︰给对象调用解决问题的函数 类常量:属于类内部的常量，使用const关键字定义 属性和方法需要使用访问修饰限定符修饰，姑且使用public修饰 1234567891011&lt;?php class 类名&#123; # 类常量 const 常量名 = 值; # 属性 public $属性名 [ = 值]; # 可以赋值也可以只声明 # 方法 [public] function 方法名([形参列表])&#123; 方法体 &#125; &#125; 成员访问:属性和方法都属于对象访问，类常量属于类访问(后续再讲) 对象访问属性和方法，使用-&gt;12345678&lt;?php # 实例化 $object = new 类名(); # 属性访问 # 此时不带属性本身的$符号（前面保存对象的变量带$符号，object-&gt;属性名是整体） $object -&gt; 属性名; # 方法访问 $object -&gt; 方法名([实参列表]); 步骤1、声明类结构工2、明确类产生的对象是否需要有数据的存储:确定属性3、明确类产生的对象是否需要函数实现功能:确定方法4、明确类是否需要定义常量:确定类常量5、对象实例化6、类成员访问（属性和方法) 实例：属性的操作：增，删，改，查 小结1、PHP类结构中有且仅有三种成员:属性、方法和类常量，其他直接属于类的内容都会报错2、类声明需要根据业务来确定类成员的存在和数量3、类中属性和方法的访问方式都是通过对象来调用: $对象-&gt;属性名/方法名();注意属性名不带$符号4、类中定义属性不能直接属性名，需要使用符号public修饰(访问修饰限定符中的一种) 访问修饰限定符分类： public:公有，类内和类外都可以访问 protected:受保护，只允许在相关类内部访问（前期的学习就当作私有） private:私有，只允许在定义类内部访问 属性必须有访问修饰限定符，方法可以没有访问修饰限定符（默认public) 类内部对象 概念 内部对象：$this，方法内部内置的一个对象，会自动指向来调用方法的对象 $this存在于方法内部（仅限内部使用），所以相当于在类的结构内部 可以访问任意访问修饰限定符修饰的成员 私有成员都是通过公有方法来实现访问（公有方法可以在类外部访问） 类内部对类成员的访问也需要通过对象才能访问，所以必须通过$this内部对象访问类成员 步骤 声明类结构 明确私有成员（不限定成员的访问修饰限定符） 私有成员需要在某种情况下被访问：增加方法，在方法里使用$this访问 例如：在类内部访问属性，可以让本来不能访问类的私有的属性和方法的对象成功访问 1234567891011121314class Saler&#123; # 属性 public $count = 100; protected $discount = 0.8; private $money = 100; public function getAll()&#123; var_dump($this); echo $this-&gt;count,$this-&gt;discount,$this-&gt;money; #正确输出 &#125; &#125;$s = new Saler();$s-&gt;getAll(); $this、class和new之间的关系原理 class是定义类结构，属于非执行段代码，因此会被加载到代码段（编译阶段） new是实例化对象，先判定类在内存（代码段）是否存在 类不存在，报错； 类存在，将类内部的属性部分复制一份，然后在内存（堆区）开辟一块内存空间，将属性放到里面，同时内部有一个指针指向类的内存空间（代码段） 对象访问属性即访问的是对象空间里存储的部分 对象访问方法是对象通过内部指针找到类空间中的方法，然后在内存（栈区）开辟运行 $this是系统在方法内置的对象通用名字 对象在调用方法的时候，系统会自动找到对象所保存的内存地址（堆区），然后把地址赋值给$this 方法内部的$this就代表调用当前$this所在方法的外部对象 $this的本质是函数内部的一个局部变量，只是系统自动对其进行赋值，而且一定是调用方法的对象本身 面向对象编程代码运行内存关系 构造方法 概念 构造方法：__construct()，是一种类结构特有的特殊方法，该方法由系统规定好，开发人员在定义的时候只需要抄一遍，有了构造方法的类在实例化对象之后，对象就会自动调用。 构造方法是一种魔术方法：魔术方法是会自动被触发，不需要手动调用的方法 构造方法的目标是为了实现对象的初始化 对象实例化之后会自动调用 构造方法通常是为了实现对象所需资源的初始化（属性、资源） 构造方法虽然为魔术方法，但本质依然是一个方法 受访问修饰限定符控制（对象的产生位置会发生改变） 对象可以选择调用（一般不会） 构造方法可以设定形参，形参对应的实参是在实例化对象的时候传入：new 类名(实参传递给形参) 步骤 确定类中需要有数据实现初始化，而且是灵活处理，每个对象都不一样的：使用构造方法 确定初始化的数据需要外部传入：使用构造方法设定形参 在构造方法内部利用内部对象实现初始化需求 属性初始化 资源初始化 其他内置方法调用 实例化对象时必须传入构造方法所需数据 示例 1、构造方法实现：在类中增加一个方法__construct()即可 2、构造方法也是一个方法，不普通的地方在于，类实例化得到的对象会马上自动调用 3、一旦构造方法拥有了形参，那么对象在调用该方法的时候就需要传入对应的实参，而构造方法又是自动调用的，所以需要在实例化对象的时候使用new 类名(构造方法对应的实参列表)来实现 4、构造方法不管再怎么特殊，也是用户定义的方法，言外之意除了在实例化对象时对象会自动调用之外，我们也可以手动调用构造方法（但是一般没有价值，因为对象实例化时会自动调用） 123456789101112131415class Saler&#123; # 属性 public $count; private $money; # 构造方法：初始化属性 public function __construct($count,$money)&#123; $this-&gt;count = $count; $this-&gt;money = $money; &#125;&#125;# 实例化$s = new Saler(100,100); # 系统在new Saler(100,100)好之后，会自动调用一次$s-&gt;__construct(1000,1000); # 允许手动调用 小结 1、构造方法__construct()是一种系统内置的方法，该方法的特性是会在对象实例化之后，对象立即自动调用 2、构造方法的目的就是为了初始化资源，包含对象属性和其他资源 3、一旦构造方法定义好之后，且构造方法自带参数，那么就只能使用new 类名(参数列表)方式才能正确实例化 4、构造方法可以当做普通方法由对象调用（不建议） 析构方法 概念 析构方法：__destruct()，也是一种类结构中魔术方法，与构造方法一样，也是系统规定好，只需要开发人员抄一遍即可，对象在被销毁时会自动调用 析构方法是用来对象销毁时主动释放资源的 对象销毁的方式： 对象无变量指向（变量指向其他数据比如重新赋值） 对象被主动销毁（unset销毁对象变量） 脚本执行结束（自动释放资源） PHP脚本执行结束会释放所有资源，所以一般较少使用析构方法 步骤 1、定义类结构 2、确定需要在对象销毁时释放资源 3、使用析构方法释放资源 示例 1、析构方法实现：类中增加一个__destruct()方法 123456class Saler&#123; # 析构方法 public function __destruct()&#123; echo __FUNCTION__; &#125;&#125; 2、析构方法调用：析构方法是在对象被销毁时自动，对象的“垂死挣扎” 12345678910# 实例化对象$s = new Saler();# 对象变量指向其他数据$s = 1; # 主动销毁对象变量unset($s); # 脚本执行结束自动释放 3、析构方法也是普通方法，可以由对象直接调用 123# 接析构方法实现代码$s = new Saler();$s-&gt;__destruct(); # 调用了对象是不会被销毁的 小结 1、析构方法是一种对象销毁时自动调用的方法 2、析构方法是用来对象销毁自身所占用的资源 3、PHP中脚本执行结束，系统会自动回收所有资源，因此一般PHP中很少使用析构方法 对象传值 概念 对象传值：将保存对象的变量赋值给另外一个变量 在PHP中，对象的传值是引用传递的：即一个对象变量赋值给另外一个变量，两个变量指向同一个对象的内存地址，即只有一个对象。 步骤 1、定义类结构 2、实例化产生对象，保存在变量中 3、将保存对象的变量赋值给另外一个变量 示例 对象传值就是保存对象的变量赋值给另外一个变量 对象传值是引用传递，不管对象赋值给多少个变量，内存中只有一个对象 123456class Saler&#123;&#125;$s1 = new Saler();$s2 = $s1;var_dump($s1,$s2); # 同一个对象$s1-&gt;name = &#x27;Saler&#x27;; # 更改一个变量所保存对象的属性echo $s2-&gt;name; # 输出Saler 小结 对象传值方式是引用传值，不论对象如何被赋值给其他变量，始终只有一个对象 范围解析操作符（类常量访问） 概念 范围解析操作符：由两个冒号组成“**::”，是专门用于类实现类成员操作**的(区别于对象对类成员操作)，可以实现类直接访问类成员 范围解析操作符是用于给类（类名）访问类成员使用的 1类名::类成员 范围解析操作符也可以被对象用来当做类使用（不建议使用） 1$对象名::类成员 类常量只能被类访问 步骤 1、定义类结构 2、确定成员需要由类进行管理：类常量 3、在需要访问类常量的时候使用范围解析操作符访问 示例 1、类常量的普通访问尝试：尝试使用对象进行访问 123456class Saler&#123; # 类常量 const PI = 3.14;&#125;$s1 = new Saler();echo $s1-&gt;PI; # 错误，$s1-&gt;PI最终转换的访问方式为:$PI，这个在类中并不存在 2、以上案例可以看出，对象无法访问类常量，那是因为类常量的定义本身就是用来给类访问的，对象是用来访问属性和方法的，类常量的访问方式为：类名::常量名，而且类的访问不需要依靠对象，就算没有实例化对象也可以访问 12# 类+范围解析操作符访问类常量echo Saler::PI; # 输出3.14 3、对象本身也依赖于类，因此也可以使用对象对类控制成员进行访问，需要使用范围解析操作符 12$s = new Saler();echo $s::PI; # 输出3.14 注意：以上方式能访问，但是不建议使用（以上方式也能看出，成员谁来访问，关键看用什么符号：①使用范围解析操作符::就是类访问；②使用对象操作符号-&gt;就是对象访问） 4、分析：类常量是固定的，而对象的属性是不同对象而不同的，成员方法简单的理解也是为属性本身进行加工的。因此有一些东西是专属于类的，而有部分内容是专门为对象提供的，所以就会有不同的成员拥有不同的访问方式 小结 1、类访问成员的方式是使用范围解析操作符“**::**”访问，由类名直接访问：类名::类常量 2、类本身是通过对同类对象的抽象而形成，所以属性和方法本身都是由对象来访问 3、类也需要有一些自身的数据和操作，这些就由类来进行访问 静态成员 概念 静态成员：使用static关键字修饰的类成员，表示该成员属于类访问（专用于类） PHP静态成员有两种 静态属性 静态方法 静态成员是明确用来给类访问的，而不是对象 静态成员只是多了一个static关键字修饰，本身也可以被对象访问 静态成员同样可以使用不同访问修饰限定符限定，效果一致 步骤 1、定义类结构 2、确定有些成员（属性、方法）不需要对象访问，直接通过类访问 3、使用static关键字修饰 4、静态成员应该让类进行访问 示例 1、静态属性：在类中定义属性的时候使用static关键字修饰，访问的时候只能使用类+范围解析操作符+静态属性访问，对象不能访问静态属性 12345678910class Saler&#123; # 属性 public $money = 0; public static $count = 0; # 静态属性&#125;# 静态成员可以直接使用类访问，而不需要先实例化对象echo Saler::$count;$s = new Saler;echo $s-&gt;count; # 错误访问，对象不能访问静态属性 2、静态方法：在类中定义方法的时候使用static关键字修饰，访问的时候使用类+范围解析操作符+静态方法名字()访问 123456789class Saler&#123; # 方法 public static function showClass()&#123; echo __CLASS__; &#125;&#125;# 类直接访问Saler::showClass(); 3、在类的内部也可以访问静态成员，同样是使用类名+范围解析操作符+静态属性/静态方法() 1234567891011class Saler&#123; # 属性 private static $count = 0; # 私有，不允许外部直接访问 # 方法 public static function showClass()&#123; echo Saler::$count; &#125;&#125;# 类直接访问Saler::showClass(); 4、静态方法本质也是类中定义的方法，因此也可以使用对象进行访问，但是不建议 123# 对象访问静态方法$s = new Saler();$s-&gt;showClass(); # 输出0 5、同理，方法也是在类内部，在编译时就存在，因此可以通过类来进行访问，使用范围解析操作符，但是非常不建议（会报错：因为类只允许访问静态成员和类常量） 12345678class Saler&#123; public function testStatic()&#123; echo __FUNCTION__; &#125;&#125;# 类访问普通成员方法Saler::testStatic(); # 输出testStatic，但是报错，当前访问的不是静态方法 6、静态方法本质是给类访问，所以不允许在静态方法内部使用$this对象 12345class Saler&#123; public static function testStaticThis()&#123; var_dump($this); # 致命错误：$this放到了不该放的位置 &#125;&#125; 小结 1、为了保障类能直接访问数据和操作数据，可以在属性和方法前增加static关键字变成静态属性和静态方法 2、类通过类名+范围解析操作符+静态成员的方式进行访问 3、静态成员也受访问修饰限定符的限定，访问权限与普通属性和方法的限制一样 4、对象可以无条件访问静态方法，而类只能访问不带$this的普通方法（不建议） 5、静态成员是给类访问的，非静态成员是给对象访问的 静态属性和方法（静态和非静态）都是保存在类结构中（代码段） 普通属性保存在对象生成的对象空间里（堆） 6、静态成员的访问效率比非静态成员高，因此有种说法是能用静态的时候就不用非静态（对象的特点是多元化，而静态的特点是单一化） self关键字 概念 self关键字：在类的内部（方法里面）使用，代替类名的写法 self如同$this代表内部对象一样，能够在方法内部代替当前类名 能够保障用户方便修改类名字 self关键字是代替类名，所以需要配合范围解析操作符:: 步骤 1、定义类结构 2、方法内部需要使用类名来进行成员访问（类常量、静态成员） 3、使用self关键字代替类名 示例 1、self是用来代替类名的，与范围解析操作符::一起使用的 123456789class Saler&#123; # 静态属性 private static $count = 0; # 私有，不允许外部直接访问 # 静态方法 public static function showClass()&#123; echo Saler::$count; echo self::$count; # 代替类名 &#125;&#125; 2、self也可以在类的内部方便实例化对象：比如构造方法被私有化之后，就没有办法在类外部实例化对象，此时可以在类内部进行对象实例化 123456789101112class Saler&#123; # 属性 private static $count = 0; # 私有，不允许外部直接访问 private function __construct()&#123;&#125; # 私有，不允许外部实例化（因为对象不能外部调用） # 方法 public static function getInstance()&#123; return new Saler(); # 使用类名实例化 return new self(); # 使用self关键字实例化 &#125;&#125;$s = Saler::getInstance(); 小结 1、self是一种在类内部用来代替类名的关键字 2、self可以用来在类内部访问静态成员 3、self也可以在类内部用来实例化对象 4、帮助类名修改时，不用修改任何类的内部结构","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记8","slug":"PHP学习9：文件编程，会话技术","date":"2021-02-10T16:00:00.000Z","updated":"2021-02-23T11:58:43.556Z","comments":true,"path":"2021/02/11/PHP学习9：文件编程，会话技术/","link":"","permalink":"http://example.com/2021/02/11/PHP%E5%AD%A6%E4%B9%A09%EF%BC%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B%EF%BC%8C%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","excerpt":"","text":"文件操作的分类1） 目录操作：文件夹，用来存放文件的特殊文件2） 文件操作：用来存放内容 目录操作创建目录结构1）mkDir(路径名字)：创建成功返回true，创建失败返回false 有些操作为的就是得到一个想要的结果，如果结果本身就存在，那么可以忽略得到过程的错误：抑制错误，所以可以加上错误抑制符@ 删除目录1）rmDir(指定文件夹路径)：移出文件夹 读取目录读取方式：将文件夹（路径）按照资源方式打开 1）openDir()：打开资源，返回一个路径资源，包含指定目录下的所有文件（文件夹）返回的是资源，不能直接echo()出来而是使用readDir()2）readDir()：从资源中读取指针所在位置的文件名字，然后指针下移，直到指针移出资源不管是Windows还是linux，前面这几个点都会有的读取所有内容：遍历操作 会话会话技术介绍：web会话可简单理解为：用户开一个浏览器，访问某一个web站点，在这个站点点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 HTTP协议的特点是无状态/无连接，当一个浏览器连续多次请求同一个web服务器时，服务器是无法区分多个操作是否来自于同一个浏览器（用户）。会话技术就是通过HTTP协议想办法让服务器能够识别来自同一个浏览器的多次请求，从而方便浏览器（用户）在访问同一个网站的多次操作中，能够持续进行而不需要进行额外的身份验证。 分类分为cookie和session 1）cookie技术Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件(HTTP协议响应头)，它可以包含有关用户的信息。无论何时用户链接到服务器（HTTP请求携带数据），Web 站点都可以访问 Cookie 信息 2）session技术Session直接翻译成中文比较困难，一般都译成时域。在计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。以及如果需要的话，可能还有一定的操作空间。Session技术是将数据保存到服务器端，无论何时用户链接到服务器，Web站点都可以访问Session信息：SESSION技术的实现是依赖COOKIE技术的。 可以这样来区分：cookie就是身份证，发在你手里，信息也在上面，检查身份的时候你将它出示就可以session就是银行卡，也发在你手里（依赖COOKIE技术），但是信息在卡上看不到，而是储存在银行里。 cookie使用Setcookie函数用来设定COOKIE信息Setcookie(名字，值，生命周期，作用域) cookie名的设置：字符串 cookie值的设置：类型要求：必须是简单类型中的整数或者字符串 cookie的生命周期： 不设置：浏览器关闭就生命周期结束 设置：从格林威治时间开始计时，所以记得加上时间戳time() 删除cookie删除一个cookie的做法：服务器没有权限去操作浏览器上的内容（不可能删除）。可以通过设定生命周期来让浏览器自动判定COOKIE是否有效：无效就清除，可以把时间就设置成时间戳time()，一出来就失效 cookie的作用范围1）默认（不设定）的范围：就是使用COOKIE默认的作用范围（开发过程一般不使用） 2）设定为“/”的含义：告知浏览器当前COOKIE的作用范围是网站根目录Setcookie(名字,值,生命周期,作用范围) cookie的数组数据按理来说是不支持数组的，但是可以创建一个伪数组设置形式：setcookie(‘c1[k1]’, 值) sessionSession与浏览器无关，但是与Cookie有关。意义在于跨脚本 PHP碰到session_start()时开启session会话，会自动检测sessionID： 如果Cookie中存在，使用现成的 如果Cookie中不存在，创建一个sessionID，并通过响应头以Cookie形式保存到浏览器上 初始化超全局变量$_SESSION为一个空数组 PHP通过sessionID去指定位置（session文件存储位置）匹配对应的文件 不存在该文件：创建一个sessionID命名文件 存在该文件：读取文件内容（反序列化），将数据存储到$_SESSION中 脚本执行结束，将$_SESSION中保存的所有数据序列化存储到sessionID对应的文件中 启用session任何时候都需要开启session（脚本使用到$_SESSION就开启一次）$_SESSION是通过session_start()函数的调用才会定义的，没有直接定义 设置SESSION信息如果想存储数据到session中，那么只要不断给$_SESSION数组添加元素即可,这里就不局限与字符串了，可以直接传数组了 读取SESSION信息$_SESSION就是一个数组，存储什么数据，什么方式存的，就是可以通过什么方式访问什么数据 意义会话技术的本质是为了实现跨脚本共享数据：在一个脚本中定义数据，在另外一个脚本中保存数据","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记7","slug":"PHP学习8：复选框的处理，文件上传学习","date":"2021-02-09T16:00:00.000Z","updated":"2021-02-23T11:58:46.552Z","comments":true,"path":"2021/02/10/PHP学习8：复选框的处理，文件上传学习/","link":"","permalink":"http://example.com/2021/02/10/PHP%E5%AD%A6%E4%B9%A08%EF%BC%9A%E5%A4%8D%E9%80%89%E6%A1%86%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"# 复选框 1、 在浏览器端，checkbox的name属性的值不论什么都会被浏览器毫无保留的提交2、 在PHP中$_POST/$_GET都会对同名name属性进行覆盖 解决方案：浏览器不识别[]（浏览器不认为有特殊性），但是PHP认为[]有特殊性：系统自动认为该符号是数组的形式，所以PHP就会自动的将同名的但是带有[]的元素组合到一起形成一个数组[]里面不写数字也可以，php会自动添加下标 文件上传实现文件上传有这几个步骤： 1、 增加文件上传的表单：浏览器请求一个服务器的HTML脚本（包含文件上传表单） 2、 用户从本地选择一个文件（点击上传框（按钮））3、 用户点击上传：文件会通过物联网传输到服务器上4、 服务器操作系统会将文件保存到临时目录：是以临时文件格式保存（windows下tmp）5、 服务器脚本开始工作：判断文件有效6、 服务器脚本将有效文件从临时目录移动到指定的目录下（完成） 原理图解： 表单的制作必需要满足这三个条件 method属性：表单提交方式必须为POST enctype属性：form表单属性，主要是规范表单数据的编码方式 上传表单：file表单 $_FILES变量详解在PHP中，有一个预定义变量$_FILES是专门用来存储用户上传的文件的 从这里可以看到，post并没有记录上传文件的信息，文件的信息是储存在$_FILES变量里的 1）name：文件在用户（浏览器端）电脑上实际存在的名字（实际用来保留后缀）2）tmp_name：文件上传到服务器后操作系统保存的临时路径（实际用来给PHP后期使用）3）type：MIME（多功能互联网邮件扩展）类型，用来在计算机中客户端识别文件类型（确定软件）4）error：文件上传的代号，用来告知应用软件（PHP）文件接收过程中出现了什么问题（PHP后期根据代码进行文件判断）可以去手册里看看5）size：文件大小（PHP根据实际需求来确定是否该保留） 文件的保存上传了文件，怎么保存到服务器里？因为之前我们并没有对上传的文件进行筛选保存，所以php运行结束后就会删除这个临时文件，所以我们就要赶在他删除这个文件之前把符合条件的文件移动到我们的服务器里面 涉及到两个函数一个是is_upload_file()参数是临时文件（.tmp）的位置 另一个函数move_uploaded_file()第一个参数是临时文件（.tmp）的位置，第二个参数的是想移动到的位置（需要要加上文件名）所以我们php可以这样写（路径可以写相对路径） 123456789&lt;?php $file=$_FILES[&#x27;img&#x27;]; if (is_uploaded_file($file[&#x27;tmp_name&#x27;]))&#123; echo(&quot;已识别到文件&quot;); if (move_uploaded_file($file[&#x27;tmp_name&#x27;],&#x27;D:\\phpstudy_pro\\Extensions\\Apache2.4.39\\htdocs\\uploads/&#x27;.$file[&#x27;name&#x27;]))&#123; echo(&quot;上传成功&quot;); &#125; &#125; 多文件上传当商品需要上传多个图片进行展示的时候：那么需要使用多文件上传针对一个内容但是不同文件说明：同名表单像复选框一样同名表单：将表单名字形成一个数组，而且同时将文件对应的五个要素：nameTmp_name、size、type、error都形成对应数量的数组，每个文件上传对应数组元素的下标都是一样的：name[0] 和type[0]是属于同一个文件 当商品需要进行多个维度图片说明的时候：需要使用多文件上传针对是不同内容所以表单名字不一样：批量解决问题不同名表单：每个文件都会形成一个属于自己独立的5个元素的数组 对多文件信息的遍历读取和处理不同名多文件上传处理方式：按照表单名字从$_FILES中取出来就可以直接使用（明确知道表单中有多少个文件上传）；如果不确定表单中有多少个文件上传，不适合挨个去取（效率不高），可以通过遍历$_FILES数组，挨个取出来实现文件上传同名多文件上传：想办法得到一个文件对应的五个元素数组。从$_FILES中把对应的name\\tmp_name\\size\\error\\type挨个取出来，然后存放到不同的数组中。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"MySQL学习笔记1","slug":"MySQL学习1：入门，DDL语句","date":"2021-01-24T14:07:25.050Z","updated":"2021-01-26T17:44:06.095Z","comments":true,"path":"2021/01/24/MySQL学习1：入门，DDL语句/","link":"","permalink":"http://example.com/2021/01/24/MySQL%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%85%A5%E9%97%A8%EF%BC%8CDDL%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"数据库基本概念 数据库：信息存储的仓库，包括一系列的关系措施！ 表:一个数据库中可以有若干张表（形式上你可以看出我们日常生活中建立的表） 字段:表里面的信息会分若干个栏目来存，这些栏目呢，我们在数据库技术中叫”字段”,栏目里面存的具体信息叫”字段值” 记录：一条信息我们叫一条记录，表中横向的多个字段值组成了一条记录，多条记录构成了一张数据表。一个数据库管理系统中可以建立若干个数据库，每个数据库中又可以建立若干张表,每张表中可以有若干条记录。 数据库可以想象成一个文件夹，里面的列表文件就叫表，表里面的一个个表头就叫字段，竖着看的就叫字段值，横着看的就叫一条条的记录 SQL语句分类 DDL(Data Definition Languages)语句数据定义语句，通过这类语言可以对数据库进行创建删除更改 DML(Data Manipulation Language)语句数据操纵语句，用于添加、删除、更新和查询数据库记录并检查数据完整性 DCL(Data Control Language)语句数据控制语句，通过此类语句可以对数据库的相关权限进行设置 DDL语句学习库 显示所有的库：show databases 创建数据库：create database 数据库名; 选择要操作的数据库：USE 数据库; 对于要操作的数据库我们需要使用use来选择一下！ 查看数据库的数据表：show tables; 删除数据库：drop database 数据库名表 创建表：在哪个数据库里面创建表需要先使用use选择到那个要操作的数据库12345create table 表名( 字段1名 字段1类型 列的约束条件, 字段2名 字段2类型 列的约束条件, ...) 查看表的定义：desc 表名; 查看创建表的SQL语句：show create table 表名 \\G这个\\G可以换成;显示的东西是一样的，效果不一样 删除表：drop table 表名 修改表：1，修改表的字段类型：alter table 表名 modify [column] 字段定义 [first|after 字段名]; 2，增加表字段：alter table 表名 add [column] 字段定义 [first|after 字段名]; 3，删除表字段 ：alter table 表名 drop [column] 字段名;4，字段改名：alter table 表名 change [column] 旧的字段名 目标字段定义（不仅是名字，也可以是类型） [first|after 字段名];注：change与modify都可以修改表的定义，不同的是change后面需要接两次列名，不方便，但是优点是change可以修改字段名称 5，修改字段排列排序：前面介绍的字段增加和修改语法(add/change/modify)中，都有一个可选项first|after 字段名,这个选择可以用来修改字段在表中的位置新增的字段默认是加载在表中最后位置，而change/modify 默认都不会改变字段的位置alter table t1 modify id2 tinyint first;alter table t1 modify id2 tinyint after id1;注意：change/first|after 字段名 这些关键字都是属于MySQL在标准SQL上的扩展，在其他的数据库上不一定适用 更改表名：alter table 表名 rename [to] 新的表名;","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"MySQL学习笔记2","slug":"MySQL学习2：DML语句","date":"2021-01-24T14:06:32.988Z","updated":"2021-01-27T17:34:49.355Z","comments":true,"path":"2021/01/24/MySQL学习2：DML语句/","link":"","permalink":"http://example.com/2021/01/24/MySQL%E5%AD%A6%E4%B9%A02%EF%BC%9ADML%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"DML数据操纵语句，用于添加、删除、更新和查询数据库记录并检查数据完整性 插入记录如果不在表名后面加括号写字段名后面的values就会按顺序依次赋值 单条插入insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n);也可以不用指定字段名，但是values后面的顺序应该和字段的排序一致 多条插入123456insert into 表名(字段1,字段2,字段3,...,字段n) values (值1,值2,值3,...,值n), (值1,值2,值3,...,值n), (值1,值2,值3,...,值n) ; 更新记录更新一个表update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 更新多个表中的数据update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件];注：多表更新更多的用在根据一个表的字段来动态的更新另外一个表的字段例子：update t1,t2 set ti.age=2000,t2.age=3000 where t1.id=1 and t2.id=1; 更新T1，T2集ti.age=2000，t2.age=3000，其中t1.id=1，t2.id=1； 删除记录删除单表中的数据delete from 表名 [where 条件]; 删除多个表中的数据delete 表1,表2,...表n from 表1,表2,...表n [where 条件];不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。 查询记录SELECT 字段1,字段2...或者* FROM 表名 WHERE 条件; 查询不重复的记录SELECT distinct field1,field2 FROM 表名;只要field1,field2任何一个字段有不同就会被选择！一般使用distinct,只筛选一个字段! 条件查询这个where条件意思是：查找满足后面这个条件的记录注：条件字段比较符号：=,&lt;,&gt;,&gt;=,&lt;=,!=等比较运算符多个条件之间可以使用or and等 排序和限制SELECT * FROM 表名 WHERE 条件 ORDER BY 字段1 [DESC|ASC],字段2 [DESC|ASC],...字段n [DESC|ASC];如果排序字段的值一样，则值相同的字段按照第二个排序字段进行排序，依次类推。如果只有一个排序字段，则这些字段相同的记录都将无序排列！默认是asc由低到高DESC表示：由高到低例如：select * from t1 order by age desc;ASC表示：由低到高例如：select * from t1 order by age asc; 对于排序后的数据如果只希望显示一部分，则可以使用 LIMIT 数字1,数字2 来限制数字1表示从哪个开始（从零开始计数的），数字2表示取出多少个例如：select * from t1 order by age limit 1,3; 聚合很多情况下，用户都需要进行一些汇总操作，这是就需要使用到SQL聚合操作 1SELECT [field1,field2,...fieldn] fun_name FROM 表名 [WHERE 条件] [GROUP BY field1,field2,...fieldn [WITH ROLLUP]] [HAVING 条件]; fun_name：聚合操作,聚合函数常用： sum()：求和：select sum(字段名) from 表名; count(*)：记录总数：select count(*|字段名) from 表名;一般就直接写* min() max()：最值：select max(字段名) from 表名; select min(字段名) from 表名;例如：GROUP BY 关键字表示要进行分类聚合(上面的这些函数)的字段、比如按部门分类统计员工数量，部门就应该写在GROUP BY后面。先建立一张这样的表：根据group by 后面的组来分类求和，比如下面的就是把相同的department分到同一组求和WITH ROLLUP 是可选语法，表明是否对分类聚合后的结果进行再汇总，就是把分了类的再全部求个和HAVING 关键字表示对分类后的结果再进行条件的过滤！注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤，应该尽可能的对记录进行先过滤！ ①直接统计：格式：select count([列名|*]) from 表名;举例：select count(*) from a1;//统计表a1中的所有记录②按某字段进行数据统计：格式：select field1,count([列名|*]) from 表名 group by field1;举例：select name,count(*) from a1 group by name;对表a1中的记录按name字段的值进行分组，并且对每个分组进行数量统计③按某字段进行数据统计,并且统计总数：格式：select field1,count([列名|*]) from 表名 group by field1 with rollup;举例：select name,count(*) from a1 group by name with rollup;④对统计后的数据进行再筛选格式：select field1,count([列名|*]) from 表名 group by field1 having count([列名|*])&gt;数值;举例：select name,count(*) from a1 group by name having count(*)&gt;4;⑤统计总和和最高最低以及总记录数：格式：select sum(field1),max(field1),min(field1),count([列名|*]) from 表名;举例：select sum(id),max(id),min(id),count(*) from a1; 表连接需求：显示多个表中的字段的时候即可使用表连接连接分类: 内连接：选取两张表中相互匹配的记录 外连接：不仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录举例： 内连接举例：先建立两张这样的表命名为employee命名为employee_record：进行如下操作：eid和id和并成了employee的id，表里既有employee的name字段又有employee_record的record字段，连接成了一个表select 表.字段,... from 表1,表2 where 需要满足的条件（比如：表1.想关联的字段1=dept.想关联的字段2）; 外连接左连接概念：包含左边表中的所有记录(包括右表中没有和它匹配的记录)，就以left join为轴，区分左表和右表例子：select ename,deptname from emp left join dept on emp.deptno=dept.deptno;右连接概念：包含右边表中的所有记录(包括左表中没有和它匹配的记录)与左连接同理子查询需求：一个查询需要另外一个查询的结果参与的时候用于子查询的关键字:in、not in语法：select * from 表1 where 某个字段 in(子查询语句);例子：建立这两个表： 若查询结果唯一可以使用“=”代替“in”select * from 表1 where 某个字段=(子查询语句);exists、not exits等语法：select语句1 from exists (select语句2)判断语句2有没有查询出语句，查出返回TRUE，如果查询出来的结果是NULL也会返回TRUE记录联合我们常常会碰到需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合多个select 语句用：UNION或者UNION ALL隔开即可实现语法：select xxx from 表1 union select xxx from 表2;联合的条件：两个表的字段数（列的数量）应该相等例子：还是先用上面创建的两个表 UNION和UNION ALL的区别：前者会将多个查询结果合并后并且进行去除重复后返回；后者则直接合并并不去除重复；","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"PHP学习笔记6","slug":"PHP学习笔记6：cookie和session","date":"2021-01-21T16:00:00.000Z","updated":"2021-01-21T19:03:34.255Z","comments":true,"path":"2021/01/22/PHP学习笔记6：cookie和session/","link":"","permalink":"http://example.com/2021/01/22/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%EF%BC%9Acookie%E5%92%8Csession/","excerpt":"","text":"Cookie创建cookiecookie是http头标的组成部分，一定要在其他内容发送之前就要发送，所以必须最先输出使用setcookie()函数创建 1setcookie(string name[,string value[,int expire[, string path[,string domain[,int secure]]]]]) 读取cookie直接通过超级全局数组$_COOKIE[]来读取浏览器端的Cookie值，举个例子 123456789101112&lt;?phpdate_default_timezone_set(&quot;Etc/GMT-8&quot;);if(!isset($_COOKIE[&quot;visittime&quot;]))&#123; //如果Cookie不存在 setcookie(&quot;visittime&quot;,date(&quot;y-m-d H:i:s&quot;)); //设置一个Cookie变量 echo &quot;欢迎您第一次访问网站！&quot;.&quot;&lt;br&gt;&quot;; //输出字符串&#125;else&#123; //如果Cookie存在 setcookie(&quot;visittime&quot;,date(&quot;y-m-d H:i:s&quot;),time()+60); //设置带Cookie失效时间的变量 echo &quot;您上次访问网站的时间为：&quot;.$_COOKIE[&quot;visittime&quot;]; //输出上次访问网站的时间 echo &quot;&lt;br&gt;&quot;; //输出回车符&#125; echo &quot;您本次访问网站的时间为： &quot;.date(&quot;y-m-d H:i:s&quot;); //输出当前的访问时间?&gt; 删除cookie方法有两种：一种是使用setcookie()函数删除，另一种是在浏览器中手动删除Cookie。下面分别进行介绍。使用setcookie()函数删除Cookie删除Cookie和创建Cookie的方式基本类似，删除Cookie也使用setcookie()函数。删除Cookie只需要将setcookie()函数中的第二个参数设置为空值，将第3个参数Cookie的过期时间设置为小于系统的当前时间即可。例如，将Cookie的过期时间设置为当前时间减1秒，代码如下： 1setcookie(&quot;name&quot;, &quot;&quot;, time()-1); Session了解Session翻译为“会话”，当启动一个Session会话时，会生成一个随机且唯一的session_id，也就是Session的文件名，此时session_id存储在服务器的内存中，当关闭页面时此id会自动注销，重新登录此页面，会再次生成一个随机且唯一的id。主要的步骤是：启动会话→注册会话→使用会话→删除会话 启动会话方式有两种：一种是使用session_start()函数，另一种是使用session_register()函数为会话登录一个变量来隐含地启动会话。使用session_start() 之前浏览器同样不能有任何输出 注册会话会话变量被启动后，全部保存在数组$_SESSION中。通过数组$_SESSION创建一个会话变量很容易，只要直接给该数组添加一个元素即可。例如，启动会话，创建一个Session变量并赋予空值，代码如下： 1234&lt;?php session_start(); //启动Session $_SESSION[&quot;admin&quot;] = null; //声明一个名为admin的变量，并赋空值 ?&gt; 使用会话首先需要判断会话变量是否有一个会话ID存在，如果不存在，就创建一个，并且使其能够通过全局数组$_SESSION进行访问。如果已经存在，则将这个已注册的会话变量载入以供用户使用。举个例子： 1234&lt;?phpif ( !empty ( $_SESSION[&#x27;session_name&#x27;])) //判断用于存储用户名的Session会话变量是否为空 $myvalue = $_SESSION[&#x27;session_name&#x27;] ;//将会话变量赋给一个变量$myvalue?&gt; 删除会话 删除单个会话删除会话变量，同数组的操作一样，直接注销$_SESSION数组的某个元素即可。例如，注销$_SESSION[&#39;user&#39;]变量，可以使用unset()函数，代码如下：unset ( $_SESSION[&#39;user&#39;] ) ; 删除多个会话 如果想要一次注销所有的会话变量，可以将一个空的数组赋值给$_SESSION，代码如下：$_SESSION = array() ; 结束当前会话如果整个会话已经结束，首先应该注销所有的会话变量，然后使用session_destroy()函数清除结束当前的会话，并清空会话中的所有资源，彻底销毁Session，代码如下：session_destroy() ;Session设置时间客户端没有禁止Cookie 使用setcookie()函数可对Session设置失效时间，例子： 123456&lt;?php session_start(); $time = 1*60; setcookie(session_name(),session_id(),time()+$time,&quot;/&quot;); # 使用setcookie手动设置Session失效时间 $_SESSION[&#x27;user&#x27;] = &#x27;mr&#x27; 客户端禁止Cookie1）在登录之前提醒用户必须打开Cookie，这是很多论坛的做法。2）设置php.ini文件中的session.use_trans_sid = 1，或者编译时打开-enable-trans-sid选项，让PHP自动跨页面传递session_id。3）通过GET方法，隐藏表单传递session_id。4）使用文件或者数据库存储session_id，在页面间传递中手动调用。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记5","slug":"PHP学习笔记5：表单，传参","date":"2021-01-19T16:00:00.000Z","updated":"2021-01-20T17:30:13.934Z","comments":true,"path":"2021/01/20/PHP学习笔记5：表单，传参/","link":"","permalink":"http://example.com/2021/01/20/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%EF%BC%9A%E8%A1%A8%E5%8D%95%EF%BC%8C%E4%BC%A0%E5%8F%82/","excerpt":"","text":"表单创建表单使用&lt;from&gt;标记，并在其中插入相关的表单元素，即可创建表单 123&lt;form name=&quot;form_name&quot; method=&quot;method&quot; action=&quot;url&quot; enctype=&quot;value&quot; target=&quot;target_win&quot;&gt;… //省略插入的表单元素&lt;/form &gt; 表单元素 输入域标记&lt;input&gt; 输入域标记&lt;input&gt;是表单中最常用的标记之一。常用的文本框、按钮、单选按钮、复选框等构成了一个完整的表单。 语法格式如下：123&lt;form&gt;&lt;input name=&quot;file_name&quot; type=&quot;type_name&quot;&gt;&lt;/form&gt; 参数name是指输入域的名称，参数type是指输入域的类型提供了10种类型的输入区域 选择域标记&lt;select&gt;和&lt;option&gt; 123456&lt;select name=&quot;name&quot; size=&quot;value&quot; multiple&gt;&lt;option value=&quot;value&quot; selected&gt;选项1&lt;/option&gt;&lt;option value=&quot;value&quot;&gt;选项2&lt;/option&gt;&lt;option value=&quot;value&quot;&gt;选项3&lt;/option&gt;…&lt;/select&gt; 菜单模式就是在&lt;select&gt;里面加上multiple列表模式就是在&lt;select&gt;里面不加multiple 文字域标记&lt;textarea&gt;文字域标记&lt;textarea&gt;用来制作多行的文字域，可以在其中输入更多的文本 123&lt;textarea name=&quot;name&quot; rows=value cols=value value=&quot;value&quot; warp=&quot;value&quot;&gt; …文本内容&lt;/textarea&gt; name表示文字域的名称；rows表示文字域的行数；cols表示文字域的列数（这里的rows和cols以字符为单位）；value表示文字域的默认值warp用于设定显示和送出时的换行方式，值为off表示不自动换行，值为hard表示自动硬回车换行，换行标记一同被发送到服务器，输出时也会换行，值为soft表示自动软回车换行，换行标记不会被发送到服务器，输出时仍然为一列。 获取表单数据有两种方式POST和GET POST应用POST方法时，只需将表单中的属性method设置成POST即可。POST方法不依赖于URL，不会显示在地址栏。POST方法可以没有限制地传递数据到服务器，所有提交的信息在后台传输，用户在浏览器端是看不到这一过程的，安全性高。所以POST方法比较适合用于发送一个保密的（如信用卡号）或者容量较大的数据到服务器。 GETGET方法是表单中method属性的默认方法。使用GET方法提交的表单数据被附加到URL后，并作为URL的一部分发送到服务器端GET方法的传参格式如下：1http://url?name1=value1&amp;name2=value2…… url和表单元素之间用“?”隔开，而多个表单元素之间用“&amp;”隔开，每个表单元素的格式都是name=value，固定不变。这个方式提交参数会把参数暴露，不适合做账号密码提交 PHP的传参方式$_POST[]全局变量建立一个表单，设置method属性为POST，添加一个文本框，命名为user，获取表单元素的代码如下： 123&lt;?php$user=$_POST[&quot;user&quot;]; //应用$_POST[]全局变量获取表单元素中文本框的值?&gt; isset($_POST[&quot;submit&quot;]这句话是判断变量是否存在，当按下按钮以后他就存在了，$_POST[&quot;submit&quot;]==&quot;提交&quot;是判断这个按钮的值（value）是不是“提交” $_GET[]全局变量建立一个表单，设置method属性为GET，添加一个文本框，命名为user，获取表单元素的代码如下： 123&lt;?php$user=$_GET[&quot;user&quot;]; //应用$_GET[]全局变量获取表单元素中文本框的值?&gt; $_SESSION[]变量建立一个表单，添加一个文本框，命名为user，获取表单元素的代码如下： 1$user=$_SESSION[&quot;user&quot;] 使用$_SESSION[]传参的方法获取的变量值，保存之后任何页面都可以使用。但这种方法很耗费系统资源，慎重使用。 在web中嵌入php脚本在HTML标记中添加PHP脚本在Web编码过程中，可以随时添加PHP脚本标记，两个标记之间的所有文本都会被解释成为PHP，而标记之外的任何文本都会被认为是普通的HTML。 对表单元素的value属性进行赋值例如，为表单元素隐藏域进行赋值，只需要将所赋的值添加到value属性后即可，代码如下： 1234&lt;?php $hidden=&quot;yg0025&quot;; //为变量$hidden赋值?&gt;隐藏域的值 :&lt;input type=&quot;hidden&quot; name=&quot;ID&quot; value=&quot;&lt;?php echo $hidden;?&gt;&quot; &gt; 首先为变量$hidden赋予一个初始值，然后将变量$hidden的值赋给隐藏域。 在PHP中获取表单元素获取文本框、密码域、隐藏域、按钮、文本域的值在程序开发过程中，获取文本框、密码域、隐 藏域、按钮以及文本域的值的方法是相同的，都是使用name属性来获取相应的value属性值。例子就像上面的那个一样 123456789101112131415161718&lt;body&gt;&lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;table width=&quot;509&quot; border=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;账号&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot; size=&quot;20&quot; &gt;&lt;/td&gt; &lt;td&gt; 密码&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;pwd&quot; type=&quot;password&quot; id=&quot;pwd&quot; size=&quot;20&quot; &gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;submit&quot; type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&quot;submit&quot;]) &amp;&amp; $_POST[&quot;submit&quot;]==&quot;提交&quot;)&#123; echo &quot;账号&quot;.$_POST[&#x27;user&#x27;].&quot;&amp;nbsp;&amp;nbsp;密码&quot;.$_POST[&#x27;pwd&#x27;];&#125;?&gt;&lt;/body&gt; 获取单选按钮的值 获取复选框的值复选框一般都是多个同时存在，为了便于传值，name的名字可以是一个数组形式，格式为： 1&lt;input type=&quot;checkbox&quot; name=&quot;chkbox[]&quot; value=&quot;chkbox1&quot;&gt; 可以使用count()函数计算数组的大小，结合for循环语句输出选择的复选框的值。可以通过下面例子理解： 123456789101112131415161718192021222324252627&lt;body&gt;&lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;table width=&quot;500&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td width=&quot;400&quot; height=&quot;25&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt; 你喜欢的图书类型 &lt;input type=&quot;checkbox&quot; name=&quot;mrbook[]&quot; value=&quot;入门类&quot;&gt; 入门类 &lt;input type=&quot;checkbox&quot; name=&quot;mrbook[]&quot; value=&quot;案例类&quot;&gt; 案例类 &lt;input type=&quot;checkbox&quot; name=&quot;mrbook[]&quot; value=&quot;讲解类&quot;&gt; 讲解类 &lt;input type=&quot;checkbox&quot; name=&quot;mrbook[]&quot; value=&quot;典型实例类&quot;&gt; 实例类 &lt;/td&gt; &lt;td width=&quot;40&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&#x27;mrbook&#x27;]) &amp;&amp; $_POST[&#x27;mrbook&#x27;]!=&quot;&quot;)&#123; echo &quot;你选择的结果是：&quot;; for($i = 0;$i&lt;count($_POST[&#x27;mrbook&#x27;]);$i++) echo $_POST[&#x27;mrbook&#x27;][$i].&quot;&amp;nbsp;&amp;nbsp;&quot;;&#125;?&gt;&lt;/body&gt; 获取下拉列表框/菜单列表框的值1．获取下拉列表框的值 获取下拉列表框的值的方法非常简单，与获取文本框的值类似，首先需要定义下拉列表框的name属性值，然后应用$_POST[]全局变量进行获取。 12345678910111213141516171819202122&lt;body&gt;&lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;table width=&quot;280&quot; border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td width=&quot;80&quot; height=&quot;25&quot; align=&quot;center&quot;&gt;&lt;span class=&quot;style2&quot;&gt;abcde:&lt;/span&gt;&lt;/td&gt; &lt;td width=&quot;194&quot;&gt; &lt;select name=&quot;select&quot; size=&quot;1&quot;&gt; &lt;option value=&quot;aaa&quot; selected&gt;aaa&lt;/option&gt; &lt;option value=&quot;bbb&quot;&gt;bbb&lt;/option&gt; &lt;option value=&quot;ccc&quot;&gt;ccc&lt;/option&gt; &lt;option value=&quot;ddd&quot;&gt;ddd&lt;/option&gt; &lt;/select&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;submit&#x27;]==&quot;提交&quot;)&#123; echo &quot;结果：&quot;.$_POST[&#x27;select&#x27;];&#125;?&gt;&lt;/body&gt; 2．获取菜单列表框的值 当标记设置了multiple属性，则为菜单列表框，可以选择多个条件。由于菜单列表框一般都是多个值同时存在，为了便于传值，标记的命名通常采用数组形式，格式为： 在返回页面可以使用count()函数计算数组的大小，结合for循环语句输出选择的菜单项。 12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;table width=&quot;423&quot; border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td width=&quot;231&quot; height=&quot;30&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;请选择：&lt;/td&gt; &lt;td width=&quot;192&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;select name=&quot;select[]&quot; size=&quot;5&quot; multiple&gt; &lt;option value=&quot;000&quot;&gt;000&lt;/option&gt; &lt;option value=&quot;111&quot;&gt;111&lt;/option&gt; &lt;option value=&quot;222&quot;&gt;222&lt;/option&gt; &lt;option value=&quot;333&quot;&gt;333&lt;/option&gt; &lt;option value=&quot;444&quot;&gt;444&lt;/option&gt; &lt;option value=&quot;555&quot;&gt;555&lt;/option&gt; &lt;/select&gt;&lt;/td&gt; &lt;td align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=&quot;30&quot; colspan=&quot;2&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;?phpif(isset($_POST[&#x27;select&#x27;]) &amp;&amp; $_POST[&#x27;select&#x27;] != &quot;&quot;)&#123; echo &quot;你的选择是:&quot;; for($i = 0; $i &lt; count($_POST[&#x27;select&#x27;]); $i++) echo $_POST[&#x27;select&#x27;][$i].&quot;&amp;nbsp;&amp;nbsp&quot;;&#125;?&gt; 获取文件域的值文件域的作用是实现文件或图片的上传。文件域有一个特有的属性accept，用于指定上传的文件类型，如果需要限制上传文件的类型，则可以通过设置该属性完成。 1234567891011&lt;body&gt; &lt;form name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; size=&quot;15&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;upload&quot; value=&quot;上传&quot;&gt; &lt;/form&gt;&lt;?php if(isset($_POST[&#x27;file&#x27;]) &amp;&amp; $_POST[&#x27;file&#x27;]!=&quot;&quot;)&#123; echo $_POST[&#x27;file&#x27;]; &#125;?&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记4","slug":"php学习笔记4","date":"2021-01-18T16:00:00.000Z","updated":"2021-01-19T04:19:56.354Z","comments":true,"path":"2021/01/19/php学习笔记4/","link":"","permalink":"http://example.com/2021/01/19/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/","excerpt":"","text":"错误处理错误分类1）语法错误：用户书写的代码不符合PHP的语法规范，语法错误会导致代码在编译过程中不通过，所以代码不会执行（Parse error）2）运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足导致的错误（runtime error）3）逻辑错误：程序员在写代码的时候不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果 错误触发 程序运行时触发：系统自动根据错误发生后，对比对应的错误信息，输出给用户：主要针对代码的语法错误和运行时错误。 人为触发：知道某些逻辑可能会出错，从而使用对应的判断代码来触发响应的错误提示Trigger_error(错误提示)：可以通过第二个参数进行严格性控制数组 数组定义 array关键字：这个方法最常使用1$变量 = array(元素1,元素2,元素3..); 要是想想字典一样的创建可以这样 类似于py中数组的定义1$变量 = [元素1,元素2…]; 隐形定义数组：给变量增加一个中括号，系统自动变成数组12$变量[] = 值1; //如果不提供下标也可以，系统自动生成，从最后写到的下标开始往后标$变量[下标] = 值; //中括号里面的内容称之为下标key，该下标可以是字母（单词）或者数字，与变量命名的规则相似 数组的特点 下标除了整数，还可以是字符串：如果数组下标都为整数：索引数组如果数组下标都为字符串：关联数组（有点像py的字典） 不同下标可以混合存在：混合数组 数组元素的顺序以放入顺序为准，跟下标无关 PHP中数组元素没有类型限制 PHP中数组元素没有长度限制 特殊值下标的自动转换布尔值：true和false空：NULL二维数组多维数组：数组里面的元素又是数组数组的遍历使用foreach遍历数组 123foreach($数组变量 as [$下标 =&gt;] $值)&#123; //通过$下标访问元素的下标；通过$值访问元素的值&#125; 就拿上面这个举例子：其实就是把数组arr中的每一个元素给$v然后再用$v去做事 foreach遍历的原理：本质是数组的内部有一颗指针，默认是指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针 123foreach($arr as $k =&gt; $v)&#123; //循环体&#125; 1、 foreach会重置指针：让指针指向第一个元素；2、 进入foreach循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量$k中（如果存在），将值取出来放到对应的值变量$v中；（指针下移）3、 进入到循环内部（循环体），开始执行；4、 重复2和3，直到在2的时候遇到指针取不到内容（指针指向数组最后） for循环遍历1、获取数组长度：count(数组)得到数组元素的长度2、要求数组元素的下标是规律的数字 while配合each和list遍历 each()函数的使用each能够从一个数组中获取当前数组指针所指向的元素的下标和值，拿到之后将数组指针下移，同时将拿到的元素下标和值以一个四个元素的数组返回：0下标 =&gt; 取得元素的下标值1下标 =&gt; 取得元素的值Key下标 =&gt; 取得元素的下标值Value下标 =&gt; 取得元素的值 list结构的使用list提供一堆变量去从一个数组中取得元素值，然后依次存放到对应的变量当中（批量为变量赋值：值来源于数组）：list必须从索引数组中去获取数据，而且必须从0开始。 1list($自己设的变量名) = $数组名 List与each配合each一定有两个元素就是0和1下标元素 1list(变量1,变量2) = each(数组); 就相当于是把each的四个元素的前两个给list分别作为下标和值但是each()在php7.2开始就被废弃了 数组相关函数排序函数 sort()：顺序排序（下标重排） rsort()：逆序排序 asort()：顺序排序（下标保留） arsort()：逆序排序 ksort()：顺序排序：按照键名（下标）来排序，和值无关 krsort()：逆序排序 shuffle()：随机打乱数组元素，数组下标会按序重排 指针函数 reset()：重置指针，将数组指针回到首位 end()：重置指针，将数组指针指导最后一个元素 next()：指针下移，取得下一个元素的值 prev()：指针上移，取得上一个元素的值 current()：获取当前指针对应的元素值 key()：获取当前指针对应的下标值注意事项：next和prev会移动指针，有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过next和prev不能回到真确的指针位置。只能通过end或者reset进行指针重置 其他函数 count()：统计数组中元素的数量 array_push()：往数组中加入一个元素（数组后面） array_pop()：从数组中取出一个元素（数组后面） array_shift()：从数组中取出一个元素（数组前面） array_unshift()：从数组中加入一个元素（数组前面） array_reverse()：数组元素反过来 in_array()：判断一个元素在数组中是否存在 array_keys()：获取一个数组的所有下标，返回一个索引数组 array_values()：获取一个数组的所有值，返回一个索引数组","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记3","slug":"PHP学习笔记3","date":"2021-01-17T16:00:00.000Z","updated":"2021-01-19T04:20:11.013Z","comments":true,"path":"2021/01/18/PHP学习笔记3/","link":"","permalink":"http://example.com/2021/01/18/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/","excerpt":"","text":"字符串引号php里面单引号和双引号是不一样的，在定义字符串的时候没有区别但是字符串里面有变量的时候就不一样了双引号是经过语法分析的，单引号是“所见即所得“ 定界符&lt;&lt;&lt;：用于定义一个格式化的大文本，；里面的格式化文本并不需要转义字符，文本格式将被保留这个定界符是不支持添加注释的其实效果就和双引号效果一样，就是用来定义大文本 nowdoc字符串：没有单引号的单引号字符串 123$str = &lt;&lt;&lt;’边界符’ 字符串内容边界符; heredoc字符串：没哟双引号的双引号字符串 123$str = &lt;&lt;&lt;边界符 字符串内容边界符; 字符串转义 \\’：在单引号字符串中显示单引号 \\”：在双引号字符串中显示双引号 \\r：代表回车（理论上是回到当前行的首位置） \\n：代表新一行 \\t：类似tab键，输出4个空格 \\$：在PHP中使用$符号作为变量符号，因此需要特定识别 注意单引号不会识别转义符号，而是直接输出 字符串长度基本函数strlen()：得到字符串的长度（字节为单位）可以使用这个来判断用户提交的密码是多少位这种类型 字符串常用函数 implode(连接方式,数组)：将数组中的元素按照某个规则连接成一个字符串 explode(分割字符,目标字符串)：将字符串按照某个格式进行分割，变成数组 trim(字符串[,指定字符])：本身默认是用来去除字符串两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符为止。可以选择左边和右边ltrim()：去除左边的，rtrim()：去除右边的 substr(字符串,起始位置从0开始[,长度])：指定位置开始截取字符串，可以截取指定长度（不指定到最后） Strstr(字符串,匹配字符)：从指定位置开始，截取到最后（可以用来去文件后缀名） Strpos(字符串，匹配字符)：判断字符在目标字符串中出现的位置（首次） Strrpos(字符串，匹配字符)：判断字符在目标字符串中最后出现的位置 Str_shuffle()：随机打乱字符串 文件包含在一个PHP脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情有四种方式： Include：包含文件 Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次） Require：与include相同 Require_once：以include_once相同语法12include ‘文件路径’;include(‘文件路径’); 以上方式：是先包含文件，后使用文件中的内容（向上包含） 向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容区别就是在引用的文件是用来给属性的还是用来做事的 文件加载原理1、 在文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中2、 加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置3、 在PHP中被包含的文件是单独进行编译的 PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错。 区别include和include_once的区别： include系统会碰到一次，执行一次；如果对统一个文件进行多次加载，那么系统会执行多次； include_once：系统碰到多次，也只会执行一次。 require和include的区别：本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样 include的错误级别比较轻：不会阻止代码执行 require要求较高：如果包含出错代码不再执行（require后面的代码） 常用函数输出 print()：类似于echo输出提供的内容，本质是一种结构（不是函数），返回1，可以不需要使用括号 print_r()：类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数组打印使用比较多）输出的区别 echo : 输出一个或多个字符串 print : 输出简单变量的值，如int,string类型变量的 print_r : 输出比较复杂类型的值，如数组，对象时间 date()：按照指定格式对对应的时间戳（从1970年格林威治时间开始计算的秒数），如果没有指定特定的时间戳，那么就是默认解释当前时间戳 1data(&#x27;想输出的信息&#x27;,[想从哪个时间戳开始]) time()：获取当前时间对应的时间戳 microtime()：获取微秒级别的时间 Strtotime()：按照规定格式的字符串转换成时间戳 数学 max()：指定参数中最大的值 min()：比较两个数中较小的值 rand()：得到一个随机数，指定区间的随机整数 mt_rand()：与rand一样，只是底层结构不一样，效率比rand高（建议使用） round()：四舍五入 ceil()：向上取整 floor()：向下取整 pow()：求指定数字的指定指数次结果：pow(2,8) == 2^8 abs()：绝对值 sqrt()：求平方根有关函数的函数function_exists()：判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）func_get_arg()：在自定义函数中去获取指定数值对应的参数func_get_args()：在自定义函数中获取所有的参数（数组）func_num_args()：获取当前自定义函数的参数数量","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记2","slug":"PHP学习笔记2","date":"2021-01-16T16:00:00.000Z","updated":"2021-01-19T04:20:05.903Z","comments":true,"path":"2021/01/17/PHP学习笔记2/","link":"","permalink":"http://example.com/2021/01/17/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","excerpt":"","text":"运算符 % ：取余（模）运算，两个数（整数）相除，保留余数,如果被除数（%前面那个）是复数结果也是复数 &amp;&amp;：逻辑与，左边的条件与右边的条件同时成立（两边结果都为true） ||：逻辑或，左边的条件或者右边的条件只要有一个满足即可 !：逻辑非，对已有条件进行取反，本身为true，取反结果就是false xor：逻辑异或 拼接运算符：英文的句号：. .=拼接运算符也是可以接等号的 递增递减在php也可行：++，-- 错误抑制符：@：在可能出错的表达式前面使用@符号即可 比较运算符 ===：全等于，左边与右边相同：大小以及数据的类型都要相同 !==：不全等于，只有大小或者类型不同 条件运算符（三目运算符）表达式1 ? 表达式2 ：表达式3；运算：如果表达式1成立，那么执行表达式2，否则执行表达式3；该运算符可以嵌套使用，表达式也可以带条件运算符：表达式1 ？ (表达式2 ? 表达式4 : 表达式5) : (表达式3 ? 表达式5 : 表达式6); 位运算符将数字转化成二进制来进行运算，类似于这样： &amp;：按位与，两个位都为1，结果为1，否则为0 |：按位或，两个有一个为1，结果为1 ~：按位非，一个位如果为1则变成0，否则反之 ^：按位异或，两个相同则为0，不同则为1 &lt;&lt;：按位左移，整个位（32位），向左移动一位，右边补0 &gt;&gt;：按位右移，整个位向右移动一位，左边补符号位对应内容（正数补0，负数补1） 函数定义用function关键字来定义function 函数名([参数]){ //函数体 //返回值：return 结果;} 调用函数名+() 函数的参数传递分为三种方式：值传递，’引用传递，默认参数，之前有学过这前两种传递方式 值传递在函数内对值改变他本身的值不会变 引用传递就是在函数定义时在变量前加上&amp;就行，改变的是“根”，函数里对这个变量改变时，他的值就会被改变 默认参数定义的时候直接给一个参数赋值，和py的默认参数一样，权重最小 返回值只能返回一个参数，如果有多个就先放到数组里面在返回数组 变量函数这个挺有意思的就是可以用值与函数名相同的变量来执行函数，有点像之前学的可变变量$$a 匿名函数变量保存匿名函数，本质得到的是一个对象（Closure） 123变量名 = Function()&#123; 函数体&#125;; 条件控制if-else语句 123456If(条件表达式)&#123; //满足条件所要执行的内容; &#125;If(条件表达式)&#123; //满足条件所要执行的内容; &#125;php的`if-else`可以使用`elseif` switch语句12345678910111213Switch(条件表达式)&#123; //所有条件判断：逐个进行 Case 值1: //当前条件表达式的结果与值1相等（==） 要执行的代码段; Break; //在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码除外），需要中断执行：break表示中断switch（结束）。 Case 值2: 要执行的代码段; Break; … //可以使用类似else的语法：都不匹配 Default: //匹配失败的代码; Break; 循环结构for循环12345678for(条件表达式1;条件表达式2;条件表达式3)&#123; //条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可 //条件表达式2：边界判定，限定循环执行的次数 //条件表达式3：用来执行条件变化（自操作） //循环体&#125; while循环1234while(条件表达式)&#123; //条件表达式就是判断边界条件 循环体; //循环条件的变化&#125; do-while循环123do&#123; //循环体&#125;while(条件表达式); foreach循环语句只能用于数组，php5增加支持对象 1234foreach($array as $value) 语句;foreach($array as $key =&gt; $value) 这个语句将遍历数组$array，将当前数组中的值传给$value（或$key和$value） break和continuebreak和continue都可以再加一个数字，表示跳出几层循环","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"PHP学习笔记1","slug":"PHP学习笔记1","date":"2021-01-15T16:00:00.000Z","updated":"2021-01-17T09:48:10.238Z","comments":true,"path":"2021/01/16/PHP学习笔记1/","link":"","permalink":"http://example.com/2021/01/16/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"php学习开始，在这记录我觉得需要注意的地方 变量变量定义： “$”前面加上这个就是变量 变量名不能以数字开头 将变量从内存中删除使用unset($变量名)函数来删除变量 变量的作用域 局部变量：函数内定义的变量 全局变量：在自定义函数内是不可以使用的，如果想在自定义函数内调用要使用global关键字声明 静态变量：函数调用结束后保留变量值，不会被消除内存，可以用来记录博客访客或者聊天记录这样的东西，要在函数内用static关键字来声明 预定义变量预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）$_GET：获取所有表单以get方式提交的数据$_POST：POST提交的数据都会保存在此$_REQUEST：GET和POST提交的都会保存$GLOBALS：PHP中所有的全局变量$_SERVER：服务器信息$_SESSION：session会话数据$_COOKIE：cookie会话数据$_ENV：环境信息$_FILES：用户上传的文件信息 可变变量可变变量：如果一个变量保存的值刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面再多加一个$符号。 123$a=&#x27;b&#x27;$b=&#x27;c&#x27;echo $$a $$a就相当于$b就是c 变量传值分为两种，一个是值传递，一个是引用传递 值传递值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存（两个变量没有关系）a就对应a的值，b就对应b的值 引用传递引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间（两个变量是同一个值）$新变量=&amp;$老变量这个方式给变量赋值是让两个变量名指向同一个值，就像一棵树上的两个枝干，都是连着一个树根所以改变了任何一个的值，两个的值都会改变 常量常量的定义有两种定义方式，define函数和const关键字 define函数：define(&#39;常数名&#39;,值) const关键字const 常量名 = 值 命名规则 常量命名不需要”$”，使用了这个符号就会被认为是变量 常量一波用大写，但是默认不区分大小写 魔术常量他们有双下划线开始+长两名+双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了 __DIR__：当前被执行的脚本所在电脑的绝对路径 __FILE__：当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字） __LINE__：当前所属的行数 __NAMESPACE__：当前所属的命名空间 __CLASS__：当前所属的类 __METHOD__：当前所属的方法 数据类型PHP是一种弱类型语言，变量本身没有数据类型。 php的八种数据类型 整型：int/integer，系统分配4个字节存储，表示整数类型（有前提） 浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数 字符串型：string，系统根据实际长度分配，表示字符串（引号） 布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false 复合数据类型：2个小类 对象类型：object，存放对象（面向对象） 数组类型：array，存储多个数据（一次性） 特殊数据类型：2个小类 资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件） 空类型：NULL，只有一个值就是NULL（不能运算） 强制转换 强制转换规则：在变量之前增加一个括号()，然后在里面写上对应类型：int/integer….其中NULL类型用到unset() 其他类型转数值的说明1、 布尔true为1，false为0；2、 字符串转数值有自己的规则 2.1 以字母开头的字符串，永远为0；2.2 以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点） 类型判断 is_开头后面跟类型名字的函数：is_XXX(变量名) 布尔类型不能用echo来访问，无法区分是布尔的true还是字符串的true，所以有个函数var_dump(变量1，变量2...)这个函数会返回变量的类型和值 Gettype(变量名)：获取类型，得到的是该类型对应的字符串 Settype(变量名,类型)：设定数据类型：与强制转换不同：1、 强制转换(类型)变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）2、 settype会直接改变数据本身整数类型在PHP中提供了四种整型的定义方式：十进制定义，二进制定义，八进制定义和十六进制定义$a = 120; //10进制$a=0b110; //2进制$a=0120; //8进制$a=0x120; //16进制Decbin()：十进制转二进制Decoct()：十进制转八进制Dechex()：十进制转十六进制Bindec()：二进制转十进制 浮点类型浮点型定义有两种方式：$f = 1.23;$f = 1.23e10; //科学计数法，其中e表示底10 伪类型伪类型：假类型，实际上在PHP中不存在的类型。但是通过伪类型可以帮助程序员去更好的查看操作手册从而更方便学习。 伪类型主要有两种：在三大类八小类之外 Mixed：混合的，可以是多种PHP中的数据类型Number：数值的，可以是任意数值类型（整形和浮点型）","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"爬虫笔记4模拟登陆","slug":"爬虫笔记4模拟登陆","date":"2021-01-12T16:00:00.000Z","updated":"2021-01-13T12:41:11.246Z","comments":true,"path":"2021/01/13/爬虫笔记4模拟登陆/","link":"","permalink":"http://example.com/2021/01/13/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B04%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/","excerpt":"","text":"这次模拟4399的登陆这篇不难，主要是学到了这几点 requests模块有个session方法可以记录网页的cookie 模拟登陆的时候有两个请求，第一个是用来登陆的，第二个是用来保存登陆界面的 一般的登陆都是post传参但是我们只需要提供用户名和密码就可以这样写123data=&#123;&#125;data[&quot;username&quot;]=&quot;1093533435&quot;data[&quot;password&quot;]=&quot;liouyuwen&quot; 先附上源代码123456789101112import requestssession=requests.Session()url=&quot;https://ptlogin.4399.com/ptlogin/login.do?v=1&quot;urlpro=&quot;https://u.4399.com/profile/&quot;headers=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;data=&#123;&#125;data[&quot;username&quot;]=&quot;xxxxxx&quot;data[&quot;password&quot;]=xxxxxx&quot;res=session.post(url=url,data=data,headers=headers)profile=session.get(url=urlpro,headers=headers).textwith open(&quot;4399.html&quot;,&quot;w&quot;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(profile) 调用Session方法12import requestssession=requests.Session() 此后所有的请求就不用requests.get/post而使用session.get或session.post 配置爬虫发起请求12345678url=&quot;https://ptlogin.4399.com/ptlogin/login.do?v=1&quot;urlpro=&quot;https://u.4399.com/profile/&quot;headers=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;data=&#123;&#125;data[&quot;username&quot;]=&quot;xxxxxx&quot;data[&quot;password&quot;]=xxxxxx&quot;res=session.post(url=url,data=data,headers=headers)profile=session.get(url=urlpro,headers=headers).text 第一个请求不需要在后面加格式，就是用来发起请求，得到cookie并登入进去第二个请求就是用来获取登入后的界面的 文件保存12with open(&quot;4399.html&quot;,&quot;w&quot;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(profile) 可以看到已经爬出来了","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"cookie","slug":"cookie","permalink":"http://example.com/tags/cookie/"}]},{"title":"aiohttp的学习使用","slug":"asyncio库的细化学习","date":"2021-01-11T16:00:00.000Z","updated":"2021-01-13T02:18:59.080Z","comments":true,"path":"2021/01/12/asyncio库的细化学习/","link":"","permalink":"http://example.com/2021/01/12/asyncio%E5%BA%93%E7%9A%84%E7%BB%86%E5%8C%96%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前面博客讲的太泛了，对于我搞爬虫就细化学习理解一波，基于这篇博客的学习由于requests库和asyncio库是不能一起使用的，所以我们要安装一点小插件pip install aiohttp先上代码 12345678910111213141516171819202122232425import asyncioimport aiohttpasync def func(url): headers = &#123; &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot; &#125; print(&#x27;开始下载&#x27;,url) async with aiohttp.ClientSession() as session: async with await session.get(url=url,headers=headers) as response: data = await response.read() name = url.split(&#x27;/&#x27;)[-1] with open(name,&#x27;wb&#x27;) as fp: fp.write(data) print(&#x27;下载完成&#x27;,url)urls = [&#x27;https://ziyuan.jumpw.com/heroactivity/cases2020/anniversary/images/img_01.png&#x27;, &#x27;https://ziyuan.jumpw.com/heroactivity/cases2020/anniversary/images/img_02.png&#x27;, &#x27;https://ziyuan.jumpw.com/heroactivity/cases2020/anniversary/images/img_03.png&#x27; ]tasks=[]for url in urls: a = func(url) task = asyncio.ensure_future(a) tasks.append(task)loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 基本步骤： 导入库 这里注意不使用requests了，直接使用aiohttp 12import asyncioimport aiohttp 建立任务单 1234urls = [&#x27;https://ziyuan.jumpw.com/heroactivity/cases2020/anniversary/images/img_01.png&#x27;, &#x27;https://ziyuan.jumpw.com/heroactivity/cases2020/anniversary/images/img_02.png&#x27;, &#x27;https://ziyuan.jumpw.com/heroactivity/cases2020/anniversary/images/img_03.png&#x27; ] 用循环对每一条任务进行操作1for url in urls: 创建协程对象1a = func(url) 将任务封装 使用asyncio.ensure_future()来封装ensure_future 其实是用来创建任务的 123tasks = [] # 这个写在循环外面task = asyncio.ensure_future(a)tasks.append(task) 建立事件循环 利用asyncio.get_event_loop()创建事件循环 1loop = asyncio.get_event_loop() 把任务列表放到事件循环里面运行 运用这个函数执行运行任务单.run_until_complete()这个函数的参数是future或者协程这个函数asyncio.wait()叫简单等待如果参数可以是一个任务单列表，如果里面有协程（或者其他的可等待对象）它将自动作为任务加入日程。 1loop.run_until_complete(asyncio.wait(tasks)) 定义一个爬虫协程 这个爬虫的特点是url要从外面导入注意的是aiohttp的使用格式比较固定，套着用就是了 12345678910111213141516171819async def func(url): headers = &#123; &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot; &#125; print(&#x27;开始下载&#x27;,url) # 类似于上下文管理器，就是with open,with前面一定要加async，固定写法 # as session是类似起名字一样 async with aiohttp.ClientSession() as session: # async with跟上面同理，await是手动挂起，因为向图片发起请求是IO操作 async with await session.get(url=url,headers=headers) as response: # 同样的，对返回的数据进行解析也是IO操作 # 不同于requests模块，read()指的是解析二进制数据 # text() 就是我们平时用的text # 而json对象则要用json() data = await response.read() name = url.split(&#x27;/&#x27;)[-1] with open(name,&#x27;wb&#x27;) as fp: fp.write(data) print(&#x27;下载完成&#x27;,url) 运行一波啪的一下很快啊","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"协程","slug":"协程","permalink":"http://example.com/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"协程asyncio库的学习和理解","slug":"协程asyncio库的学习与理解","date":"2021-01-09T16:00:00.000Z","updated":"2021-01-13T02:18:58.183Z","comments":true,"path":"2021/01/10/协程asyncio库的学习与理解/","link":"","permalink":"http://example.com/2021/01/10/%E5%8D%8F%E7%A8%8Basyncio%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/","excerpt":"","text":"基于python文档和一些大佬的博客学习，谈谈我对于协程的学习与理解协程：coroutine ，简写成：coro 协程函数: 定义形式为 async def 的函数; 协程对象: 调用 协程函数 所返回的对象。协程通过 async/await 语法进行声明 定义函数的时候再头上加一个async就变成了协程 调用的时候也要在函数名前加上await123456import asyncioasync def do(): print(&#x27;hello&#x27;) await asyncio.sleep(1) print(&#x27;world&#x27;)asyncio.run(do()) 简单地调用一个协程并不会将其加入执行日程 运行 asyncio 程序asyncio.run(coro, *, debug=False) 执行 coroutine（协程） coro 并返回结果。 如果 debug 为 True，事件循环将以调试模式运行。 此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。 用来运行最高层级的入口点”do()”函数上面的实例就使用了这个函数 123456import asyncioasync def do(): print(&#x27;hello&#x27;) await asyncio.sleep(1) print(&#x27;world&#x27;)asyncio.run(do()) 等待12345678910111213141516import asyncioimport timeasync def say_after(delay, what): await asyncio.sleep(delay) print(what)async def main(): print(&quot;started at&quot;, time.strftime(&#x27;%X&#x27;)) await say_after(1, &#x27;hello&#x27;) await say_after(2, &#x27;world&#x27;) print(&quot;started at&quot;, time.strftime(&#x27;%X&#x27;))asyncio.run(main()) 简单等待asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED) 并发运行 aws 指定的 可等待对象 并阻塞线程直到满足 return_when 指定的条件。 如果 aws 中的某个可等待对象为协程，它将自动作为任务加入日程。 返回两个 Task/Future 集合: (done, pending)。 于是就可以这样调用，实现并发运行 1loop.run_until_complete(asyncio.wait(任务单（可为一个列表）)) 可等待对象如果一个对象可以在 await 语句中使用，那么它就是 可等待 对象有三种主要类型: 协程, 任务 和 Future. 协程协程属于可等待对象，因此可以在其他协程中被等待:（可用await被调用） 协程函数: 定义形式为 async def 的函数; 协程对象: 调用 协程函数 所返回的对象。 12345678910import asyncioasync def nested(): return 42async def main(): nested() # 用await调用协程 print(await nested())asyncio.run(main()) 直接调用nested就报错，说没有用await第二个用来await声明就可以调用了 任务任务 被用来设置日程以便 并发 执行协程。当一个协程通过 asyncio.create_task() 等函数被打包为一个 任务，该协程将自动排入日程准备立即运行 123456789import asyncioasync def nested(): return 42async def main():# 将nested函数用下面的方法打包成一个任务task# 用await调用任务 task = asyncio.create_task(nested()) await taskasyncio.run(main()) FuturesFuture 是一种特殊的 低层级 可等待对象，表示一个异步操作的 最终结果。当一个 Future 对象 被等待，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。通常情况下 没有必要 在应用层级的代码中创建 Future 对象。 创建任务asyncio.create_task(coro) 该函数用来并发运行作为 asyncio 任务 的多个协程。 将 coro 协程 打包为一个 Task 排入日程准备执行。返回 Task 对象。事件循环asyncio.get_running_loop()返回当前 OS 线程中正在运行的事件循环。如果没有正在运行的事件循环则会引发 RuntimeError。 此函数只能由协程或回调来调用。该任务会在 get_running_loop() 返回的循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError。 1234567891011121314151617181920import asyncioimport time# 创建一个延迟函数，控制延迟运行async def say_after(delay, what): await asyncio.sleep(delay) print(what) async def main(): task1 = asyncio.create_task( say_after(1, &#x27;hello&#x27;)) task2 = asyncio.create_task( say_after(2, &#x27;world&#x27;)) print(&quot;started at&quot;, time.strftime(&#x27;%X&#x27;)) # 两个task就像一个代办的任务，然后带着await执行他们 await task1 await task2 print(&quot;started at&quot;, time.strftime(&#x27;%X&#x27;))asyncio.run(main()) 可以发现运行时间和上面写的代码不一样了，就只有我们设置的最长的等待时间：两秒，说明实现了并发运行 休眠asyncio.sleep(delay, result=None) 阻塞：delay 指定的秒数 如果指定了 result，则当协程完成时将其返回给调用者 sleep() 总是会挂起当前任务，以允许其他任务运行 事件循环获取时间循环asyncio.get_running_loop()：返回当前 OS 线程中正在运行的事件循环，如果没有正在运行的事件循环则会引发 RuntimeError。 asyncio.get_event_loop()：获取当前事件循环， 如果当前 OS 线程没有设置当前事件循环并且 set_event_loop() 还没有被调用，asyncio 将创建一个新的事件循环并将其设置为当前循环 asyncio.set_event_loop(loop)：将 loop 设置为当前 OS 线程的当前事件循环 asyncio.new_event_loop()：创建一个新的事件循环 运行和停止loop.run_until_complete(future)：运行直到 future ( Future 的实例 ) 被完成如果参数是 coroutine object（协程） ，将被隐式调度为 asyncio.Task 来运行 loop.run_forever()：运行事件循环直到 stop() 被调用 loop.stop()：停止事件循环 学到这里，就有能力看懂小泽的这段代码了1234567891011121314151617181920212223242526272829import asyncioimport timeasync def english(): print(&#x27;小明正在学英语...&#x27;) await asyncio.sleep(2) print(&#x27;小明已经学了两秒英语...&#x27;)async def math(): print(&#x27;小明正在学数学...&#x27;) await asyncio.sleep(2) print(&#x27;小明已经学了两秒数学...&#x27;)async def zhexue(): print(&#x27;小明正在学哲学...&#x27;) await asyncio.sleep(4) print(&#x27;小明已经学了四秒哲学...&#x27;)if __name__ == &#x27;__main__&#x27;: start = time.time() # 建立任务库 renwu = [english(),math(),zhexue()] # 初始化地盘 dipan = asyncio.get_event_loop() # 放置任务 dipan.run_until_complete(asyncio.wait(renwu)) # 结束计时 end = time.time() print(&#x27;小明学完所有课程啦！总用时：&#x27;+str(end-start)+&#x27;秒！&#x27;)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"协程","slug":"协程","permalink":"http://example.com/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"爬虫学习笔记3","slug":"爬虫入门学习笔记3","date":"2021-01-04T17:21:45.769Z","updated":"2021-01-04T17:23:24.029Z","comments":true,"path":"2021/01/05/爬虫入门学习笔记3/","link":"","permalink":"http://example.com/2021/01/05/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/","excerpt":"","text":"爬虫入门学习笔记3get()和post()的数据请求 在get()里面叫paramas 在post()里面叫data 尝试动态页面的爬取（豆瓣排名）老规矩，先附上源代码： 1234567891011121314151617181920212223242526272829303132333435import requestsimport jsonurl=&#x27;https://movie.douban.com/j/chart/top_list?&#x27;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;params = &#123; &#x27;type&#x27;:&#x27;5&#x27;, &#x27;interval_id&#x27;:&#x27;100:90&#x27;, &#x27;action&#x27;:&#x27;&#x27;, &#x27;start&#x27;: &#x27;0&#x27;, &#x27;limit&#x27;:&#x27;20&#x27;&#125;response=requests.get(url=url,headers=header,params=params).content.decode()res=json.loads(response)for i in res: rating = i[&#x27;rating&#x27;][0] rank = i[&#x27;rank&#x27;] types = i[&#x27;types&#x27;] typess = &#x27;&#x27; for a in types: typess += a typess += &#x27;/&#x27; regions = i[&#x27;regions&#x27;][0] date = i[&#x27;release_date&#x27;] title = i[&#x27;title&#x27;] actors = i[&#x27;actors&#x27;] actorss = &#x27;&#x27; for b in actors: actorss += b actorss += &#x27;/&#x27; print(&#x27;电影名字：&#x27; + title) print(&#x27;排名：&#x27;,rank) print(&#x27;评分：&#x27; + rating) print(&#x27;主演：&#x27; + actorss) print(&#x27;上映时间：&#x27; + date + &#x27;/上映地区：&#x27; + regions + &#x27;/分类：&#x27; + typess) print(&#x27;-------------------------------------------------------------------&#x27;) 失败的尝试一开始使用xpath来爬取这个文本，但是发现不得行，爬了一个寂寞给我，后来了解到这是一个动态的页面，所以我们回忆起爬取有道翻译怎么操作的 必要信息的提取 打开network勾到XHR，看响应头，发现第三个是有效的信息 目标确定，接下来就是获取必要的信息来配置爬虫 找出真正的url 发现提交方式是get 发现返回的是json格式 翻到最下面，找到get请求的数据paramas配置好爬虫 之前爬取有道翻译的时候也涉及了json解密。 response=requests.get(url=url,headers=header,params=params).content.decode()对于这后面的.content.decode()这里说一下我的理解：由于返回的是json格式，不能用文本方式爬取，所以用最最基本的二进制方式爬取就对了，decode()指的是编码方式，默认就是字符串方式，刚好我们json.loads()就是要处理字符串12345678910111213import requestsimport jsonurl=&#x27;https://movie.douban.com/j/chart/top_list?&#x27;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;params = &#123; &#x27;type&#x27;:&#x27;5&#x27;, &#x27;interval_id&#x27;:&#x27;100:90&#x27;, &#x27;action&#x27;:&#x27;&#x27;, &#x27;start&#x27;: &#x27;0&#x27;, &#x27;limit&#x27;:&#x27;20&#x27;&#125;response=requests.get(url=url,headers=header,params=params).content.decode()res=json.loads(response) 数据的处理 解码出来的res是一个列表，列表里面是一个个的字典，每个字典代表一个电影 由于不美观，所我处理了一个电影好观察字典的键和值的对应关系这样就一目了然了照着这个处理后的字典，数据处理很简单，就不多说了12345678910111213141516171819202122for i in res: rating = i[&#x27;rating&#x27;][0] rank = i[&#x27;rank&#x27;] types = i[&#x27;types&#x27;] typess = &#x27;&#x27; for a in types: typess += a typess += &#x27;/&#x27; regions = i[&#x27;regions&#x27;][0] date = i[&#x27;release_date&#x27;] title = i[&#x27;title&#x27;] actors = i[&#x27;actors&#x27;] actorss = &#x27;&#x27; for b in actors: actorss += b actorss += &#x27;/&#x27; print(&#x27;电影名字：&#x27; + title) print(&#x27;排名：&#x27;,rank) print(&#x27;评分：&#x27; + rating) print(&#x27;主演：&#x27; + actorss) print(&#x27;上映时间：&#x27; + date + &#x27;/上映地区：&#x27; + regions + &#x27;/分类：&#x27; + typess) print(&#x27;-------------------------------------------------------------------&#x27;)","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"爬虫学习笔记2","slug":"爬虫入门学习笔记2","date":"2021-01-03T14:48:23.077Z","updated":"2021-01-04T17:23:22.553Z","comments":true,"path":"2021/01/03/爬虫入门学习笔记2/","link":"","permalink":"http://example.com/2021/01/03/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","excerpt":"","text":"爬虫入门学习笔记2一篇博客写太多不好翻，另起一篇来写 尝试更复杂的图片爬取这次玩个更难的试试，这个网址是泽上荧光大佬提供的，比较简单好欺负，我是一个猫奴，我们就不爬涩图，爬点小猫来玩玩，这个网址是很多辑，每一辑都有若干张图片可以发现每一辑里面是第几张图片网页的后面就会加上几个数字，我们就要利用这个小细节把页面里的所有图片都给他爬下来先附上完整代码：代码是参考小泽大佬的（基本就是硬搬hhh） 1234567891011121314151617181920212223242526import requestsfrom lxml import etreeimport osurl=&quot;http://www.win4000.com/zt/mao.html&quot;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;response=requests.get(url=url,headers=header).texttree = etree.HTML(response)leaf=tree.xpath(&#x27;//div[@class=&quot;tab_tj&quot;]//ul[@class=&quot;clearfix&quot;]/li/a/@href&#x27;)if not os.path.exists(&#x27;./maomao&#x27;): os.mkdir(&#x27;./maomao&#x27;)for a in leaf: try: b=1 while b&lt;11: c = a.split(&#x27;.html&#x27;)[0] d = c+&#x27;_&#x27;+str(b)+&#x27;.html&#x27; b += 1 e = requests.get(url=d,headers=header).text f = etree.HTML(e) g = f.xpath(&#x27;//div[@class=&quot;main&quot;]//div[@class=&quot;pic-meinv&quot;]/a/img/@src&#x27;)[0] h = requests.get(url=g,headers=header).content i = &#x27;maomao/&#x27;+g.split(&#x27;/&#x27;)[-1] with open(i,&#x27;wb&#x27;) as fp: fp.write(h) except : print(&quot;出错了&quot;) 老套路上他就完了12345678import requestsfrom lxml import etreeimport osurl=&quot;http://www.win4000.com/zt/dongman.html&quot;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;response=requests.get(url=url,headers=header).texttree = etree.HTML(response)leaf=tree.xpath(&#x27;//div[@class=&quot;tab_tj&quot;]//ul[@class=&quot;clearfix&quot;]/li/a/@href&#x27;) 文件比较多，我们创建一个文件夹创建文件夹叫maomao 12if not os.path.exists(&#x27;./maomao&#x27;): os.mkdir(&#x27;./maomao&#x27;) 图片的爬取之前我们爬取的网页都放在了leaf这个列表里，我们现在要打开那个链接把里面的图片一张张爬下来 因为不知道每一辑有多少图片，所以我们可以使用try语句防止运行的终止 12for a in leaf: try: 在每一辑中，每爬取一张图片就要打开下一个页面，爬取这一辑的下一张图片，所以我们设计一个循环，每次循环都在后边加一 12345678910for a in leaf: try: b=1 while b&lt;11: c = a.split(&#x27;.html&#x27;)[0] d = c+&#x27;_&#x27;+str(b)+&#x27;.html&#x27; b += 1 e = requests.get(url=d,headers=header).text f = etree.HTML(e) g = f.xpath(&#x27;//div[@class=&quot;main&quot;]//div[@class=&quot;pic-meinv&quot;]/a/img/@src&#x27;)[0] 关于这一步这个[0]，f.xpath(xxxx)返回的是一个列表，在这一步中列表就只有一个元素就是那个地址，后面加[0]实际上就是选择了这个地址元素并赋值给了g这个变量，所以g这个变量就可以直接当url了g = f.xpath(&#39;//div[@class=&quot;main&quot;]//div[@class=&quot;pic-meinv&quot;]/a/img/@src&#39;)[0] 爬取图片并储存到maomao文件夹中 上次说了图片要二进制爬取注意一个小细节，给图片命名的时候在前面加上了”maomao/“把路径指向了maomao文件夹 12345678910111213141516for a in leaf: try: b=1 while b&lt;11: c = a.split(&#x27;.html&#x27;)[0] d = c+&#x27;_&#x27;+str(b)+&#x27;.html&#x27; b += 1 e = requests.get(url=d,headers=header).text f = etree.HTML(e) g = f.xpath(&#x27;//div[@class=&quot;main&quot;]//div[@class=&quot;pic-meinv&quot;]/a/img/@src&#x27;)[0] h = requests.get(url=g,headers=header).content i = &#x27;maomao/&#x27;+g.split(&#x27;/&#x27;)[-1] with open(i,&#x27;wb&#x27;) as fp: fp.write(h) except : print(&quot;出错了&quot;) 大功告成！！！ 尝试有道翻译功能的动态爬取有道翻译是加密了的，不能直接爬取，具体解密可以看这个大佬学长的博客看了群里一个师傅发的代码，说吧url里的_o删掉就好了，我一试，还真行。先附上完整代码 1234567891011121314151617181920212223import requestsimport jsonword = input(&#x27;请输入想翻译的单词或句子：&#x27;)url = &quot;http://fanyi.youdao.com/translate?smartresult=dict&amp;&quot;header = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36 Edg/87.0.664.41&quot;&#125;data = &#123; &#x27;i&#x27; : word, &#x27;from&#x27; : &#x27;AUTO&#x27;, &#x27;to&#x27; : &#x27;AUTO&#x27;, &#x27;smartresult&#x27; : &#x27;dict&#x27;, &#x27;client&#x27; : &#x27;fanyideskweb&#x27;, &#x27;salt&#x27; : &#x27;16096771607986&#x27;, &#x27;sign&#x27; : &#x27;e72a9ef79c90a05a621157815772b913&#x27;, &#x27;lts&#x27; : &#x27;1609677160798&#x27;, &#x27;bv&#x27; : &#x27;4f7ca50d9eda878f3f40fb696cce4d6d&#x27;, &#x27;doctype&#x27; : &#x27;json&#x27;, &#x27;version&#x27; : &#x27;2.1&#x27;, &#x27;keyfrom&#x27; : &#x27;fanyi.web&#x27;, &#x27;action&#x27; : &#x27;FY_BY_REALTlME&#x27;, &#125;response = requests.post(url=url,data=data,headers=header).content.decode()res = json.loads(response)print(res[&#x27;translateResult&#x27;][0][0][&#x27;tgt&#x27;]) 知己知彼，进行网页审查 打开网页，F12把network的这个勾选上，选上了以后可以保存请求记录 随便输入一个单词点击翻译，找到这个箭头指的东西 url记录下来待会配置要用，记得我刚刚说的要把里面的_o删掉喔，不然爬不到的 发现这个网页是用post的方式传参的 翻到下面，把数据信息全部扒下来， 可以发现i的值就是我们输入的单词 from和to就是转换的语言，其他的不知道是什么，全部扒下来就是了 在这里发现返回的值是json的格式，所以我们需要导入json库来对其解码 按老方法整就是了1234567891011121314151617181920import requestsimport jsonword = input(&#x27;请输入想翻译的单词或句子：&#x27;)url = &quot;http://fanyi.youdao.com/translate?smartresult=dict&amp;&quot;header = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36 Edg/87.0.664.41&quot;&#125;data = &#123; &#x27;i&#x27; : word, &#x27;from&#x27; : &#x27;AUTO&#x27;, &#x27;to&#x27; : &#x27;AUTO&#x27;, &#x27;smartresult&#x27; : &#x27;dict&#x27;, &#x27;client&#x27; : &#x27;fanyideskweb&#x27;, &#x27;salt&#x27; : &#x27;16096771607986&#x27;, &#x27;sign&#x27; : &#x27;e72a9ef79c90a05a621157815772b913&#x27;, &#x27;lts&#x27; : &#x27;1609677160798&#x27;, &#x27;bv&#x27; : &#x27;4f7ca50d9eda878f3f40fb696cce4d6d&#x27;, &#x27;doctype&#x27; : &#x27;json&#x27;, &#x27;version&#x27; : &#x27;2.1&#x27;, &#x27;keyfrom&#x27; : &#x27;fanyi.web&#x27;, &#x27;action&#x27; : &#x27;FY_BY_REALTlME&#x27;, &#125; 接下来对翻译功能进行爬取 .content是转成二进制的意思 .decode()是指定编译格式，默认编码为字符串编码123response = requests.post(url=url,data=data,headers=header).content.decode()res = json.loads(response)print(res[&#x27;translateResult&#x27;][0][0][&#x27;tgt&#x27;]) 如果不进行json的解码，直接打印response的话 发现返回了一个字典，我们直接选中字典里的东西，会出现报错原因是这个其实是一串字符串，不是字典，只是长的和字典一样所以我们需要使用json.loads()函数来给他解个码，json库的详细解释这个博客说的很详细这个函数的具体作用就是：json.loads()函数可以将字符串转化为字典，但要保证,该字符串是以json格式组成的字符串，解完了码以后res是一个字典，我们就可以直接选中需要的东西了 那么什么是json勒JSON:一种与开发语言无关的、轻量级的数据存储格式格式：他有两种格式 Object{key:value,key:value…}key：string类型value：任何基本类型或数据结构 Array[value,value…]value：任何基本类型或数据结构。比如：{“name”:”李广”, “values”:[1,2,45,”你好”] } 总的来说就是类似于字典的格式，主要用来配置属性的（就像你玩一个游戏操控主角，主角的hp，mp是多少多少）更详细的解释可以看这篇博客","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"爬虫学习笔记1","slug":"爬虫入门学习笔记1","date":"2021-01-01T15:20:24.433Z","updated":"2021-01-03T14:49:32.513Z","comments":true,"path":"2021/01/01/爬虫入门学习笔记1/","link":"","permalink":"http://example.com/2021/01/01/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"爬虫入门学习笔记整了这么久，终于轮到爬虫了，之前一直对爬虫有所向往，现在学起来也是觉得很有意思，主要是通过一些大佬的博客来学习的，以下是我学习爬虫的学习笔记。 安装requests和BeautifulSoup4安装request：python本身提供的urllib没有python社区的requests库好用，现在主流都是用request来制作爬虫 打开cmd控制台 pip安装指令pip install requests 安装BeautifulSoup4：有了requests模块，可以使用他的get()方法来下载网页，但是下载的是网页的源代码，不利于信息的检索，所以有这个库来对其解析 打开cmd控制台 pip安装指令pip install bs4 开始写第一个爬虫，爬取百度网页爬取网页有几个步骤 指定你要爬取的url 使用requests的get方法来发起请求，返回响应对象 获取响应数据，转换成我们看得懂的形式 将爬取的内容储存 导入数据库1import requests 指定URL1u=&quot;https://www.baidu.com/&quot; 使用get方法爬取1response=requests.get(url=u) 设置编码为“utf-8”，不然网页打开是乱码1response.encoding = &quot;utf-8&quot; 获取响应数据，以text的形式给page1page=response.text 查看到response的形式是这个，所以要用.text来把他转化成文本格式 储存，把内容写进创建的baidu.html文件中12with open(&quot;baidu.html&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: f.write(page) 然后发现文件夹里就多了一个baidu的html文件 我的第二个爬虫，动态页面的爬取我们使用百度搜索一个东西，比如搜素爬虫，用上一个爬虫的方法不能爬取这个，要爬取动态页面，要给爬虫一个header找到这个user-agent，这个是给服务器说明访问的浏览器的信息（可以理解为一个身份证）在爬虫文件中创建一个字典 1idcard=&#123;&#x27;User-Agent&#x27;:&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;&#125; 在调用get()方法的时候给他一个headers属性，内容是刚刚创建的字典然后剩下的操作还是看那四部 1234567import requestsurl=&quot;https://www.baidu.com/s?wd=爬虫&quot;idcard=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;response=requests.get(url=url,headers=idcard) # 给他headers属性file=response.textwith open (&quot;wd.html&quot;,&quot;w&quot;,encoding=&#x27;utf-8&#x27;) as wd: wd.write(file) 发现文件中有wd.html文件了，打开就是搜索爬虫得到的网页了 爬虫etree配合xpath语句的学习并爬取b站分类表xpath是XML的路径语言，常与lxml库一起来解析网站完整详解这个博客中有比较详细介绍下面介绍我的学习思路 安装lxml控制台pip install lxml没啥好说的 导入库12import requestsfrom lxml import etree 通过etree.HTML()来解析网站,把网页数据解析 请求信息，处理信息 要爬取b站的信息，url设置到b站12url=&#x27;https://www.bilibili.com/&#x27;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125; 把爬取的信息文本化 1response=requests.get(url=url,headers=header).text 根据大佬的博客所说，把解析网站比喻成把网页数据变成一个大树，我们只取里面的几片叶子 1tree=etree.HTML(response) 接触到了xpath1leaf=tree.xpath(&#x27;//div[@id=&quot;primaryChannelMenu&quot;]/span/div[2]/a/span/text()&#x27;) 这时候print(leaf)就有结果了返回了一个列表，里面成功爬取了分类 xpath详解我自己的语法理解： 每递进一层就加一个/标签名 开头就是//两个斜杠就是直接跳转，不从开头开始一层一层的推 选择标签内的属性就用@属性名 选择有特殊标记的标签的语法//标签名[@属性名=&quot;xxx&quot;] 一层一层的推下去推到最后的时候选择要取得的信息：1，如果是标签里的文本信息就在最后加/text()如/a/span/text()2，如果是标签里面的属性就在最后加/@属性名如/a/@href 如果是很多兄弟元素可以使用标签名[排序数字]来选择例如div[1],这个排列数字是从1开始的，意思是第几个 例题 从根部开始，一级一级的找到了‘动画’xpath就可以写成：/html/body/div[2]/div/div[1]/div[3]/div/div[2]/span[1]/div/a/span/text()div[2]表示的是同级下第二个div，因为上面的svg标签里还有个div标签优化写法：因为我只要爬取这里的分类标签，所以：//div[@id=“primaryChannelMenu”]/span[1]/div/a/span/text() 这里只爬取了第一个“动画”，要爬取全部分类还得改一下这里有一排span标签，每一个都是一个分类，要把他里面的所以分类名爬取出来,我们就不要给span排列数字了，让他全选中leaf=tree.xpath(&#39;//div[@id=&quot;primaryChannelMenu&quot;]/span/div[2]/a/span/text()&#39;)成功！！！ 尝试图片的爬取这个网站很简单，结构都很简单，爬取里面的图片先附上完整的代码 123456789101112import requestsfrom lxml import etreeurl=&quot;https://www.qqtn.com/article/article_292075_1.html&quot;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;response=requests.get(url=url,headers=header).texttree=etree.HTML(response)leaf=tree.xpath(&#x27;//div[@id=&quot;zoom&quot;]/p/img/@src&#x27;)for i in leaf: a=requests.get(url=i,headers=header).content name=i.split(&quot;/&quot;)[-1] with open(name,&quot;wb&quot;) as f: f.write(a) 详解如下 导入库12import requestsfrom lxml import etree 设置响应头，把爬取网页信息并处理1234url=&quot;https://www.qqtn.com/article/article_292075_1.html&quot;header=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;response=requests.get(url=url,headers=header).texttree=etree.HTML(response) 写xpath语句 1leaf=tree.xpath(&#x27;//div[@id=&quot;zoom&quot;]/p/img/@src&#x27;) 图片是id=&quot;zoom&quot;的div里面的，所以可以双斜杠直接跳到这，发现第一个p没有图片而是文字介绍，不过没关系，第二个开始的p开始才有img标签，所以直接这样写可以忽略掉第一个p，最后选择img标签里的src属性 图片的储存这个时候直打印leaf出来的是图片的地址的列表我们要提取里面的图片并保存，就遍历这个列表，每次循环将图片保存下来 12345for i in leaf: a=requests.get(url=i,headers=header).content name=i.split(&quot;/&quot;)[-1] with open(name,&quot;wb&quot;) as f: f.write(a) 因为每次循环的i都是地址，所以我们继续用requests.get()方法来爬取图片网站，爬取下来要用二进制的形式来保存，就是加上.content（图片，视频，音频都是要用二进制来爬取的，要爬取文字就用.text） 命名图片，看他的地址https://pic.qqtn.com/up/2020-3/15847100617620054.jpg最后是xxxx.jpg，所以我们用字符串的切片split()以”/“来对地址切片，选择倒数第一片就是xxxx.jpg了 储存图片，命名是完整的，有jpg的后缀，所以我们直接open就行，注意打开方式是”wb”，因为我们前面是用二进制的形式爬取的内容，所以”b”不能忘记了 运行成功！！！","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Hexo博客的双线部署（github+coding）绑定自定义域名，以及遇到问题","slug":"Hexo博客的双线部署（github+coding）绑定自定义域名，以及遇到问题","date":"2020-12-27T09:45:33.626Z","updated":"2020-12-27T11:24:11.269Z","comments":true,"path":"2020/12/27/Hexo博客的双线部署（github+coding）绑定自定义域名，以及遇到问题/","link":"","permalink":"http://example.com/2020/12/27/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%EF%BC%88github+coding%EF%BC%89%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"Hexo博客的双线部署（github+coding）绑定自定义域名，以及遇到问题前段时间装修了一下我的博客,发现好看是好看了，但是访问速度慢下来了，安装了图片懒加载还是太慢，杯水车薪。后来看到双线部署的概念 把博客部署到github给境外使用，部署到coding给境内使用，这样访问速度会快很多。 本博客是基于已在github搭建了博客的基础上写的，如果github还没部署不推荐直接就双线部署 coding改版了，静态页面也改版了，分配到域名不像以前一样和github差不多，现在提供的域名是一个很大一串不美观的域名，不知道是我操作的问题还是改变了就是这样，希望大佬指正绑定ssh密钥这个步骤和绑定在github如出一辙，我就不多说了，coding界面也是中文的。与之前不一样的是注册的是团队，不能直接以个人注册了，并不妨碍 创建项目coding官方推荐的是这个，那就选这个吧 按提示创建好项目就行和库就行 修改config配置文件照着这个格式来，我推荐的是绑定ssh的地址，不用输入密码比较方便哈哈哈然后hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 三件套推上去就行了发现coding也有了 绑定自定义域名我是在腾讯云买的域名，这个见仁见智，喜欢到哪就到哪买呗DNS域名解析我也是在腾讯的DNSPod解析的照这样解析设置好coding有一个很坑的，现在静态页面跑到了下面，要自己打开持续部署打开静态页面创建一个网站节点就选香港吧，不用备案我这里出现了一个问题，自己搭建好的hexo不能选择网站类型中的hexo，会部署失败，但是代码来源选示例仓库就可以部署 下一步点自定义域名，把你买的域名输入进去，按照他说的在DNSPod解析域名处添加顺便把github的一起设置好 这里coding改版了，他给的地址是一大串东西而他给的CNAME 指向却不是这个地址设置好之后点一下部署，等个几分钟就可以访问了 讲一下github这边，github这边特别简单，打开你博客的仓库，打开设置往下翻，找到github pages，如图填写好就可以了可以发现我们的境内和境外已经分开了 我遇到的问题问题就出来了，我发现部署到coding后访问速度还是特别慢，他的ip根本就不是之前创建静态页面时选的香港，而还是国外的ip，访问速度和github一样慢甚至还更慢这不行，这还更慢我为什么还要双线部署，我就强行把CNAME指向改到了coding给的那个一大串的地址，访问速度一下就起来了但是这样做不行，证书不是你的，访问都有危险提示 所以我现在很迷惑，为什么给我的ip是国外的不能是那个香港的，coding为什么把这两个地址分开来，这样失去了双线部署的意义想求助一下大佬我哪个地方做错了？","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"域名部署","slug":"域名部署","permalink":"http://example.com/tags/%E5%9F%9F%E5%90%8D%E9%83%A8%E7%BD%B2/"}]},{"title":"butterfly主题配置记录","slug":"butterfly配置记录","date":"2020-12-26T12:33:59.091Z","updated":"2020-12-26T12:36:57.323Z","comments":true,"path":"2020/12/26/butterfly配置记录/","link":"","permalink":"http://example.com/2020/12/26/butterfly%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"安装依赖一开始要输入这个代码，不然打不开 1npm install hexo-renderer-pug hexo-renderer-stylus --save 添加关于和标签这两个不能直接去掉标注就生效，要生成一个page还要在md文件里加上 1234---title: tagsdate: 2020年12月24日15:14:16type: &quot;tags&quot; 1234---title: aboutdate: 2020年12月24日15:14:16type: &quot;about&quot; 添加鼠标和文字样式参考小康大佬参考木槿大佬把代码添加到：\\Butterfly\\source\\css\\_third-partynormalize.min.css末尾 背景的自定义参考大佬的博客：小康大佬自建一个css文件，在主题配置文件inject处引入 图片懒加载详情请看作者github：https://github.com/Troy-Yang/hexo-lazyload-image大佬的插件推荐：justlovesmile大佬 添加Valine大佬的博客X北辰北大佬博客讲的很详细了，主要提示一下butterfly主题有个小坑这里要把注释去掉，不是在冒号后面加Valine","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Python学习笔记","slug":"Python学习笔记","date":"2020-12-23T16:37:55.295Z","updated":"2020-12-30T15:49:21.507Z","comments":true,"path":"2020/12/24/Python学习笔记/","link":"","permalink":"http://example.com/2020/12/24/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Python中__new__函数的理解在小甲鱼的课程里，学到了__new__函数的时候，我刚看完他的例子，我是一脸懵逼啊，一点都没有头绪，为啥这样做？在看了几篇博客以后我稍有理解，在这里记录一下 new 是在一个对象实例化的时候所调用的第一个方法。它跟其他魔法方法不同，它的第一个参数不是 self 而是这个类（cls），而其他的参数会直接传递给 init 方法的。 个人理解：new方法是会在init方法前调用的，除了第一个参数，其他参数会返回给init 123456class Do (str): #继承str的方法 def __new__(cls,itstr): #调用__new__函数，传入字符串itstr itstr = itstr.upper() # 把每个字母大写 return str.__new__(cls,itstr) #返回实例对象给__init__函数d = Do(&#x27;AbcDeFg&#x27;) #创建实例对象print(d) 创建实例对象d的时候，本来是调用init函数的但是由于我们重写了new函数，所以在调用init函数之前会先调用new函数我们重写的new函数第二个参数是itstr，但是我们还要加工后再返回给init所以在加工完后return里写str.__new__(cls,itstr)重新调用new函数后把加工后的itstr返回给init函数所以在调用完了new后开始调用init时，init收到的参数是加工后的itstr，所以d的值就是“ABCDEFG”了 利用这个特点，我们可以在实例化初始化之前对传入的参数进行修改计算，修改以后再传给init，通熟的说就是“掉包”，例如 1234class Do(float): # 继承浮点数的方法 def __new__(cls, num): # 传入参数num return float.__new__(cls, num*1.5) # 对num加工后返回给initprint(Do(12)) 对类和对象，self，__init__的理解类和对象首先要拿class创建一个类，这个类就相当于一个图纸，创建对象就是类的实例化，就相当于那图纸造屋子，对象名=类名()就算是给这个类创建了一个对象，这个对象就是在这个类里面了 self一个类可以生成无数个对象，当对象的方法被调用时，对象会将自身作为第一个参数传给这个方法，这个时候python才知道到底这个方法是给哪个对象用的，所以这个self就像是一把钥匙，对应着这个对象对应的门。比如下面的代码 12345678class Person: # 创建了一个名为Person的类 def setname (self,itname): # 创建一个名为setname的方法，第一个参数为self self.itname = itname # 因为itname是外部变量，要在类中使用要加工 def printname (self): print(&quot;我是%s&quot; % self.itname)a = Person() # 实例化aa.setname(&quot;小明&quot;) # a作为self参数传入，&quot;小明&quot;作为itname参数传入a.printname() 对于self.itname的理解：itname是全局变量，要在类中使用还得加工一下，使用self.变量名将外部的变量引入类中使用，不加self.会被当做普通变量。 其实self的意义是绑定 12345678910class D: def setxy (self,x,y): self.x = x self.y = y def printxy(self): print(self.x,self.y)dd = D()dd.setxy(1,2) # 这一步实际上是这样调用的dd.setxy(dd,1,2)# 这个时候x=1,y=2是dd实例的私有的绑定在dd上的属性# 连类对象D都没有这个属性，del D删除了类对象dd.printxy()一样能打印出来 提示：可以使用__dict__方法查看对象的属性如dd.__dict__ init这是一个构造函数（构造方法），实例化对象时，该方法会在对象被创建的时候自动调用，实例化对象的时候是可以传入参数的，这些参数会自动传入该方法中，通过重写该方法可以自定义对象的初始化操作，不重写就默认调用init(self)。，类名就作为self，看如下代码。 1234567class Person: def __init__ (self,itname): # 额外添加一个参数，实例化对象时输入的内容就作为itname的参数 self.itname = itname def printname (self): print(&quot;我是%s&quot; % self.itname)a = Person(&quot;小明&quot;) # 创建类的时候就可以直接传入参数，类名作为self，&quot;小明&quot;作为itnamea.printname() 用类和对象写一个计时器在学了一些类和对象之后，在书上看到一个例子，用类和对象打造一个计时器，我一开始没有思路，大概看了一下书上的例题后有了思路，下面是我自己写的代码（借鉴例子） 1234567891011121314151617import timeimport mathclass Count: def start(self): self.start=time.localtime() print(&quot;开始计时&quot;) def stop(self): self.stop=time.localtime() self.do() print(&quot;计时结束&quot;) def do(self): self.sec=math.fabs(self.stop[5]-self.start[5]) self.min=self.stop[4]-self.start[4] print(&quot;运行了%d秒&quot; % (self.sec+self.min*60))t=Count()t.start()t.stop() 首先我去查了一下time模块的内容，找到了这个用法说明 12345#作用：用于单独获取时间的某一部分t = time.localtime()print(t)#输出结果time.struct_time(tm_year=2020, tm_mon=12, tm_mday=18, tm_hour=20, tm_min=57, tm_sec=2, tm_wday=4, tm_yday=353, tm_isdst=0) 他会返回一个元组，下标是4，5对应分钟和秒钟，只需要让他们相减就可以 看了书上的写法，比我的高明很多，先留坑，以后把改善后的代码补回来","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"vscode使用笔记","slug":"vscode使用笔记","date":"2020-12-12T16:00:00.000Z","updated":"2020-12-16T15:17:37.889Z","comments":true,"path":"2020/12/13/vscode使用笔记/","link":"","permalink":"http://example.com/2020/12/13/vscode%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"vscode使用笔记","text":"vscode使用笔记 推荐安装的插件这里主要推荐三款核心插件，其余的可以按需选择。 1.Markdown All in One：目前 Vscode 最流行的 Markdown 语法解析器。 2.Markdown PDF：使用的 Markdown 文件渲染导出插件。 3.Markdown TOC：一款针对 Github 等平台自动生成文章目录的插件（目前主流的博客平台如 CSDN 已经不需要自己在文中生成目录了）。 使用vscode预览Markdown文件 VScode已经默认集成markdown文档编辑插件,所以编辑md文件时已经有代码高亮。要实时预览的话按Ctrl+shift+p 后搜索Markdown找到这个 或使用快捷键Ctrl+k 放掉以后再按v 导入图片导入图片语法： 只记录一种图片插入方式 1![](xxx.png) 可以是本地的路径也可以是网络上的图片地址 导入代码块1使用&#96;&#96;&#96;代码内容&#96;&#96;&#96; 大佬的博客有更全面的介绍https://www.cnblogs.com/jpfss/p/10941921.html vscode配置c/c++编译调试环境下载好MinGW，配置系统环境 安装插件打开vscode把这两个插件安装好，按这个小三角就可以直接运行了 配置调试环境但是代码出现了问题不能调试，所以我们还得配置一下调试环境都选第一个会发现弹出一个文件，别管他直接关掉就好，现在的vscode会直接帮你配置好，不需要像其他博主那样自己创建自己输入现在就可以调试了，大功告成","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"}]},{"title":"前端学习笔记","slug":"前端学习笔记HTML5，CSS3（更新中）","date":"2020-12-12T16:00:00.000Z","updated":"2020-12-26T08:52:46.667Z","comments":true,"path":"2020/12/13/前端学习笔记HTML5，CSS3（更新中）/","link":"","permalink":"http://example.com/2020/12/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0HTML5%EF%BC%8CCSS3%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/","excerpt":"前端学习笔记","text":"前端学习笔记 网页分成三个部分： 结构(HTML) 表现(CSS) 行为(JavaScript)css简介与使用1.内部样式 将样式编写到head中的style标签里然后通过CSS的选择器来选中元素并为其设置各种样式可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用 内部样式表更加方便对样式进行复用 缺点：我们的内部样式表只能对一个网页起作用，它里边的样式不能跨页面进行复用 2.外部样式表以将CSS样式编写到一个外部的CSS文件中,然后通过link标签来引入外部的CSS文件 外部样式表需要通过link标签进行引入，意味着只要想使用这些样式的网页都可以对其进行引用使样式可以在不同页面之间进行复用 将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验。css的语法1.注释：/**/ 2.基本语法：选择器 声明块 选择器，通过选择器可以选中页面中的指定元素比如 p 的作用就是选中页面中所有的p元素 声明块，通过声明块来指定要为元素设置的样式声明块由一个一个的声明组成 声明是一个名值对结构一个样式名对应一个样式值，名和值之间：以:连接 ，以;结尾 选择器1.常用选择器 元素选择器作用：根据标签名来选中指定的元素语法：标签名{}例子：p{} h1{} div{} id选择器作用：给元素设定id属性，根据元素的id属性值选中一个元素 语法：#id属性值{} 例子：#box{} #red{} 类选择器作用：给元素设定，根据元素的class属性值选中一组元素 语法：.class属性值 好处：既可以给单一标签设定样式，也可以给一组标签设定样式 通配选择器 作用：选中页面中的所有元素 语法: * 2.复合选择器 交集选择器作用：选中同时复合多个条件的元素 语法：选择器1选择器2选择器3选择器n{} 注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头 并集选择器作用：同时选择多个选择器对应的元素，其中可以是交集选择器语法：选择器1,选择器2,选择器3,选择器n{}例子： #b1,.p1,h1,span,div.red{} 关系选择器介绍标签关系： 123456789父元素：直接包含子元素的元素叫做父元素子元素：直接被父元素包含的元素是子元素祖先元素：1.直接或间接包含后代元素的元素叫做祖先元素2.一个元素的父元素也是它的祖先元素后代元素：1.直接或间接被祖先元素包含的元素叫做后代元素2.子元素也是后代元素兄弟元素：拥有相同父元素的元素是兄弟元素 子元素选择器作用：选中指定父元素的指定子元素 语法：父元素 &gt; 子元素 后代元素选择器作用：选中指定元素内的指定后代元素 语法：祖先 后代 兄弟选择器1.选择下一个兄弟 语法：前一个 + 下一个 选择紧贴着p的span的兄弟元素 2.选择下边所有的~符号后面标签名的兄弟 语法：兄 ~ 弟选择p后面的所有的span兄弟元素 属性选择器语法：[属性名] 选择含有指定属性的元素[属性名=属性值] 选择含有指定属性和属性值的元素[属性名^=属性值] 选择属性值以指定值开头的元素[属性名$=属性值] 选择属性值以指定值结尾的元素[属性名*=属性值] 选择属性值中含有某值的元素的元素 伪类选择器伪类（不存在的类，特殊的类）伪类用来描述一个元素的特殊状态比如：第一个子元素、被点击的元素、鼠标移入的元素…伪类一般情况下都是使用:开头 :empty 匹配冒号前面元素的类型中没有子元素的元素 :only-child 匹配他的父元素中只有唯一子元素的子元素(匹配的是冒号前的元素，也就是那个子元素) :first-child 第一个子元素:last-child 最后一个子元素:nth-child() 选中第n个子元素 :nth-last-child(n) 指定每个冒号前元素，匹配该元素的同级兄弟元素里倒数第n个元素 特殊值：n 第n个 n的范围0到正无穷2n 或 even 表示选中偶数位的元素2n+1 或 odd 表示选中奇数位的元素以上这些伪类都是根据所有的子元素进行排序 :first-of-type:last-of-type:nth-of-type():nth-last-of-child(n)这几个伪类的功能和上述的类似，不同点是他们是在冒号前元素的父元素里面的同类型元素中进行排序:not() 否定伪类将符合条件的元素从选择器中去除 a元素的伪类语法：:link 用来表示没访问过的链接（正常的链接）:visited 用来表示访问过的链接，由于隐私的原因，所以visited这个伪类只能修改链接的颜色。:hover 用来表示鼠标移入的状态:active 用来表示鼠标点击下去的瞬间（如果鼠标一直按住不放就不是瞬间哈哈哈） 直接在a元素里设置color属性，不管上面的点没点过，hover不hover都是那个颜色要想设置这些属性就再a:hover{colorxxx}就可以 伪元素选择器伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）伪元素使用 :: 开头语法：::first-letter 表示第一个字母::first-line 表示第一行::selection 表示鼠标拖动选中的内容::before 元素的开始::after 元素的最后before 和 after 必须结合content属性来使用 选择器权重 样式 权重 内联样式 1000 id选择器 0100 类和伪类选择器 0010 元素选择器 0001 通配选择器 0000 继承 没有优先级 1.比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）, 一般来说选择器越详细优先级越高。 2.选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器如果优先级计算后相同，此时则优先使用靠下的样式 3.可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式。注意：在开发中这个玩意一定要慎用！ 单位长度单位 像素屏幕（显示器）实际上是由一个一个的小点点构成的不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰所以同样的200px在不同的设备下显示效果不一样 百分比也可以将属性值设置为相对于其父元素属性的百分比设置百分比可以使子元素跟随父元素的改变而改变 emem是相对于元素的字体大小来计算的1em = 1font-size系统默认的font-size是16pxem会根据字体大小的改变而改变当加上font-size时会根据font-size来布置 remrem是相对于根元素的字体大小来计算与em同理，只不过他认定的font-size是根元素html里的font-size 123html&#123; font-size=10px&#125; 颜色颜色单位 颜色名在CSS中可以直接使用颜色名来设置各种颜色比如：red、orange、yellow、blue、green … …但是在css中直接使用颜色名是非常的不方便 RGB值：RGB通过三种颜色的不同浓度来调配出不同的颜色R：red，G：green ，B：blue每一种颜色的范围在 0 - 255 (0% - 100%) 之间语法：RGB(红色,绿色,蓝色) RGBA:就是在rgb的基础上增加了一个a表示不透明度需要四个值，前三个和rgb一样，第四个表示不透明度1表示完全不透明 0表示完全透明 .5半透明 十六进制的RGB值：语法：#红色绿色蓝色颜色浓度通过 00-ff如果颜色两位两位重复可以进行简写#aabbcc –&gt; #abc，而#aabbcd就不能简写一定要RGB每一项都两两重复 HSL值 HSLA值H 色相(0 - 360)S 饱和度，颜色的浓度 0% - 100%（100%最正）L 亮度，颜色的亮度 0% - 100%（50%最正）A 不透明度，和之前的一样 layout关系着整个网页的布局 文档流文档流（normal flow） 网页是一个多层的结构，一层摞着一层 通过CSS可以分别为每一层来设置样式 作为用户来讲只能看到最顶上一层 这些层中，最底下的一层称为文档流，文档流是网页的基础 我们所创建的元素默认都是在文档流中进行排列 对于我们来元素主要有两个状态 在文档流中 不在文档流中（脱离文档流） 元素在文档流中有什么特点：块元素： 块元素会在页面中独占一行(自上向下垂直排列) 默认宽度是父元素的全部（会把父元素撑满） 默认高度是被内容撑开（子元素） 行内元素： 行内元素不会独占页面的一行，只占自身的大小 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素则元素会换到第二行继续自左向右排列（书写习惯一致） 行内元素的默认宽度和高度都是被内容撑开 盒子模型盒模型、盒子模型、框模型（box model） CSS将页面中的所有元素都设置为了一个矩形的盒子 将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置 每一个盒子都由一下几个部分组成：内容区（content）内边距（padding）边框（border）外边距（margin） 内容区（content），元素中的所有的子元素和文本内容都在内容区中排列内容区的大小由width 和 height两个属性来设置 width 设置内容区的宽度 height 设置内容区的高度 123width: 200px;height: 200px;background-color: #bfa; 边框（border），边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部边框的大小会影响到整个盒子的大小要设置边框，需要至少设置三个样式： 边框的宽度 border-width 边框的颜色 border-color 边框的样式 border-style 123border-width: 10px;border-color: red;border-style: solid 边框不会影响内容区的大小，但会影响整个盒子模型的大小 边框边框 (border) 边框的宽度 border-width 边框的颜色 border-color 边框的样式 border-style 宽度border-width: 10px; 默认值，一般都是 3个像素border-width可以用来指定四个方向的边框的宽度值的情况 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 除了border-width还有一组 border-xxx-widthxxx可以是 top right bottom left用来单独指定某一个边的宽度 颜色border-color用来指定边框的颜色，同样可以分别指定四个边的边框规则和border-width一样border-color也可以省略不写，如果省略了则自动使用color的颜色值 1color: red; 样式border-style 指定边框的样式，默认值是none 表示没有边框 solid 表示实线 dotted 点状虚线 dashed 虚线 double 双线 简写属性 border简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求 除了border以外还有四个 border-xxx border-top border-right border-bottom border-left 这个方式比较方便所以用的比较多 1border: 10px red solid; 内边距（padding） 内容区和边框之间的距离是内边距 一共有四个方向的内边距： padding-top padding-right padding-bottom padding-left 简写属性和border一样遵循上左下右规则padding: 10px 20px 30px 40px; 内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距上 一共盒子的可见框的大小，由内容区 内边距 和 边框共同决定， 所以在计算盒子大小时，需要将这三个区域加到一起计算 外边距（margin）外边距不会影响盒子可见框的大小但是外边距会影响盒子的位置 一共有四个方向的外边距：margin-top：上外边距，设置一个正值，元素会向下移动margin-right：默认情况下设置margin-right不会产生任何效果margin-bottom：下外边距，设置一个正值，其下边的元素会向下移动margin-left：左外边距，设置一个正值，元素会向右移动 margin也可以设置负值，如果是负值则元素会向相反的方向移动 元素在页面中是按照自左向右的顺序排列的，都往左上角挤，所以默认情况下如果我们设置的左和上外边距则会移动元素自身，而设置下和右外边距会挤开其他元素 margin的简写属性：margin 可以同时设置四个方向的外边距 ，用法和padding一样 margin会影响到盒子的实际占用空间 盒子的水平布局元素的水平方向的布局：元素在其父元素中水平方向的位置由以下几个属性共同决定 margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须要满足以下的等式margin-left+border-left+padding-left+width+padding-right+border-right+margin-right = 其父元素内容区的宽度 （必须满足）以上等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整调整的情况：1，如果这七个值中没有为 auto 的情况，则浏览器会自动调整margin-right值以使等式满足，所以之前说调margin-right不会有任何效果，一般来说margin-right是由浏览器自己来调节的。2，如果要设置auto，七个值有三个可以设置auto： width margin-left maring-right 1，如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0 2，如果将三个值都设置为auto，则外边距都是0，宽度最大 3，如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值可以利用这个原理让元素在父元素中居中 12width:200px;margin:0 auto; 这个0是上下外边距，auto是左右外边距 总的来说1，七个属性要满足等式。2，如果不满足就会自动调整： 如果没设置auto则自动调整margin-right填满父元素 如果设置了auto分情况 垂直方向的布局默认情况下父元素的高度被内容撑开垂直方向上内容（包括子元素的边框边距等等）多高父元素就被撑的多高 如果父元素高度被设定，那该是多少就是多少。 子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用 overflow 属性来设置父元素如何处理溢出的子元素可选值： visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示 hidden 溢出内容将会被裁剪不会显示 scroll 生成两个滚动条，通过滚动条来查看完整的内容 auto 根据需要生成滚动条（有的时候不需要两个滚动条，就用auto就好） 垂直外边距的折叠我们给这两个元素分别设置上下外边距的时候，有一个不生效 相邻的垂直方向外边距会发生重叠现象兄弟元素： 兄弟元素间的相邻垂直外边距会取两者之间的较大值（两者都是正值） 特殊情况：如果相邻的外边距一正一负，则取两者的和如果相邻的外边距都是负值，则取两者中绝对值较大的 兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理 父子元素： 父子元素间相邻外边距，子元素的会传递给父元素（上外边距） 父子外边距的折叠会影响到页面的布局，必须要进行处理方法1：设置父元素的padding再改height方法2：以后再说更好的 行内元素的盒模型行内元素的盒模型 行内元素不支持设置宽度和高度 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局 行内元素可以设置border，垂直方向的border不会影响页面的布局 行内元素可以设置margin，垂直方向的margin不会影响布局display 用来设置元素显示的类型可选值： inline 将元素设置为行内元素 block 将元素设置为块元素 inline-block 将元素设置为行内块元素行内块，既可以设置宽度和高度又不会独占一行 table 将元素设置为一个表格 none 元素不在页面中显示a是行内元素，通过display把他设置成块元素，宽高就能实现了 visibility 用来设置元素的显示状态可选值： visible 默认值，元素在页面中正常显示 hidden 元素在页面中隐藏 不显示，但是依然占据页面的位置与none的区别，none直接是消失，不会给他留位置","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"hexo主题yilia个性化","slug":"hexo主题yilia个性化","date":"2020-12-11T16:00:00.000Z","updated":"2020-12-12T03:58:03.494Z","comments":true,"path":"2020/12/12/hexo主题yilia个性化/","link":"","permalink":"http://example.com/2020/12/12/hexo%E4%B8%BB%E9%A2%98yilia%E4%B8%AA%E6%80%A7%E5%8C%96/","excerpt":"展开全文的美化","text":"展开全文的美化 在md文件中加这个标签会有两个跑出来，我觉得很不美观所以找了另一个办法在yilia的_config.yml中把这个more改成空格就行了 为博客网站更换logo1.将图片放在yilia的img文件夹里 2.在yilia的config文件里把路径加上 展开全文的使用1、node.js版本必须6.2以上2、在hexo根目录下执行命令：npm i hexo-generator-json-content --save3.在根目录下的config里加入 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 但是我的出现了问题没有标题在上面，那就没什么用了后来查资料我发现要在md文件头部加上这个东西title是标题，所有文章的索引就是依靠这个东西来标注的，tags是标签，要注意tags的格式不要搞错了。 左侧栏的美化不知道是不是我自己的原因，在根目录改的作者名和个性签名不能显示出来，所以一言也无法使用，后来百度了一下，说是现在的yilia会优先选择主题的author和subtitle，所以要在yilia的config文件里加上author和subtitle。 添加一言后来检查了一些别的大佬的主题设置，发现这样写是可以加上一言的在layout\\partial\\left-col文件里找到&lt;p class=&quot;header-subtitle&quot;&gt;&lt;%=theme.subtitle%&gt;&lt;/p&gt;，把他换成下面这几段 1234&lt;a id=&quot;hitokoto&quot; href=&quot;#&quot; onmouseover=&quot;this.style.color=&#x27;#7fffd4&#x27;;&quot; onmouseout=&quot;this.style.color=&#x27;aliceblue&#x27;;&quot;&gt;_(:з」∠)_ 加载中...&lt;/a&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt; 这样就可以了 为左边栏子自定义图片背景1.打开\\themes\\yilia\\source\\main.xxxx.css文件 2.用你的编辑器在里面找到.left-col{ 3.在这个标签里删除background属性并加上background-image:url(“”);属性","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"http://example.com/tags/yilia/"}]},{"title":"github上搭建好个人博客上传文件没有小绿格记录","slug":"github上搭建好个人博客上传文件没有小绿格记录","date":"2020-12-08T16:00:00.000Z","updated":"2020-12-13T06:41:10.263Z","comments":true,"path":"2020/12/09/github上搭建好个人博客上传文件没有小绿格记录/","link":"","permalink":"http://example.com/2020/12/09/github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%A5%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E5%B0%8F%E7%BB%BF%E6%A0%BC%E8%AE%B0%E5%BD%95/","excerpt":"github上搭建好个人博客上传文件没有小绿格记录","text":"github上搭建好个人博客上传文件没有小绿格记录 本来想搭建博客后在上面更新博客在github上打卡小绿格记录但是发现小绿格没有出来我搭建完博客后上传到github的内容是这么些，但是我上传博客却不是在这里上传我是把md文件放到这个文件夹里使用下面三个命令来实现博客推送而不是git push的方式 123hexo cleanhexo ghexo d 但是我看到第一个文件夹里其实有更新的博客但是就是没有小绿格我看了一下我有两个branch，main和master，我的博客文件放在master里，而一个无关紧要的branch main被我创建库的时候设成了default,于是我就想改一下分支，但是没搞懂git的使用方法原理，把博客搞崩溃了。我干脆就删掉那个库重新搭建了一个博客，这次我就只设置了一个分支master搭够好了博客后我就发现使用hexo的三部上传博客也可以出现小绿格了。","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"在github创建库并向上上传文件","slug":"在github创建库并向上上传文件","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-20T15:02:16.451Z","comments":true,"path":"2020/12/08/在github创建库并向上上传文件/","link":"","permalink":"http://example.com/2020/12/08/%E5%9C%A8github%E5%88%9B%E5%BB%BA%E5%BA%93%E5%B9%B6%E5%90%91%E4%B8%8A%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","excerpt":"在github创建库并向上上传文件","text":"在github创建库并向上上传文件 我之前已经创建过库，绑定了密钥，所以省了很多步骤我就记录了一下过程怕自己忘记 1，先在github创建一个库复制这个链接到时要用 2.在本地创建一个文件夹在文件夹中使用git clone http....(这个是刚刚复制的地址)出现了你在github中创建的库的文件 上传文件1.打开后git bash here，将你要上传的文件放到里面再使用git add . 这个git add .的意思是：将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把.换成这个特定的文件名。 2.使用git commit -m “xxx” xxx是该文件的提交的注释说明 3.使用git push -u origin main这个’main’是分支名，每个人可能不一样这一步做完就算完成了详细教学可以参考其一其二这个我觉得是写的最好的 以后要更新你的库就输入这几个命令：123git add .git commit -m &quot;&quot;git push origin main（那个-u是第一次上传的时候要用的） 每次push要输入密码push了几天以后，我发现每次push都要密码，贼麻烦，所以我就找了一下原因，原来我们直接clone下来的库默认是https的形式，所以每次都要输入密码但是如果改成ssh的形式就不用输入密码了具体的操作就看这个大佬的博客吧","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"指针练习","slug":"指针练习题","date":"2020-11-18T16:00:00.000Z","updated":"2020-12-13T06:41:12.611Z","comments":true,"path":"2020/11/19/指针练习题/","link":"","permalink":"http://example.com/2020/11/19/%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"使用指针方法实现字符串逆序存放后再输出","text":"使用指针方法实现字符串逆序存放后再输出 编写程序：从键盘任意输入一个字符串，输出该字符串。然后，将该字符串逆序存放后再输出，要求用字符指针完成。（提示：逆序存放的函数接口：void invstr(char *s)） 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;void invstr(char *s)&#123; char b; int len; len=strlen(s); /*获取该字符串的长度*/ for(int i=0;i&lt;len/2;i++)&#123; /*该循环的目的是每次将字符串的头和尾换一下位置*/ b=*(s+i); /*字符串的第i个元素的地址暂时放到b里*/ *(s+i)=*(s+len-1-i); /*将字符串的倒数第i个元素换到第i个元素*/ *(s+len-1-i)=b; /*再将b存放的地址放回倒数第i个元素*/ &#125; &#125;int main()&#123; char a[1000]; gets(a); /*输入字符串*/ printf(&quot;%s\\n&quot;,a); /*正序输出一次*/ invstr(a); /*运行函数*/ printf(&quot;%s&quot;,a); /*逆序输出*/ &#125; 利用指针编程，用指针方法编写一函数，实现两个字符串的比较。编程点拨：即自己编写一个strcmp函数：strcmp(s1,s2)，如果s1= s2，返回值为0，如果s1≠s2, 返回它们二者第一个不同字符的ASCII码差值(如”BOY”与”BAD”, 第二个字母不同，”O”与”A”之差为79-65=14)。如果要s1&gt;s2，则输出正值，如果s1&lt;s2，则输出负值。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;void strcmp(char *s1,char *s2)&#123; int len,i=0,sum=0,lenmax; lenmax = strlen(s1); len = strlen(s2); if(lenmax &lt; len)&#123; lenmax = len; &#125; for(i=0;i&lt;lenmax and sum==0;i++)&#123; if(*(s1+i) &gt; *(s1+i))&#123; sum = *(s1+i) - *(s2+i); &#125; if(*(s1+i) &lt; *(s2+i))&#123; sum = ( - (*(s1+i) - *(s2+i))); &#125; &#125; printf(&quot;%d&quot;,sum);&#125;int main()&#123; char s1[1000],s2[1000]; gets(s1); gets(s2); strcmp(s1,s2); &#125;","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://example.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"}]},{"title":"使用Hexo在Github上创建博客","slug":"使用Hexo在Github上创建博客","date":"2020-10-18T16:00:00.000Z","updated":"2021-01-02T17:54:43.766Z","comments":true,"path":"2020/10/19/使用Hexo在Github上创建博客/","link":"","permalink":"http://example.com/2020/10/19/%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"使用Hexo在Github上创建博客","text":"使用Hexo在Github上创建博客 前言先说明一下，我在此时只是一位刚上大一的新生，还啥都不懂，文中如果有什么错误或不规范的地方请各位大佬斧正，我定会虚心接受。在10月18日晚上，学长给我布置了个作业，让我在github上构建属于自己的博客网站，我了解了一下，觉得有个属于自己的网站简直太帅了，于是就兴冲冲的开始了搭建，在10月19号下午，废物的我终于搭建好了。于是在此记录一下我搭建的过程。 一、安装必备插件Git，Node.js安装Git和Node.js我就不在此多加赘述，哪里都能找到，而且讲的也详细。 二、安装Hexo1、在电脑中创建文件夹比如我是这样创建的 2、进入这个文件夹按右键选择Git bash here打开小黑框 3、依次输入1npm install -g hexo 安装Hexo的基础框架。 1hexo init 初始化hexo。 1npm install 安装相关组件。 1hexo s 生成静态页面 这个时候你可以在本地访问自己的网站了。 但是也只仅限于你，接下来我们要把这玩意上传到Github里面，让所有人都能访问。 三、将本地内容上传到Github里1、注册一个Github账号2、创建一个仓库 3、配置Github的个人数据123git config --global user.name &quot;xxxname&quot; git config --global user.email &quot;xxxemail&quot; xxx是你自己的用户名，配置完成后可以输入下面的代码来验证 1git config --list 如果出现了问题，用下面两个代码重新设置 123$ git config --global --replace-all user.email &quot;输入你的邮箱&quot; $ git config --global --replace-all user.name &quot;输入你的名字&quot; 4、设置你的ssh密钥1ssh-keygen -t rsa -C &quot;xxxemail&quot; 注意上面代码的C要大写喔代码输入了以后一直按回车就好，直到出现这个页面就OK了然后我们可以直接在小黑框中调出密钥 1cat ~/.ssh/id_rsa.pub 从ssh-rsa开始一直到.com全部复制下来上传ssh就可以了像这样就成功了然后我们可以在小黑框上输入ssh -T git@github.com进行验证看到他和你打招呼了就意味着OK了 5、上传到Github用记事本打开这个文件，直接拉到最下面，按照这个格式打好，注意红点标注了的地方是有一个空格的 然后再到小黑框里输入npm install hexo-deployer-git --save 123hexo cleanhexo ghexo d 这个时候你的网站就算搭建完成了！可以让别人访问了http://你自己的用户名.github.io 上传博客将博客文件放到文件夹里后执行三个命令 123hexo cleanhexo ghexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"cookie","slug":"cookie","permalink":"http://example.com/tags/cookie/"},{"name":"协程","slug":"协程","permalink":"http://example.com/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"事件循环","slug":"事件循环","permalink":"http://example.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"域名部署","slug":"域名部署","permalink":"http://example.com/tags/%E5%9F%9F%E5%90%8D%E9%83%A8%E7%BD%B2/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/tags/vscode/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"yilia","slug":"yilia","permalink":"http://example.com/tags/yilia/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"c语言","slug":"c语言","permalink":"http://example.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"}]}